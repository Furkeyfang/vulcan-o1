{"id": 2, "instruction": "Place a 2x2x2 cube at (5, 0, 0) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a simple static transformation task requiring precise geometric placement and orientation. The objective is to create a cube with specific dimensions (2x2x2), position it at coordinates (5, 0, 0), and apply a 45° rotation about the Y-axis. The main challenge is ensuring the rotation is applied correctly relative to the cube's origin, and that the dimensions exactly match the specification. No physics simulation is required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2m x 2m x 2m (each side length = 2).\n- Cube Center Position: (5, 0, 0) in world coordinates.\n- Rotation: 45° about the Y-axis. In Blender, rotations are in radians: 45° = π/4 ≈ 0.7854 rad.\n- The cube's local origin coincides with its geometric center by default in Blender's cube primitive.\n- Bounding Box: After rotation, the cube's corners will be at positions rotated about its center at (5,0,0). The axis-aligned bounding box will expand due to rotation.\n</spatial_layout>\n\n<kinematic_topology>\nStatic object with no joints or hierarchy.\n- world -> cube_object (Single mesh with transform)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The cube is static. However, if later used in physics simulation, note:\n- Mass: Could be derived from volume if material density is known (not required here).\n- Stability: The cube rests flat if rotation were zero, but with Y rotation, it stands on one edge line if placed on ground plane at Z=0, potentially unstable.\n</predictive_simulation>\n\n<parameter_summary>\ncube_size: 2.0\ncube_location: (5.0, 0.0, 0.0)\ncube_rotation_y_deg: 45.0\ncube_rotation_y_rad: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with dimensions 2x2x2\n# Default cube in Blender is 2x2x2, but its scale is (1,1,1) meaning 2 units in each direction\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Target_Cube\"\n\n# Set location: (5, 0, 0)\ncube.location = (5.0, 0.0, 0.0)\n\n# Rotate 45° about Y-axis\n# Convert degrees to radians\nrot_y_rad = math.radians(45.0)\ncube.rotation_euler = (0.0, rot_y_rad, 0.0)\n\n# Verify dimensions: scale should remain (1,1,1) for a 2x2x2 cube\ncube.scale = (1.0, 1.0, 1.0)\n\n# Optionally, set display to show transformations clearly\nbpy.context.space_data.overlay.show_extra_indices = True\n```\n</implementation>"}
{"id": 5, "instruction": "Place a 3x1x1 cube at (-4, 1, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a basic static placement task requiring precise object creation, scaling, location, and rotation. The primary challenge is correctly interpreting the dimensions (3x1x1 likely meaning length, width, height) and applying the Y-axis rotation in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Length (X) = 3.0 units, Width (Y) = 1.0 unit, Height (Z) = 1.0 unit.\n- Final Location: (-4.0, 1.0, 0.0) in world coordinates.\n- Final Rotation: 15° counter-clockwise around the global Y-axis (when viewed from above). In radians: 15 * (π/180) ≈ 0.261799.\n- Local Origin: By default, the cube's origin is at its geometric center. After scaling, the cube's local bounds will be ±1.5 along X, ±0.5 along Y, and ±0.5 along Z.\n</spatial_layout>\n\n<kinematic_topology>\nStatic object with no hierarchy or joints. Single mesh object parented directly to the world.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. Placement is purely static. Ensure the rotation is applied to the object's transform to finalize its orientation.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (3.0, 1.0, 1.0)\ncube_location: (-4.0, 1.0, 0.0)\ncube_rotation_y_degrees: 15.0\ncube_rotation_y_radians: 0.2617993877991494\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, for a clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a default cube (1x1x1)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\n\n# Get the active object (the cube we just created)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve 3x1x1 dimensions\n# Default cube has vertices at ±0.5 on each axis. Scaling by (3,1,1) yields desired size.\ncube.scale = (3.0, 1.0, 1.0)\n\n# Apply the scale to make it the object's base geometry\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set the location\ncube.location = (-4.0, 1.0, 0.0)\n\n# Set the rotation (15 degrees around Y-axis)\n# Convert degrees to radians\nrotation_radians = math.radians(15.0)\ncube.rotation_euler = (0.0, rotation_radians, 0.0)\n\n# Apply the rotation to the object's data\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Optional: Set object display to see edges clearly\ncube.display_type = 'SOLID'\n```\n</implementation>"}
{"id": 8, "instruction": "Place a cylinder (radius 0.5, height 2) at (0, 2, 5) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylinder with specified geometry and placement. This involves direct modeling without dynamics. The primary considerations are accurate dimensioning, precise location, and rotation about the Z-axis. No kinematic or dynamic simulation is required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Radius (r): 0.5 m\n- Cylinder Height (h): 2.0 m\n- Cylinder Base Location: (x, y, z) = (0.0, 2.0, 5.0) in world coordinates. Note that in Blender, the cylinder primitive's origin is at its center by default. To place the base at (0,2,5), we must offset by half its height (1.0 m) in the Z-direction, resulting in a cylinder center at (0,2,6).\n- Rotation: 120° about the global Z-axis. Convert to radians for Blender: θ = 120° * (π/180) = 2.094395 rad.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh, no joints).\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic behavior is required. The cylinder is static. Ensure the rotation is applied correctly and the location accounts for the cylinder's origin.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.5\n- cylinder_height: 2.0\n- base_location_world: (0.0, 2.0, 5.0)\n- cylinder_center_location: (0.0, 2.0, 6.0)\n- rotation_z_degrees: 120.0\n- rotation_z_radians: 2.094395\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Parameters from summary\nradius = 0.5\nheight = 2.0\nbase_loc = (0.0, 2.0, 5.0)\ncenter_loc = (0.0, 2.0, 6.0)  # Because cylinder origin is at its center\nrotation_rad = math.radians(120.0)  # Convert 120 degrees to radians\n\n# Create cylinder primitive (default origin at center)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=radius,\n    depth=height,\n    location=center_loc\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Apply rotation about Z-axis\ncylinder.rotation_euler = (0, 0, rotation_rad)\n\n# Verify location: the base should now be at (0,2,5)\n# Note: After rotation, the base is still at the same height relative to the center.\n# Since we rotated about Z, the base plane remains perpendicular to Z, so the base location is unchanged.\n\n# Optional: Add a passive rigid body if physics is needed later (not required by task)\n# bpy.ops.rigidbody.object_add()\n# cylinder.rigid_body.type = 'PASSIVE'\n\n# For clarity, print the location and rotation\nprint(f\"Cylinder created at world location: {cylinder.location}\")\nprint(f\"Cylinder rotation (radians): {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 10, "instruction": "Place a 4x1x1 cube at (3, 0, -2) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a rectangular prism (cube with non-uniform dimensions) at a specific location with a specific rotation. No physics or dynamics are required. The primary considerations are correct dimension scaling, accurate coordinate placement, and proper rotation application in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 4 units in X, 1 unit in Y, 1 unit in Z.\n- World location: (3, 0, -2) in Blender's coordinate system (X-right, Y-forward, Z-up).\n- Rotation: 75 degrees around the Y-axis (local rotation). Convert to radians for Blender: 75° × (π/180) ≈ 1.30899694 radians.\n- Default Blender cube is 2×2×2, so scaling factors: (4/2, 1/2, 1/2) = (2.0, 0.5, 0.5).\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no hierarchy or joints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. Object will remain static. Ensure rotation is applied after scaling to avoid shearing (order: scale, then rotate, then translate).\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (4.0, 1.0, 1.0)\n- location: (3.0, 0.0, -2.0)\n- rotation_y_degrees: 75.0\n- rotation_y_radians: 1.30899694\n- scale_factors: (2.0, 0.5, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get the active object\ncube = bpy.context.active_object\ncube.name = \"Rectangular_Prism\"\n\n# Apply scaling to achieve 4x1x1 dimensions\ncube.scale = (2.0, 0.5, 0.5)\n\n# Apply rotation (75° around Y-axis)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Apply location\ncube.location = (3.0, 0.0, -2.0)\n\n# Apply transformations to make them intrinsic (clean object data)\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n```\n</implementation>"}
{"id": 7, "instruction": "Place a sphere with radius 2 at (6, 0, 1) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a sphere with specified geometric properties and transformations in 3D space. This involves precise parameterization and application of transformations. The sphere must be placed at coordinates (6, 0, 1) with radius 2, then rotated 45° around the Y-axis. This is a fundamental 3D modeling operation requiring accurate spatial reasoning.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius (r): 2.0 units\n- Sphere center location: (x=6.0, y=0.0, z=1.0)\n- Rotation: 45° around Y-axis (global orientation)\n- Transform order: Scale for radius, then translation to position, then rotation\n- Default sphere in Blender has radius 1, requiring scaling by factor 2\n- Rotation in radians: 45° × π/180 = 0.785398 radians\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single mesh object with transform hierarchy)\n- No joints or constraints required\n- Transformation stack: scale → translate → rotate\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None - static object placement\n- Mitigation: Ensure transformations are applied in correct order\n- Verification: Confirm final position and orientation match specifications\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.0\n- sphere_location: (6.0, 0.0, 1.0)\n- sphere_rotation_y: 45.0 (degrees)\n- sphere_rotation_y_rad: 0.785398\n- default_sphere_radius: 1.0\n- scale_factor: 2.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default sphere (radius 1 at origin)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,\n    location=(0, 0, 0),\n    segments=32,\n    ring_count=16\n)\n\n# Get reference to created sphere\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply transformations in correct order\n# 1. Scale for radius (2x in all dimensions)\nsphere.scale = (2.0, 2.0, 2.0)\n\n# 2. Apply scale transformation\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# 3. Set location\nsphere.location = (6.0, 0.0, 1.0)\n\n# 4. Apply rotation (45° around Y-axis)\nsphere.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Apply rotation transformation\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=False)\n\n# Verify transformations\nprint(f\"Sphere created with:\")\nprint(f\"  Name: {sphere.name}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation (Euler): {sphere.rotation_euler}\")\nprint(f\"  Scale: {sphere.scale}\")\nprint(f\"  Dimensions: {sphere.dimensions}\")\n```\n</implementation>"}
{"id": 4, "instruction": "Place a cylinder (radius 1, height 3) at (2, 0, 2) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise static placement of a primitive cylinder with specific dimensions, location, and orientation. No dynamic simulation or mechanical interaction is needed, making this a straightforward geometric modeling exercise.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius (r): 1.0 units\n- Cylinder height (h): 3.0 units\n- Target location: (x, y, z) = (2.0, 0.0, 2.0)\n- Rotation: 60° around X-axis (θ_x = 60°)\n- The base cylinder in Blender is centered at origin with height along Z-axis\n- After rotation, the cylinder's local Z-axis will tilt 60° from world Z-axis\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object with no joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic behavior to simulate. The cylinder will remain fixed at specified location and orientation.\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 1.0\ncylinder_height: 3.0\nlocation_x: 2.0\nlocation_y: 0.0\nlocation_z: 2.0\nrotation_x_deg: 60.0\nrotation_x_rad: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=3.0,\n    location=(2.0, 0.0, 2.0)\n)\n\n# Get reference to the created cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply rotation (60 degrees around X-axis)\ncylinder.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Optional: Set material for visualization\nmaterial = bpy.data.materials.new(name=\"CylinderMaterial\")\nmaterial.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\ncylinder.data.materials.append(material)\n\n# Add reference grid for spatial context\nbpy.ops.mesh.primitive_grid_add(\n    x_subdivisions=10,\n    y_subdivisions=10,\n    size=10.0,\n    location=(0, 0, 0)\n)\ngrid = bpy.context.active_object\ngrid.name = \"ReferenceGrid\"\n```\n</implementation>"}
{"id": 6, "instruction": "Place a 1x3x1 cube at (1, 0, -3) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a rectangular prism (cube) in 3D space. This is a basic transformation operation with no dynamics or complex kinematics. The primary considerations are correct dimensional scaling, translation to the specified coordinates, and applying the X-axis rotation. Since the default Blender cube is 2x2x2 units centered at the origin, we must scale it to 1x3x1 dimensions before applying the rotation and translation.\n</strategic_layout>\n\n<spatial_layout>\n- Desired dimensions: width (X)=1, depth (Y)=3, height (Z)=1.\n- Default Blender cube dimensions: 2x2x2.\n- Required scale factors: (1/2, 3/2, 1/2) = (0.5, 1.5, 0.5).\n- Target location: (1, 0, -3).\n- Target rotation: 90° about X-axis = π/2 radians (1.5708 rad).\n- Transformation order: Apply scaling first (object mode), then rotation, then translation to maintain clarity.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh, no hierarchy needed).\n- No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation or stability risks for this static object placement.\n- Ensure rotation is applied in correct order (Euler rotation in object mode).\n- Verify final orientation: A 90° X-rotation on a tall box (Y=3, Z=1) will make it tall in Z and deep in Y.\n</predictive_simulation>\n\n<parameter_summary>\n- target_location: (1.0, 0.0, -3.0)\n- target_rotation_x_degrees: 90.0\n- target_dimensions: (1.0, 3.0, 1.0)\n- base_scale_factors: (0.5, 1.5, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 1x3x1 dimensions\ncube.scale = (0.5, 1.5, 0.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set rotation (90° about X-axis)\ncube.rotation_euler = (radians(90.0), 0.0, 0.0)\n\n# Set location\ncube.location = (1.0, 0.0, -3.0)\n\n# Optionally set object origin to geometry center for clarity\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n```\n</implementation>"}
{"id": 9, "instruction": "Place a 2x1x3 cube at (-2, -1, 4) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cube with specified dimensions, location, and orientation. This involves straightforward geometric modeling without dynamics or complex assemblies.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (Width, Depth, Height): 2.0m (X), 1.0m (Y), 3.0m (Z).\n- World Location: (-2.0, -1.0, 4.0) in meters.\n- Rotation: 30° around the X-axis (0.5236 radians).\n- Default Blender cube is 2m³ (from -1 to 1 in each local axis). Scaling factors: (2.0/2.0 = 1.0 in X, 1.0/2.0 = 0.5 in Y, 3.0/2.0 = 1.5 in Z).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single static mesh object, no parent or joints).\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None for static placement. If physics were enabled, the cube would fall from Z=4.0m.\n- Mitigation: No rigid body is added, keeping the cube as a static mesh.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 1.0, 3.0)\n- cube_location: (-2.0, -1.0, 4.0)\n- cube_rotation_x_degrees: 30.0\n- scale_factors: (1.0, 0.5, 1.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add a default cube (2m x 2m x 2m)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve dimensions 2m (X) x 1m (Y) x 3m (Z)\ncube.scale = (1.0, 0.5, 1.5)\n\n# Apply scale to make dimensions explicit in mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-2.0, -1.0, 4.0)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n```\n</implementation>"}
{"id": 3, "instruction": "Place a sphere with radius 1 at (0, 3, 0) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a sphere with specific geometric properties (radius=1) and applying precise spatial transformations (translation to (0,3,0) and 90° rotation about Z-axis). This involves basic 3D object creation and transformation operations in Blender. The sphere's default UV sphere mesh with 32 segments provides adequate smoothness for visualization.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius (R): 1.0 units\n- Translation vector: (0.0, 3.0, 0.0) in world coordinates\n- Rotation: 90° about global Z-axis (π/2 radians)\n- Rotation matrix for 90° Z-rotation:\n  [[cos(90°), -sin(90°), 0],\n   [sin(90°), cos(90°), 0],\n   [0, 0, 1]] = [[0, -1, 0], [1, 0, 0], [0, 0, 1]]\n- Final vertex positions: v_final = R_z(90°) * (v_original) + T\n- Bounding box dimensions: ±1.0 in X,Y,Z after rotation (rotation doesn't change bounding sphere)\n</spatial_layout>\n\n<kinematic_topology>\nStatic object hierarchy:\n- world (global coordinate system)\n  └── sphere_object (transformable mesh with applied transformations)\nNo joints or constraints needed for this static placement.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A - static object placement\n- Collision risks: None with other scene elements (empty scene)\n- Transform verification: Rotation occurs around object's origin, which remains at (0,3,0) post-translation\n- Coordinate system: All transformations applied in global/world space as specified\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.0\n- location: (0.0, 3.0, 0.0)\n- rotation_angle_degrees: 90.0\n- rotation_axis: 'Z'\n- sphere_segments: 32\n- sphere_rings: 16\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Vector, Matrix\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,\n    location=(0.0, 3.0, 0.0),\n    segments=32,\n    ring_count=16\n)\n\nsphere = bpy.context.active_object\nsphere.name = \"positioned_sphere\"\n\n# Apply 90° rotation about Z-axis\nrotation_angle = math.radians(90.0)\nrotation_matrix = Matrix.Rotation(rotation_angle, 4, 'Z')\nsphere.matrix_world @= rotation_matrix\n\n# Alternative: Set rotation directly (ensures exact 90° about global Z)\nsphere.rotation_euler = (0.0, 0.0, rotation_angle)\n\n# Update scene\nbpy.context.view_layer.update()\n\n# Verification output\nprint(f\"Sphere created at: {sphere.location}\")\nprint(f\"Sphere rotation (radians): {sphere.rotation_euler}\")\nprint(f\"Sphere scale: {sphere.scale}\")\n```\n</implementation>"}
{"id": 1, "instruction": "Place a 1x1x1 cube at (0, 0, 0) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static cube with specific geometric transformations. Since this is a purely kinematic placement without dynamic simulation, the focus is on accurate coordinate positioning and Euler rotation application. The cube will be created at the world origin with unit dimensions and rotated around its local X-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 1m × 1m × 1m (world units)\n- Initial Location: (0, 0, 0) in global coordinates\n- Rotation Transformation: 30° rotation around X-axis = π/6 radians\n- Vertex Displacement: After rotation, original vertex (0, 0.5, 0.5) transforms to (0, 0.5cos30° - 0.5sin30°, 0.5sin30° + 0.5cos30°) ≈ (0, 0.183, 0.683)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh with transform hierarchy)\n- No joints or constraints required\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Collision Risk: None (single object scene)\n- Visual Verification: Rotated cube should show apparent foreshortening along Y and Z axes when viewed from front orthographic view\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (0.0, 0.0, 0.0)\n- cube_dimensions: (1.0, 1.0, 1.0)\n- rotation_angle_deg: 30.0\n- rotation_axis: 'X'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create unit cube at origin\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0.0, 0.0, 0.0))\ncube = bpy.context.active_object\ncube.name = \"RotatedCube\"\n\n# Apply 30° rotation around X-axis\nrotation_rad = math.radians(30.0)\ncube.rotation_euler = (rotation_rad, 0.0, 0.0)\n\n# Update mesh data to apply transformation\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Set visual properties for clarity\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\ncube.data.materials.append(mat)\n\n# Set up viewport for visualization\nfor area in bpy.context.screen.areas:\n    if area.type == 'VIEW_3D':\n        area.spaces[0].region_3d.view_location = (0, 0, 0)\n        area.spaces[0].region_3d.view_distance = 5\n        area.spaces[0].region_3d.view_rotation.rotate(math.radians(45), math.radians(45), 0)\n        break\n\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Cube rotation (degrees): {math.degrees(cube.rotation_euler.x):.1f}, {math.degrees(cube.rotation_euler.y):.1f}, {math.degrees(cube.rotation_euler.z):.1f}\")\n```\n</implementation>"}
{"id": 12, "instruction": "Place a sphere with radius 0.5 at (-3, 2, 1) and rotate it 180° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static sphere at a specific location with a specific orientation. This requires basic 3D modeling operations: create primitive, set transform properties. No physical simulation or constraints are needed beyond the initial placement.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.5 units\n- Sphere center location: (-3, 2, 1) in global coordinates (X, Y, Z)\n- Sphere rotation: 180° around Y-axis = π radians (3.14159 rad)\n- No scaling transformation applied\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world → sphere_object\n- No joints or constraints required\n- Object transforms applied directly to mesh origin\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required\n- Static placement ensures perfect stability\n- No collision or interaction considerations\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.5\n- sphere_location: (-3.0, 2.0, 1.0)\n- sphere_rotation_y_degrees: 180.0\n- sphere_rotation_y_radians: 3.14159\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects for clean scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.5,\n    location=(-3.0, 2.0, 1.0)\n)\n\n# Get reference to created sphere\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply 180° rotation around Y-axis (π radians)\nsphere.rotation_euler = (0.0, math.pi, 0.0)\n\n# Optional: Apply transforms to make rotation permanent in mesh data\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Verify transforms\nprint(f\"Sphere created: {sphere.name}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation: {sphere.rotation_euler}\")\nprint(f\"Radius: {sphere.dimensions.x / 2}\")\n```\n</implementation>"}
{"id": 13, "instruction": "Place a cylinder (radius 1, height 1) at (4, 4, 4) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cylinder with specific geometric properties at a defined location and orientation. This involves direct 3D modeling with precise coordinate placement and rotation transformation. The main consideration is correct coordinate system handling in Blender (right-handed, Z-up) and proper unit interpretation (meters).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0m\n- Cylinder height: 1.0m  \n- World coordinates: X=4.0m, Y=4.0m, Z=4.0m\n- Rotation: 90° around X-axis (π/2 radians)\n- The cylinder's local Z-axis will be rotated to align with world Y-axis after transformation\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with no parent/child relationships)\n- No joints or constraints needed as it's a static object\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic behavior required\n- Static placement ensures stability\n- No collision or interaction considerations\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 1.0  \n- location_x: 4.0\n- location_y: 4.0\n- location_z: 4.0\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.57079632679\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with given dimensions\n# Blender's default cylinder has radius=1, height=2, so we scale accordingly\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=1.0,\n    location=(0, 0, 0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Set location\ncylinder.location = (4.0, 4.0, 4.0)\n\n# Set rotation (90° around X-axis)\n# Convert degrees to radians for rotation_euler\ncylinder.rotation_euler = (math.radians(90.0), 0, 0)\n\n# Apply rotation to mesh data for clean transformation\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 17, "instruction": "Place a cylinder (radius 2, height 1) at (0, 0, -5) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a static cylindrical obstacle at a specific location with a 45-degree rotation about the Y-axis. This involves creating a primitive mesh, applying precise geometric transformations, and ensuring no unintended collisions or physics interactions (as none are specified).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center location: (0, 0, -5) in world coordinates.\n- Cylinder dimensions: radius = 2.0m, height = 1.0m (extending ±0.5m along local Z-axis).\n- Rotation: 45° about Y-axis (π/4 radians).\n- Bounding box: The cylinder's axis-aligned bounding box will be larger due to rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static mesh with no parent, fixed transformation)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic behavior required.\n- Rotation does not affect stability as the cylinder is static and symmetric.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.0\n- cylinder_height: 1.0\n- cylinder_location: (0.0, 0.0, -5.0)\n- cylinder_rotation_y_degrees: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.0,\n    depth=1.0,\n    location=(0.0, 0.0, -5.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Cylinder\"\n\n# Apply 45° rotation about Y-axis\ncylinder.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Ensure transformation is applied (optional for static object)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\nprint(f\"Created cylinder '{cylinder.name}' at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 16, "instruction": "Place a sphere with radius 1.5 at (1, -3, 3) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a sphere with specific geometry (radius 1.5), positioning it at coordinates (1, -3, 3) in 3D space, and applying a 60° rotation about the X-axis. This is a fundamental 3D modeling operation with no complex physics or dynamics involved. The primary consideration is ensuring precise coordinate and rotation transformation handling in Blender's right-handed coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: X=1.0, Y=-3.0, Z=3.0\n- Sphere radius: 1.5 units\n- Rotation: 60° about X-axis (global/local depends on context)\n- Rotation conversion: 60° × (π/180°) = 1.047197551 radians\n- Bounding box: From (X-1.5, Y-1.5, Z-1.5) = (-0.5, -4.5, 1.5) to (X+1.5, Y+1.5, Z+1.5) = (2.5, -1.5, 4.5)\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no parent-child hierarchy or constraints.\n- world -> sphere (Mesh with transform: location=(1,-3,3), rotation_euler=(1.0472,0,0))\n</kinematic_topology>\n\n<predictive_simulation>\nStatic placement with no dynamic behavior. The sphere will remain fixed at the specified location and orientation. No stability risks or collisions to consider. The transformation is purely geometric.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.5\n- sphere_location: (1.0, -3.0, 3.0)\n- rotation_degrees_x: 60.0\n- rotation_radians_x: 1.047197551\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.5,\n    location=(1.0, -3.0, 3.0),\n    scale=(1, 1, 1)\n)\nsphere = bpy.context.active_object\nsphere.name = \"TargetSphere\"\n\n# Apply 60° rotation about X-axis (convert to radians)\nsphere.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Update mesh transformations\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(f\"Sphere created: {sphere.name}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation (radians): {sphere.rotation_euler}\")\nprint(f\"Radius: {sphere.dimensions.x / 2}\")\n```\n</implementation>"}
{"id": 15, "instruction": "Place a 2x3x1 cube at (-5, 0, 2) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a static object placement task requiring precise dimensional control and coordinate transformation. The primary challenge is correctly interpreting \"2x3x1\" dimensions (width, depth, height) and applying the Y-axis rotation about the object's origin. Since no dynamic behavior is required, implementation focuses on mesh creation and transformation.\n</strategic_layout>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 2.0m, Depth (Y) = 3.0m, Height (Z) = 1.0m\n- World Location: (-5.0, 0.0, 2.0) in global coordinates\n- Rotation: 35° around global Y-axis (counter-clockwise from positive X direction)\n- Origin: Default cube origin at geometric center\n- Height Offset: Base of cube will be at Z = 1.5 (2.0 - 0.5) since height is 1m and origin is centered\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_object (Static Mesh)\nNo joints or constraints needed for static placement.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is statically placed with no applied forces\n- Risk: None beyond potential coordinate system misinterpretation\n- Verification: Confirm dimensions and orientation match specifications\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 3.0, 1.0)\n- cube_location: (-5.0, 0.0, 2.0)\n- cube_rotation: 35.0 (degrees around Y-axis)\n- origin_offset: (0.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Vector, Euler\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default Blender dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 2x3x1 dimensions\n# Default Blender cube has vertices at ±0.5 in local space\n# Scaling factor = desired_dimension / default_dimension\nscale_x = 2.0 / 1.0  # Default cube size is 1.0 when created with size=1.0\nscale_y = 3.0 / 1.0\nscale_z = 1.0 / 1.0\ncube.scale = (scale_x, scale_y, scale_z)\n\n# Apply rotation (35° around Y-axis)\nrotation_rad = math.radians(35.0)\ncube.rotation_euler = Euler((0.0, rotation_rad, 0.0), 'XYZ')\n\n# Set location\ncube.location = Vector((-5.0, 0.0, 2.0))\n\n# Apply transformations to make them permanent in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Verify final dimensions\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation: {math.degrees(cube.rotation_euler.y)}°\")\n\n# Optional: Add visual differentiation\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blue color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n```\n</implementation>"}
{"id": 19, "instruction": "Place a 2x2x1 cube at (-1, 4, -1) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single static cube with specific dimensions, location, and orientation. This is a foundational 3D modeling task. The primary consideration is correctly interpreting the dimensions (likely width, depth, height in the X, Y, Z axes respectively) and applying the rotation in the correct order (location first, then rotation). The scene must be prepared by clearing existing objects.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (Width, Depth, Height): (2.0, 2.0, 1.0) meters.\n- Cube Location (X, Y, Z): (-1.0, 4.0, -1.0) meters. Given the height of 1m, the base of the cube will be at Z = -1.5 and the top at Z = -0.5 if unrotated.\n- Cube Rotation: 25 degrees around the local X-axis. This is a forward/backward tilt. In radians: 25 * (π/180) ≈ 0.436332 radians.\n- Rotation Order: Apply rotation after setting location. The cube's origin (center) is at the specified location.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh, no parent, no joints). This is a single rigid object.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cube is static; no dynamic simulation is required.\n- Risk: None. The rotation is purely visual and does not affect stability as no physics are applied.\n- Mitigation: Ensure the cube is not set as a dynamic rigid body unless required for a later simulation step.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 1.0)\n- cube_location: (-1.0, 4.0, -1.0)\n- cube_rotation_x_degrees: 25.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects in the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a cube with dimensions 2x2x1\n# Default Blender cube is 2x2x2, so we scale by (1, 1, 0.5) to get 2x2x1\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply dimensions: scale in Z by 0.5 to get height 1 (since base size is 2)\ncube.scale = (1.0, 1.0, 0.5)\n\n# Apply the scale transformation to make it the actual mesh data\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location\ncube.location = (-1.0, 4.0, -1.0)\n\n# Set rotation: 25 degrees around X-axis, converted to radians\ncube.rotation_euler = (math.radians(25.0), 0.0, 0.0)\n```\n</implementation>"}
{"id": 20, "instruction": "Place a 5x1x1 cube at (6, 1, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a simple static object placement task requiring precise geometric transformations. The primary considerations are accurate dimension scaling, location translation, and rotation application around the local Y-axis. Since the object is static with no moving parts, kinematic chains and dynamics are irrelevant.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (L×W×H): 5×1×1 units.\n- Target location (X,Y,Z): (6, 1, 0).\n- Rotation angle: 15° counterclockwise around the Y-axis (right-hand rule).\n- The cube's origin (pivot point) defaults to its geometric center at (0,0,0) in local coordinates.\n- After rotation, vertices transform via rotation matrix R_y(15°).\n</spatial_layout>\n\n<kinematic_topology>\nStatic single-body topology:\n- world → cube_mesh (Static Rigid Body)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The cube will remain statically placed. Ensure rotation is applied correctly to avoid clipping with other potential objects (none specified).\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (5.0, 1.0, 1.0)\ncube_location: (6.0, 1.0, 0.0)\ncube_rotation_y_degrees: 15.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom mathutils import Matrix\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to desired dimensions (5,1,1) from default (1,1,1)\ncube.scale = (5.0, 1.0, 1.0)\n\n# Apply scale transformation to mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (6.0, 1.0, 0.0)\n\n# Set rotation (15° around Y-axis)\ncube.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Optional: Add passive rigid body for physics (if needed later)\n# bpy.ops.rigidbody.object_add()\n# cube.rigid_body.type = 'PASSIVE'\n\nprint(f\"Cube '{cube.name}' created at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 11, "instruction": "Place a 1x2x2 cube at (0, 5, 0) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static 3D cube with specified dimensions, position, and orientation. This is purely a geometric modeling task without physical simulation requirements. The cube will be created with its origin at the world center initially, then transformed to the target location and rotation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width=1m (X), height=2m (Y), depth=2m (Z) based on 1x2x2 specification.\n- Target position: (0, 5, 0) in world coordinates.\n- Target rotation: 45° around global Z-axis (0.7854 radians).\n- Local origin: Cube center remains at geometric center after transformations.\n- No collision or physics constraints needed for static placement.\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body hierarchy:\n- world (global coordinate system)\n  └── cube_object (transformed mesh)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A for static object placement.\n- Dynamic risks: None since no physics simulation required.\n- Verification: Simple visual confirmation of final transform matrix.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 2.0)\n- target_location: (0.0, 5.0, 0.0)\n- target_rotation_z: 45.0 (degrees)\n- rotation_radians: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with specified dimensions\n# Default Blender cube is 2x2x2, so we scale by half dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply dimensions (scale from default 2m cube)\ncube.scale = (0.5, 1.0, 1.0)  # Converts 2x2x2 to 1x2x2\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 5.0, 0.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Apply all transformations\nbpy.ops.object.transform_apply(location=True, rotation=True)\n\n# Optional: Add wireframe display for clarity\ncube.display_type = 'WIRE'\ncube.show_wire = True\ncube.show_all_edges = True\n\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Final dimensions: {cube.dimensions}\")\nprint(f\"Rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 14, "instruction": "Place a 3x3x1 cube at (2, -2, 0) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating and positioning a simple rectangular prism (3×3×1 units) at a specified location with a Z-axis rotation. This involves basic 3D modeling with explicit geometric transformations rather than kinematic mechanisms. The primary challenge is correctly applying both translation and rotation transformations in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: X=3.0m, Y=3.0m, Z=1.0m (making it a flat rectangular shape)\n- Target position: X=2.0m, Y=-2.0m, Z=0.0m (resting on ground plane)\n- Rotation: 20° around global Z-axis (θ_z = 20°)\n- The cube's center will be at the specified coordinates after both transformations\n- Rotation is applied before translation in Blender's transformation order\n</spatial_layout>\n\n<kinematic_topology>\nStatic single-body geometry with no joints or hierarchy:\n- world → cube_object (static mesh, no parent)\nNo kinematic constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Flat rectangular shape with 1:3 aspect ratio may appear unstable visually but is statically placed.\n- Risk: None beyond potential Z-fighting if placed exactly at Z=0 on default plane.\n- Mitigation: Slight vertical offset not needed as default plane is at Z=0.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 3.0, 1.0)\n- cube_location: (2.0, -2.0, 0.0)\n- cube_rotation_z_degrees: 20.0\n- cube_rotation_euler: (0.0, 0.0, 0.349066) [20° in radians]\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default 2x2x2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PositionedCube\"\n\n# Set dimensions to 3×3×1 by scaling\ncube.dimensions = (3.0, 3.0, 1.0)\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (2.0, -2.0, 0.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Optional: Add passive rigid body for physics simulation\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\nprint(f\"Cube created at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 22, "instruction": "Place a cylinder (radius 1, height 4) at (-6, 0, 0) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static placement task. The objective is to create a cylinder with specified dimensions and apply a translation and rotation transformation. No dynamic simulation or complex physics are required. The primary considerations are ensuring correct Blender unit handling, precise coordinate placement, and proper rotation order (Euler angles). We'll create a simple, static mesh.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: radius = 1.0 m, height = 4.0 m.\n- World coordinates: Object origin (center of cylinder) will be placed at (-6, 0, 0).\n- Rotation: 30 degrees about the global X-axis. In radians: θ_x = 30° * (π/180) ≈ 0.5236 rad.\n- No scaling transformation required.\n- The cylinder's local Z-axis is its height axis. A 30° X-rotation will tilt the cylinder forward (if Z is up).\n</spatial_layout>\n\n<kinematic_topology>\nStatic hierarchy:\n- world\n    └── cylinder_object (single mesh, no parent, no constraints)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamics involved. Risk assessment: none. The object is static and will remain in place. Ensure the rotation is applied correctly to avoid visual misinterpretation.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 4.0\n- location: (-6.0, 0.0, 0.0)\n- rotation_degrees_x: 30.0\n- rotation_radians_x: 0.5235987755982988\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with given dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=4.0,\n    location=(-6.0, 0.0, 0.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"target_cylinder\"\n\n# Apply rotation: 30 degrees about X-axis\ncylinder.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n```\n</implementation>"}
{"id": 18, "instruction": "Place a 1x1x4 cube at (2, 1, 1) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is a basic 3D modeling operation: create a rectangular prism (cube with non-uniform scaling) and apply a translation and rotation. No physics or complex constraints are required. The primary consideration is ensuring the correct order of transformations: scale first, then rotate, then translate to achieve the desired final state.\n</strategic_layout>\n\n<spatial_layout>\n- Original cube dimensions (default Blender): 2x2x2.\n- Desired dimensions: 1x1x4. Scaling factors: Sx = 0.5, Sy = 0.5, Sz = 2.0.\n- Final location: (2, 1, 1).\n- Final rotation: 90° about Z-axis = 1.5708 radians.\n- No complex spatial calculations are needed beyond these transformations.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world -> cube (no joints or constraints).\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required. The cube is static. Risk of unintended collisions or instability is none.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (2.0, 1.0, 1.0)\n- cube_rotation_z_degrees: 90.0\n- cube_scale: (0.5, 0.5, 2.0)\n- cube_final_dimensions: (1.0, 1.0, 4.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Add a default cube (2x2x2) at origin\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 1x1x4 dimensions\ncube.scale = (0.5, 0.5, 2.0)\n\n# Apply rotation: 90 degrees around Z-axis\ncube.rotation_euler = (0, 0, math.radians(90))\n\n# Apply translation to final location\ncube.location = (2.0, 1.0, 1.0)\n\n# Update the object's transformation\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Verify dimensions (optional)\ndimensions = cube.dimensions\nprint(f\"Cube dimensions: {dimensions.x:.2f} x {dimensions.y:.2f} x {dimensions.z:.2f}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation (Z): {math.degrees(cube.rotation_euler.z):.1f}°\")\n```\n</implementation>"}
{"id": 23, "instruction": "Place a 1x4x1 cube at (0, -4, 0) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static rectangular prism (cube) with non-uniform scaling, positioning it at a specific world coordinate, and applying a rotation transform. No dynamics or complex kinematics are required. The primary consideration is ensuring the object's dimensions, location, and rotation are set correctly in the Blender scene.\n</strategic_analysis>\n\n<spatial_layout>\n- Default Blender cube has dimensions 2x2x2 meters (from -1 to +1 on each axis).\n- Target dimensions: 1 (X) × 4 (Y) × 1 (Z) meters. Scale factor = (0.5, 2.0, 0.5).\n- World location: (0, -4, 0) meters.\n- Rotation: 60° around Y-axis (local). Convert to radians: 60° × (π/180) ≈ 1.047197551 rad.\n- Object origin remains at the geometric center after scaling.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world → scaled_cube (Mesh object, no parent)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Static stability: N/A (object is fixed in space by transform).\n- Collision: No other objects present.\n- Risk: None.\n</predictive_simulation>\n\n<parameter_summary>\ntarget_dimensions: (1.0, 4.0, 1.0)\nlocation: (0.0, -4.0, 0.0)\nrotation_y_degrees: 60.0\nrotation_y_radians: 1.047197551\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"scaled_cube\"\n\n# Apply scaling to achieve 1x4x1 dimensions\ncube.scale = (0.5, 2.0, 0.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (0.0, -4.0, 0.0)\ncube.rotation_euler = (0.0, radians(60.0), 0.0)\n\n# Optional: Visual confirmation\nprint(f\"Cube created: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (degrees): {cube.rotation_euler.y * 180 / 3.1415926535}\")\n```\n</implementation>"}
{"id": 26, "instruction": "Place a cylinder (radius 0.75, height 2.5) at (1, 2, -4) and rotate it 40° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static object placement task requiring no physical simulation. The objective is to create a cylinder with specified dimensions at a given location and orientation. No dynamic constraints or hierarchies are needed - this is purely a geometric modeling exercise.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 0.75 units\n- Cylinder height: 2.5 units  \n- Location coordinates: X=1.0, Y=2.0, Z=-4.0\n- Rotation: 40° about Y-axis (Blender uses radians: 40° × π/180 = 0.6981 rad)\n- No spatial constraints or interactions with other objects\n</spatial_layout>\n\n<kinematic_topology>\n- Standalone cylinder object with no parent-child relationships\n- No joints or constraints required (static object)\n- Direct creation in world space at specified transform\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation needed for static geometry\n- No collision or stability risks\n- Render-only object with no physical properties required\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 0.75\ncylinder_height: 2.5\nlocation_x: 1.0\nlocation_y: 2.0\nlocation_z: -4.0\nrotation_y_degrees: 40.0\nrotation_y_radians: 0.6981317007977318\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.75,\n    depth=2.5,\n    location=(1.0, 2.0, -4.0)\n)\n\n# Get reference to the cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply rotation (40° about Y-axis)\ncylinder.rotation_euler = (0.0, math.radians(40.0), 0.0)\n\n# Optional: Add material for visibility\nmaterial = bpy.data.materials.new(name=\"CylinderMaterial\")\nmaterial.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\ncylinder.data.materials.append(material)\n\nprint(f\"Cylinder created at location: {cylinder.location}\")\nprint(f\"Cylinder rotation (degrees): {math.degrees(cylinder.rotation_euler.y)}° about Y-axis\")\n```\n</implementation>"}
{"id": 25, "instruction": "Place a sphere with radius 1 at (-2, -2, -2) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a sphere with specified radius, position, and rotation. This requires setting up a basic static scene in Blender without physical simulation. The sphere will be created as a mesh object with appropriate transformations applied.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: r = 1.0 units\n- Sphere center position: P = (-2.0, -2.0, -2.0) in global coordinates\n- Rotation: 120° (2π/3 radians) about the Z-axis\n- Rotation matrix for Z-axis: R_z(θ) = [[cosθ, -sinθ, 0], [sinθ, cosθ, 0], [0, 0, 1]]\n- For θ = 120° = 2π/3 rad: cos(120°) = -0.5, sin(120°) = √3/2 ≈ 0.8660254\n</spatial_layout>\n\n<kinematic_topology>\n- World coordinate system (global)\n- Sphere object (single rigid body, no hierarchy)\n- No joints or constraints needed for static placement\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic behavior required\n- Static scene ensures stability\n- Sphere remains at fixed position with applied rotation\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.0\nsphere_location: (-2.0, -2.0, -2.0)\nrotation_angle_degrees: 120.0\nrotation_angle_radians: 2.0943951023931953\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,\n    location=(-2.0, -2.0, -2.0),\n    scale=(1.0, 1.0, 1.0)\n)\n\n# Get reference to the created sphere\nsphere = bpy.context.active_object\nsphere.name = \"Rotated_Sphere\"\n\n# Apply 120° rotation around Z-axis (convert degrees to radians)\nrotation_angle = math.radians(120.0)\nsphere.rotation_euler = (0.0, 0.0, rotation_angle)\n\n# Update scene\nbpy.context.view_layer.update()\n\nprint(f\"Created sphere '{sphere.name}'\")\nprint(f\"  Radius: {sphere.dimensions.x/2:.3f}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation (Z-axis): {math.degrees(sphere.rotation_euler.z):.1f}°\")\n```\n</implementation>"}
{"id": 21, "instruction": "Place a sphere with radius 3 at (10, 0, 0) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to place a static sphere with specific radius and location, then apply a pure rotation about the Z-axis. No dynamics or complex mechanisms are required. The primary consideration is ensuring correct transformation order (location then rotation) and proper unit conversion for the rotation angle.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: r = 3.0 units\n- Center Location: (x, y, z) = (10.0, 0.0, 0.0)\n- Rotation: θ = 45° about the Z-axis (counterclockwise when viewing from positive Z)\n- Rotation in radians: θ_rad = 45 × π / 180 = π / 4 ≈ 0.7854 rad\n- Bounding Box: The sphere extends ±3.0 units in all axes from its center after rotation\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object hierarchy:\n  - world → sphere_object (Mesh with transform only)\n- No joints, constraints, or parent-child relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The sphere is a static object, so no stability concerns\n- Risks: None for static placement. Potential risk if future simulations add physics: large mass could cause instability if not properly set\n- Mitigation: Ensure proper scale is applied to radius rather than object dimensions\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 3.0\n- sphere_location: (10.0, 0.0, 0.0)\n- rotation_angle_degrees: 45.0\n- rotation_angle_radians: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\n# The 'add_uv_sphere' operator uses diameter, so we set radius after creation\nbpy.ops.mesh.primitive_uv_sphere_add(segments=32, ring_count=16, radius=1.0)\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Set radius to 3.0 (scale the mesh data, not the object scale)\nsphere.data.transform(mathutils.Matrix.Scale(3.0, 4))\nsphere.data.update()\n\n# Set location\nsphere.location = (10.0, 0.0, 0.0)\n\n# Apply rotation about Z-axis (45 degrees converted to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Apply transforms to make transformations explicit\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Optional: Add a simple material for visibility\nmat = bpy.data.materials.new(name=\"Sphere_Material\")\nmat.use_nodes = True\nsphere.data.materials.append(mat)\n\nprint(f\"Sphere created:\")\nprint(f\"  Radius: {sphere.dimensions.x/2:.3f}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {math.degrees(sphere.rotation_euler.z):.1f}° about Z-axis\")\n```\n</implementation>"}
{"id": 28, "instruction": "Place a 1x5x1 cube at (2, -5, 2) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a rectangular prism with dimensions 1×5×1 units, positioned at coordinates (2, -5, 2), and rotated 90° around the Z-axis. This is a straightforward static geometry placement task. The primary consideration is correctly interpreting the dimension order (likely width, depth, height in X, Y, Z) and applying the rotation after scaling to avoid distortion.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 1, Depth (Y) = 5, Height (Z) = 1.\n- Default Blender cube: 2×2×2 bounding box centered at origin.\n- Scaling factors: X_scale = 1/2 = 0.5, Y_scale = 5/2 = 2.5, Z_scale = 1/2 = 0.5.\n- Position: (x, y, z) = (2, -5, 2).\n- Rotation: 90° around Z-axis = π/2 radians ≈ 1.5708 rad.\n- Order: Apply scaling, then rotation, then translation.\n</spatial_layout>\n\n<kinematic_topology>\nStatic object hierarchy:\n- world → cube (single mesh object, no parent)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The object will be statically placed. Risk of collision or instability is irrelevant for this static placement task.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 5.0, 1.0)\n- cube_location: (2.0, -5.0, 2.0)\n- cube_rotation_z_degrees: 90.0\n- default_cube_size: 2.0\n- scale_factors: (0.5, 2.5, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get the active object\ncube = bpy.context.active_object\ncube.name = \"Placed_Cube\"\n\n# Apply scaling to achieve 1x5x1 dimensions\n# Default cube is 2x2x2, so scale factors are desired/2\ncube.scale = (0.5, 2.5, 0.5)\n\n# Apply rotation: 90 degrees around Z-axis\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Set location\ncube.location = (2.0, -5.0, 2.0)\n\n# Apply transforms to make scale and rotation permanent in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Verify final dimensions\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation (Z): {math.degrees(cube.rotation_euler.z)}°\")\n```</implementation>"}
{"id": 30, "instruction": "Place a sphere with radius 2.5 at (0, 6, 0) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static sphere with specific geometric properties. This is a straightforward 3D modeling operation with no dynamic constraints, kinematics, or physical interactions. The primary considerations are accurate dimensioning, precise placement in world coordinates, and correct application of rotational transformation about the X-axis. The sphere will be a simple mesh object with no rigid body properties or complex hierarchies.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (R): 2.5 units\n- Sphere Center Position (P): (X=0.0, Y=6.0, Z=0.0) in global coordinates\n- Rotation: 15° about the global X-axis. In radians: θ = 15 * (π/180) = π/12 ≈ 0.2618 rad\n- Bounding Box: The axis-aligned bounding box will span from (-2.5, 3.5, -2.5) to (2.5, 8.5, 2.5) when unrotated. Rotation around X affects Y and Z coordinates locally but doesn't change the axis-aligned extents in this simple case.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single mesh object with transform applied, no parent, no joints)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The sphere is a static object; no dynamic stability analysis required.\n- Risk: None. This is a purely geometric placement task.\n- Mitigation: Ensure the rotation is applied correctly (Blender uses radians for rotation_euler).\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.5\n- sphere_location: (0.0, 6.0, 0.0)\n- sphere_rotation_x_degrees: 15.0\n- sphere_rotation_x_radians: 0.2617993877991494\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\n# Default segments/rings are fine for demonstration\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.5, location=(0.0, 6.0, 0.0))\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply 15-degree rotation around X-axis (converted to radians)\nsphere.rotation_euler = (math.radians(15.0), 0.0, 0.0)\n\n# Optional: Set smooth shading for better visualization\nbpy.ops.object.shade_smooth()\n\nprint(f\"Sphere created: radius={sphere.dimensions.x/2}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation (radians): {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 29, "instruction": "Place a 2x1x2 cube at (4, 0, 4) and rotate it 33° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static cube with specific dimensions, location, and rotation. No mechanical or dynamic simulation is needed, making this a straightforward 3D modeling operation. The primary consideration is accurately applying the transformations in the correct order (scale → location → rotation) to match the specification.\n</strategic_layout>\n\n<spatial_layout>\n- Target Location: (4, 0, 4) in global coordinates.\n- Target Rotation: 33° around the global Y-axis.\n- Cube Dimensions: 2 (width/X) × 1 (height/Y) × 2 (depth/Z). Since Blender's default cube is 2×2×2, scaling factors are (1, 0.5, 1).\n- Transformation Order: Apply scaling to the mesh data for clarity, then set object location and rotation.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world → cube_object (static mesh)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamics or stability risks are involved. The cube is a static object with no joints or constraints.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 1.0, 2.0)\n- cube_location: (4.0, 0.0, 4.0)\n- cube_rotation_y: 33.0 (degrees)\n- blender_scale_factors: (1.0, 0.5, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects for a clean scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to desired dimensions: 2 (X), 1 (Y), 2 (Z)\n# Default cube is 2x2x2, so scale factors are (1, 0.5, 1)\ncube.scale = (1.0, 0.5, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation (convert degrees to radians)\ncube.location = (4.0, 0.0, 4.0)\ncube.rotation_euler = (0.0, math.radians(33.0), 0.0)\n\n# Optional: Apply rotation for clean transforms\nbpy.ops.object.transform_apply(rotation=True)\n\nprint(f\"Cube '{cube.name}' created at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 31, "instruction": "Place a cylinder (radius 1.2, height 3.2) at (-4, -2, 1) and rotate it 70° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a static cylinder with specified dimensions at a specific location and orientation. No dynamics or physics are required. The challenge is correctly applying the 70° rotation around the Z-axis (world up-axis) after positioning. The cylinder's default axis aligns with global Z, so a Z-axis rotation will appear as a twist around its central axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Dimensions: Radius (R) = 1.2 units, Height (H) = 3.2 units.\n- Location: Center point at (x, y, z) = (-4.0, -2.0, 1.0). Since Blender's cylinder origin is at its geometric center, this places the cylinder's midpoint at that coordinate.\n- Rotation: 70° (1.22173 radians) around the global Z-axis. This is applied after translation.\n- Coordinate System: Right-handed, Z-up. Rotation follows the right-hand rule (counter-clockwise when viewing from positive Z).\n</spatial_layout>\n\n<kinematic_topology>\nStatic object only. No hierarchy or joints required.\n- world -> cylinder (Direct placement)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamics involved. The cylinder will remain fixed in place. Ensure rotation is applied correctly to match the intended visual orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.2\n- cylinder_height: 3.2\n- cylinder_location: (-4.0, -2.0, 1.0)\n- cylinder_rotation_z_deg: 70.0\n- cylinder_rotation_z_rad: 1.22173\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.2,\n    depth=3.2,\n    location=(-4.0, -2.0, 1.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Apply 70° rotation around Z-axis (convert to radians)\ncylinder.rotation_euler = (0.0, 0.0, math.radians(70.0))\n\n# Ensure transformation is applied (optional for static mesh)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Set viewport display (optional)\ncylinder.show_wire = True\ncylinder.show_all_edges = True\n\n# Set origin to geometry center (already true by default)\ncylinder.select_set(True)\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n```\n</implementation>"}
{"id": 34, "instruction": "Place a sphere with radius 0.8 at (-5, 3, 2) and rotate it 50° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a simple static sphere at a specified location with a rotation. No complex physics or dynamic constraints are involved. The focus is on precise geometric placement and orientation using Blender's bpy module.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.8 units.\n- Location coordinates: (-5, 3, 2) in the global XYZ space.\n- Rotation: 50° (0.872665 radians) around the global Z-axis.\n- The sphere's local origin (center) will be placed exactly at the given coordinates.\n</spatial_layout>\n\n<kinematic_topology>\n- The sphere is a single rigid body with no parent-child hierarchy or joints.\n- It exists directly under the world coordinate system.\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation is required. The object will be static unless a rigid body property is added, which is not specified.\n- The rotation is purely for visual orientation; no collision or motion analysis is needed.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 0.8\n- location: (-5.0, 3.0, 2.0)\n- rotation_z_degrees: 50.0\n- rotation_z_radians: 0.8726646259971648\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV Sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.8, location=(-5.0, 3.0, 2.0))\n\n# Get reference to the created sphere\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply rotation of 50 degrees around Z-axis (convert to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(50.0))\n\n# Optionally, set the object origin to its center (already by default)\n# No further physics properties are added as not specified.\n```\n</implementation>"}
{"id": 35, "instruction": "Place a cylinder (radius 1, height 2) at (3, 3, -3) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static modeling task requiring precise geometric placement and rotation of a cylinder. The primary challenge is translating mathematical specifications into correct Blender coordinate system transformations (right-handed Z-up). No dynamic simulation or complex constraints are involved.\n</strategic_layout>\n\n<geometric_calculations>\n- Cylinder origin: Default Blender cylinder has Z-axis as height axis, centered at (0,0,0) with radius 1 and height 2\n- Translation: Move from origin to target position (3, 3, -3)\n- Rotation: Apply 45° (π/4 radians) rotation around Y-axis\n- Coordinate System: Right-handed, Z-up (Blender default)\n- Rotation Order: Euler angles (default XYZ) with Y-axis rotation = 45°\n</geometric_calculations>\n\n<modeling_approach>\nSingle primitive object with transform operations. No parenting hierarchy needed. Mesh data created with specified dimensions, then transformed.\n</modeling_approach>\n\n<quality_considerations>\n- Use math.radians for conversion to ensure precision\n- Clear existing scene for reproducible results\n- Explicitly name object for clarity\n- Use bpy.ops for primitive creation then adjust properties\n</quality_considerations>\n\n<parameter_summary>\ncylinder_radius: 1.0\ncylinder_height: 2.0\ncylinder_location: (3.0, 3.0, -3.0)\ncylinder_rotation_y_degrees: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=2.0,\n    location=(0, 0, 0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply transformations\ncylinder.location = (3.0, 3.0, -3.0)\ncylinder.rotation_euler = (0, math.radians(45.0), 0)\n\n# Verify dimensions (optional but good practice)\ncylinder.data.name = \"CylinderMesh\"\nprint(f\"Cylinder created at {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.y):.1f}° around Y-axis\")\n```\n</implementation>"}
{"id": 24, "instruction": "Place a 2x2x3 cube at (3, 3, 3) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves static placement of a rectangular prism (referred to as a cube with non-uniform dimensions) at a specific world coordinate with a defined orientation. No dynamic simulation or multi-body kinematics are required. The primary challenge is ensuring accurate geometric transformation (scale, translation, rotation) in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Target Location: World coordinate (3, 3, 3) represents the object's origin (center).\n- Dimensions: Width (X) = 2m, Depth (Y) = 2m, Height (Z) = 3m.\n- Rotation: 90° around the X-axis. In radians: θ = π/2 ≈ 1.5708 rad.\n- Transformation Order: Apply scale first to establish dimensions, then rotation, then translation to final location.\n- Mesh Vertices: Default Blender cube has vertices at ±1 on each axis. Scaling by (1, 1, 1.5) yields 2×2×3 dimensions.\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body with no joints or hierarchy:\n- world -> cube_object (Static Mesh)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Not applicable (static placement).\n- Risk: None. Simple geometric operation.\n- Validation: Ensure final object's bounding box center matches (3,3,3) with correct orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 3.0)\n- cube_location: (3.0, 3.0, 3.0)\n- cube_rotation_x_rad: 1.57079632679\n- cube_scale: (1.0, 1.0, 1.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube primitive (default 2×2×2)\nbpy.ops.mesh.primitive_cube_add()\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling for 2×2×3 dimensions\ncube.scale = (1.0, 1.0, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set rotation (90° around X-axis)\ncube.rotation_euler = (math.radians(90), 0, 0)\n\n# Set location\ncube.location = (3.0, 3.0, 3.0)\n\n# Apply rotation to mesh data\nbpy.ops.object.transform_apply(rotation=True)\n\nprint(f\"Cube '{cube.name}' created:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Euler): {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 27, "instruction": "Place a 3x1x2 cube at (-3, 1, 5) and rotate it 10° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a rectangular prism. This is a fundamental 3D modeling operation involving coordinate transformations. The key is to correctly apply the rotation about the object's local X-axis after setting its position, ensuring the transformation order doesn't cause unintended displacement.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 3.0m, Depth (Y) = 1.0m, Height (Z) = 2.0m\n- Target Location: (-3.0, 1.0, 5.0) in global coordinates\n- Rotation: 10° counter-clockwise around local X-axis (Euler rotation)\n- Transformation Order: Location then rotation (object space transformation)\n- Bounding Box Corners (pre-rotation, centered at target):\n  Min: (-3 - 1.5, 1 - 0.5, 5 - 1) = (-4.5, 0.5, 4)\n  Max: (-3 + 1.5, 1 + 0.5, 5 + 1) = (-1.5, 1.5, 6)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_object (Static Mesh with transform)\n- No joints or constraints needed for static placement\n</kinematic_topology>\n\n<predictive_simulation>\n- Static placement with no dynamics involved\n- Risk: None for static geometry\n- Verification: Confirm final transform matrix matches specifications\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 1.0, 2.0)\n- target_location: (-3.0, 1.0, 5.0)\n- x_rotation_degrees: 10.0\n- x_rotation_radians: 0.174532925\n- scale_factors: (1.5, 0.5, 1.0)  # From default 2m cube\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve 3x1x2 dimensions\n# Default cube is 2m per side, so scale factors = desired/2\ncube.scale = (3.0/2.0, 1.0/2.0, 2.0/2.0)  # (1.5, 0.5, 1.0)\n\n# Apply scale to make it permanent (avoids distortion during rotation)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location\ncube.location = (-3.0, 1.0, 5.0)\n\n# Set rotation: 10° around X-axis\nrotation_rad = math.radians(10.0)\ncube.rotation_euler = (rotation_rad, 0.0, 0.0)\n\n# Apply rotation to make it permanent\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Verify final transform\nprint(f\"Final Location: {cube.location}\")\nprint(f\"Final Dimensions: {cube.dimensions}\")\nprint(f\"Final Rotation (Euler): {cube.rotation_euler}\")\nprint(f\"X-axis Rotation: {math.degrees(cube.rotation_euler.x):.2f}°\")\n\n# Optional: Add visual materials\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.use_nodes = True\ncube.data.materials.append(mat)\n```\n</implementation>"}
{"id": 33, "instruction": "Place a 1x1x2 cube at (1, 1, 6) and rotate it 180° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a rectangular prism with base dimensions 1×1 and height 2, position it at coordinates (1, 1, 6) in 3D space, and apply a 180° rotation around its local Y-axis. This requires basic mesh creation, transformation, and understanding that rotation is applied after scaling to ensure correct orientation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 1.0, depth (Y) = 1.0, height (Z) = 2.0.\n- World position: (x, y, z) = (1.0, 1.0, 6.0). The Z-coordinate of 6.0 means the base will be at z=5.0 and top at z=7.0 (since default cube is centered).\n- Rotation: 180° around Y-axis = π radians = 3.14159 rad.\n- Transformation order: Scale first to dimensions, then rotate, then translate.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no parent-child relationships or armature.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The object will remain statically placed. Ensure the rotation is applied to the object's transform to match the specification exactly.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (1.0, 1.0, 2.0)\ncube_location: (1.0, 1.0, 6.0)\ncube_rotation_y_degrees: 180.0\ncube_rotation_y_radians: 3.14159\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a default cube (1x1x1)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to 1x1x2 dimensions (scale Z by 2)\ncube.scale = (1.0, 1.0, 2.0)\nbpy.context.view_layer.update()\n\n# Apply rotation: 180 degrees around Y-axis\ncube.rotation_euler = (0.0, math.radians(180.0), 0.0)\nbpy.context.view_layer.update()\n\n# Move to final position (1, 1, 6)\ncube.location = (1.0, 1.0, 6.0)\n\n# Apply transforms to make scale and rotation explicit in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(f\"Cube '{cube.name}' created with dimensions {cube.dimensions}\")\nprint(f\"Location: {cube.location}, Rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 32, "instruction": "Place a 4x2x1 cube at (5, -1, -1) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThis is a simple static placement task requiring precise geometric transformation. The core challenge is correctly interpreting the dimensions and rotation order. Since this is a single static object with no dynamics, we focus on accurate mesh creation, scaling, positioning, and Euler rotation application.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 4m (X), 2m (Y), 1m (Z).\n- World Position: (5, -1, -1) in global coordinates.\n- Rotation: 25° around the X-axis. In Blender, rotations use radians: 25° × π/180 ≈ 0.436332 radians.\n- Mesh Origin: Default cube has vertices at ±1 unit. Scaling by (2, 1, 0.5) gives the target dimensions: \n  X: 4 = 2 × 2, Y: 2 = 2 × 1, Z: 1 = 2 × 0.5.\n- Final Transformation: Location first, then rotation (Blender applies scale, rotation, then translation by default in object mode).\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh with no hierarchy or joints. Structure: world -> cube_object (static mesh).\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. Static placement only. Ensure rotation is applied correctly (Euler rotation order XYZ default). No collision or stability risks.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (4.0, 2.0, 1.0)\ncube_location: (5.0, -1.0, -1.0)\ncube_rotation_x_degrees: 25.0\ncube_rotation_x_radians: 0.4363323129985824\nbase_cube_scale: (2.0, 1.0, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 4x2x1 dimensions (scale default 2m cube by (2,1,0.5))\ncube.scale = (2.0, 1.0, 0.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (5.0, -1.0, -1.0)\ncube.rotation_euler = (math.radians(25.0), 0.0, 0.0)\n\n# Optional: Add a material for visibility\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Cube '{cube.name}' created at {cube.location} with dimensions {cube.dimensions}\")\n```\n</implementation>"}
{"id": 39, "instruction": "Place a cylinder (radius 0.5, height 4) at (-1, 5, -1) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis is a simple static placement task requiring precise geometric transformation. The cylinder must be created with specified dimensions, translated to the target position, and rotated about its local X-axis. No dynamic simulation or complex hierarchy is needed.\n</strategic_layout>\n\n<spatial_layout>\n- Cylinder dimensions: Radius (r) = 0.5m, Height (h) = 4.0m\n- Base cylinder in Blender is created with center at origin, height along Z-axis\n- Translation vector: T = (-1.0, 5.0, -1.0)\n- Rotation: 30° about X-axis = 30 * π/180 ≈ 0.5236 radians\n- Since Blender's default cylinder height is along Z, X-axis rotation will tilt the cylinder forward/backward\n- Final transformation: Rotate then translate\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object: cylinder_mesh\n- No parent-child relationships or joints required\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. Static placement only. Ensure the cylinder doesn't intersect with existing scene objects (none in this case).\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 0.5\ncylinder_height: 4.0\nlocation: (-1.0, 5.0, -1.0)\nrotation_x_degrees: 30\nrotation_x_radians: 0.5236\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.5,\n    depth=4.0,\n    location=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply rotation (30 degrees about X-axis)\ncylinder.rotation_euler[0] = math.radians(30)\n\n# Apply translation\ncylinder.location = (-1.0, 5.0, -1.0)\n\n# Optional: Set smooth shading and single vertex color for clarity\nbpy.ops.object.shade_smooth()\ncylinder.data.materials.clear()\nmat = bpy.data.materials.new(name=\"CylinderMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Reddish color\ncylinder.data.materials.append(mat)\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 38, "instruction": "Place a sphere with radius 1.2 at (7, 0, 2) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static sphere with specific geometric properties. This is a basic 3D modeling operation with no mechanical interactions or physics constraints. The primary considerations are accurate placement and rotation using Blender's coordinate system where Y-axis rotation is around the vertical axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: (7, 0, 2) in world space.\n- Sphere radius: 1.2 units.\n- Rotation: 60° around Y-axis (converted to radians: 60 * π/180 ≈ 1.0472 rad).\n- Bounding box: From (5.8, -1.2, 0.8) to (8.2, 1.2, 3.2) before rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single rigid body with no joints or hierarchy)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The sphere is a single static object, inherently stable at its given location.\n- Dynamic risks: None, as no motion or interactions are specified.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.2\n- sphere_location: (7.0, 0.0, 2.0)\n- rotation_angle_y_degrees: 60.0\n- rotation_angle_y_radians: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with 32 segments and rings for smooth appearance\nbpy.ops.mesh.primitive_uv_sphere_add(\n    segments=32,\n    ring_count=16,\n    radius=1.2,\n    location=(7.0, 0.0, 2.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Sphere_Object\"\n\n# Apply 60-degree rotation around Y-axis (converted to radians)\nsphere.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Optional: Add a material for visibility\nmaterial = bpy.data.materials.new(name=\"Sphere_Material\")\nmaterial.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nsphere.data.materials.append(material)\n```\n</implementation>"}
{"id": 36, "instruction": "Place a 2x4x1 cube at (0, -6, 2) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static object placement task requiring precise coordinate positioning and axis-aligned rotation. The primary challenge is correctly interpreting the dimensional notation (2×4×1 as width×depth×height) and applying the rotation around the local X-axis. No dynamic simulation or complex kinematics are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X)=2.0m, Depth (Y)=4.0m, Height (Z)=1.0m.\n- Center Location: (0.0, -6.0, 2.0) in world coordinates.\n- Rotation: 90° around X-axis (π/2 radians). After rotation, original Y-dimension becomes vertical, and Z-dimension becomes depth.\n- Post-rotation orientation: Faces originally on ±Y now face ±Z, faces originally on ±Z now face ∓Y.\n</spatial_layout>\n\n<kinematic_topology>\n- world → static_cube (Single rigid body with fixed transform, no joints or parent-child relationships)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is placed with its geometric center at Z=2.0, meaning its bottom face will be at Z=1.5 (center 2.0 minus half-height 0.5). This is a stable static placement if no physics enabled.\n- Risk: If rigid body physics were enabled with gravity, the cube would fall since it's in mid-air. However, the task doesn't specify physics activation.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 4.0, 1.0)\n- cube_location: (0.0, -6.0, 2.0)\n- cube_rotation_x_degrees: 90.0\n- cube_rotation_x_radians: 1.570796\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default dimensions (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Placed_Cube\"\n\n# Apply dimensions: scale from default 2m cube to desired 2×4×1\n# Scale factors = desired / default\nscale_x = 2.0 / 2.0  # 1.0\nscale_y = 4.0 / 2.0  # 2.0\nscale_z = 1.0 / 2.0  # 0.5\ncube.scale = (scale_x, scale_y, scale_z)\n\n# Apply scale transformation to mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (0.0, -6.0, 2.0)\n\n# Set rotation: 90° around X-axis\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Optional: Add passive rigid body for potential physics (commented out)\n# bpy.ops.rigidbody.object_add()\n# cube.rigid_body.type = 'PASSIVE'\n\nprint(f\"Created {cube.name} at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 37, "instruction": "Place a 3x2x2 cube at (-2, 2, -5) and rotate it 15° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a static 3D cube with specific dimensions, position, and orientation. This is a foundational 3D modeling operation requiring precise coordinate transformation. The cube must be scaled from Blender's default 2x2x2 unit cube to 3x2x2, translated to (-2, 2, -5) in world space, and rotated 15° around the global Z-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 3m (X-axis) × 2m (Y-axis) × 2m (Z-axis).  \n- Scale Factor Calculation: Default Blender cube is 2×2×2. Required scale vector = (target_x/2, target_y/2, target_z/2) = (3/2, 2/2, 2/2) = (1.5, 1.0, 1.0).\n- World Location: (-2.0, 2.0, -5.0).\n- Rotation: 15° clockwise about global Z-axis (viewed from above). Radians = 15 × π/180 = 0.2618 rad.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh with no parent or joints).\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation is required. The cube is a static object. Ensure the scale is applied (not just transform) to avoid physics engine issues if rigid bodies are added later.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 2.0, 2.0)\n- cube_location: (-2.0, 2.0, -5.0)\n- cube_rotation_z_deg: 15.0\n- scale_vector: (1.5, 1.0, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to 3x2x2 dimensions\ncube.scale = (1.5, 1.0, 1.0)\n# Apply scale to transform actual mesh geometry\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-2.0, 2.0, -5.0)\ncube.rotation_euler = (0, 0, radians(15.0))\n\n# Optional: Add a passive rigid body for future physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 43, "instruction": "Place a cylinder (radius 1.5, height 2) at (2, -3, -2) and rotate it 10° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cylinder with precise dimensional and positional specifications. This involves creating a mesh primitive, scaling it to achieve the required radius and height, positioning it in 3D space, and applying a rotational transformation. The cylinder's local origin will be at its geometric center; the translation must account for this.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Dimensions: Target radius = 1.5 units, height = 2.0 units.\n- Blender Default Cylinder: Default radius = 1.0, default height = 2.0.\n- Scaling Factors: Scale X = 1.5, Scale Y = 1.5 (for radius), Scale Z = 1.0 (height/2.0).\n- Target Location: World coordinates (2.0, -3.0, -2.0).\n- Rotation: 10 degrees counter-clockwise around the global Z-axis (facing positive Z). Convert to radians: 10° × (π/180) ≈ 0.174532925 radians.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh, no hierarchy).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cylinder is a passive object with no dynamics; stability is inherent.\n- Risk: None for static placement. Ensure the transformation order (scale, rotate, translate) is correctly applied.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.5\n- cylinder_height: 2.0\n- cylinder_location: (2.0, -3.0, -2.0)\n- cylinder_rotation_z_degrees: 10.0\n- cylinder_rotation_z_radians: 0.174532925\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects (optional, for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a default cylinder (32 vertices, radius=1, depth=2, aligned on Z)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=2.0,\n    location=(0, 0, 0),\n    rotation=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Apply scaling to achieve target radius and height\ncylinder.scale = (1.5, 1.5, 1.0)  # Scale X/Y for radius, Z for height (2.0/2.0=1.0)\n\n# Set rotation (around global Z-axis)\ncylinder.rotation_euler = (0, 0, math.radians(10.0))\n\n# Set final location\ncylinder.location = (2.0, -3.0, -2.0)\n\n# Apply transformations to make them intrinsic (freeze transform)\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(\"Cylinder created with:\")\nprint(f\"  Radius: {cylinder.dimensions.x / 2:.3f}\")\nprint(f\"  Height: {cylinder.dimensions.z:.3f}\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation (Z): {math.degrees(cylinder.rotation_euler.z):.1f}°\")\n```\n</implementation>"}
{"id": 42, "instruction": "Place a sphere with radius 2 at (0, 0, 8) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is a basic 3D modeling operation: create a spherical mesh, scale it to a specified radius, position it in world space, and apply a rotation. No dynamic simulation or complex assembly is required. The key is to accurately set the geometry and transform properties in Blender.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 2.0 units.\n- Sphere Center: (0.0, 0.0, 8.0).\n- Rotation: 90° around the global X-axis, which in radians is π/2 ≈ 1.5708 rad.\n- Resulting Orientation: The sphere's local Z-axis (pole) will be rotated to align with the global Y-axis.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single static mesh object with no parent or constraints).\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamics or physical interactions are specified. The sphere is a static decorative or placeholder object.\n- Risk: None.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.0\n- sphere_location: (0.0, 0.0, 8.0)\n- sphere_rotation_x_degrees: 90.0\n- sphere_rotation_x_radians: 1.57079632679\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, to start fresh)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a UV sphere with 32 segments and 16 rings (defaults)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    segments=32,\n    ring_count=16,\n    radius=1.0,  # Will be scaled immediately\n    location=(0, 0, 0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Sphere\"\n\n# Set the radius by scaling uniformly (since default radius is 1, scale by 2)\nsphere.scale = (2.0, 2.0, 2.0)\n\n# Apply the scale to make the radius intrinsic\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set the location\nsphere.location = (0.0, 0.0, 8.0)\n\n# Set the rotation: 90 degrees around X-axis\nsphere.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Optional: Set object origin to geometry center (already at center by default)\n# bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n```\n</implementation>"}
{"id": 44, "instruction": "Place a 2x3x2 cube at (-3, -3, 3) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise 3D object placement and transformation. I will create a rectangular prism (2×3×2) at the specified coordinate with a 35° X-axis rotation. This involves understanding Blender's coordinate system, rotation conventions, and ensuring the object's dimensions match the specifications exactly.\n</strategic_analysis>\n\n<spatial_layout>\n- Target Location: (-3.0, -3.0, 3.0) in global coordinates.\n- Dimensions: Width (X) = 2.0m, Depth (Y) = 3.0m, Height (Z) = 2.0m.\n- Rotation: 35° around X-axis (Euler rotation). Convert to radians: 35° × π/180 ≈ 0.610865 rad.\n- Object Origin: Default cube origin at center. The location coordinate will position the object's center at (-3, -3, 3).\n- Bounding Box: After rotation, the vertices will transform but the center remains at the specified location.\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube_object (Static mesh with no parent, no constraints needed for this static placement).\n- Transformation applied directly to the mesh object.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None. Static object placement with no dynamics.\n- Verification: The cube's post-rotation bounding box can be computed but is not required for this task.\n- Safety: Ensure no overlapping with other objects (scene is empty).\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (-3.0, -3.0, 3.0)\n- cube_dimensions: (2.0, 3.0, 2.0)\n- cube_rotation_x_deg: 35.0\n- cube_rotation_x_rad: 0.610865\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube (default 2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve 2×3×2 dimensions\n# Default cube vertices are from -1 to 1, so scaling factor = dimension/2\ncube.scale = (1.0, 1.5, 1.0)  # (2/2, 3/2, 2/2)\n\n# Apply scale to transform\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-3.0, -3.0, 3.0)\ncube.rotation_euler = (math.radians(35.0), 0.0, 0.0)\n\n# Verify dimensions\ndimensions = cube.dimensions\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Dimensions (XYZ): {dimensions.x:.3f}, {dimensions.y:.3f}, {dimensions.z:.3f}\")\nprint(f\"Rotation (radians): {cube.rotation_euler.x:.3f}\")\n```\n</implementation>"}
{"id": 47, "instruction": "Place a cylinder (radius 2, height 3) at (-7, 0, 2) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical obstacle with specific dimensions, position, and orientation. This requires precise geometric modeling with accurate translation and rotation transformations in Blender's 3D space.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Dimensions: Radius (R) = 2.0m, Height (H) = 3.0m\n- Translation: Vector (-7, 0, 2). Note that Z=2 positions the cylinder's base 2m above ground since Blender cylinders are centered by default.\n- Rotation: 25° counterclockwise around X-axis. In radians: θ = 25 * π/180 ≈ 0.4363 rad.\n- To achieve base at Z=2, we offset the cylinder's local origin: Default cylinder origin is at center (height range -H/2 to H/2). For base at Z=2, we need center at Z = 2 + H/2 = 2 + 1.5 = 3.5.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with no joints or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required for static placement.\n- Verification: The cylinder will remain fixed at specified coordinates and orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.0\n- cylinder_height: 3.0\n- location: (-7.0, 0.0, 3.5)  # Adjusted for base at Z=2\n- rotation_x_degrees: 25.0\n- rotation_x_radians: 0.4363323129985824\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.0,\n    depth=3.0,\n    location=(-7.0, 0.0, 3.5)  # Center at Z=3.5 for base at Z=2\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply 25° rotation around X-axis (converted to radians)\ncylinder.rotation_euler[0] = math.radians(25.0)\n\n# Update scene\nbpy.context.view_layer.update()\n\n# Optional: Add a ground plane for visual reference\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0,0,0))\nground = bpy.context.active_object\nground.name = \"Ground\"\n```\n</implementation>"}
{"id": 41, "instruction": "Place a 1x2x3 cube at (-6, 1, 1) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a simple rectangular prism with non-uniform dimensions (1×2×3) at a specific location (-6,1,1) with a 45° rotation around the Y-axis. This is a fundamental 3D modeling operation involving mesh creation, transformation, and coordinate system understanding. No physical simulation is needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 1m, height (Z) = 2m, depth (Y) = 3m.\n- Desired location: world coordinates (-6, 1, 1). The Z=1 coordinate positions the cube's base at ground level given its 2m height.\n- Rotation: 45° around global Y-axis = 0.785398 radians.\n- The cube's local origin will be at its geometric center by default, so the specified location places the center at (-6,1,1).\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The object is static and will remain at the specified transform.\n</predictive_simulation>\n\n<parameter_summary>\nlocation: (-6.0, 1.0, 1.0)\ndimensions: (1.0, 3.0, 2.0)  # Blender: (X, Y, Z) = (width, depth, height)\nrotation_y_degrees: 45.0\nrotation_y_radians: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0,0,0))\ncube = bpy.context.active_object\ncube.name = \"TaskCube\"\n\n# Apply non-uniform scaling to achieve 1x2x3 dimensions\n# Since default cube is 2m³, scale factors: (1/2, 3/2, 2/2) = (0.5, 1.5, 1.0)\ncube.scale = (0.5, 1.5, 1.0)\n\n# Apply scale to make dimensions permanent in mesh data\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set final transform: location and rotation\ncube.location = (-6.0, 1.0, 1.0)\ncube.rotation_euler = (0.0, radians(45.0), 0.0)\n\n# Apply rotation to mesh data (optional, keeps transform clean)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Verify dimensions\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 48, "instruction": "Place a 3x3x3 cube at (2, 2, 2) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a basic 3D modeling and transformation task requiring precise geometric placement and rotation. The core challenge is understanding Blender's coordinate system and transformation order (scale, rotation, location). The cube must be created with proper dimensions, positioned, and rotated without distortion.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 3m × 3m × 3m (scale factor of 1.5 from default 2m Blender cube)\n- Target location: (2, 2, 2) in global coordinates\n- Rotation: 45° around Y-axis = π/4 radians\n- Transformation order: Create unit cube → Scale to dimensions → Apply rotation → Set location\n- Bounding box after rotation: Rotated cube will extend approximately ±2.12m in X/Z directions from center\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body with no joints or constraints\n- Hierarchy: world → cube_object (transform only)\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: Applying rotation after location could cause orbital rotation around origin\n- Mitigation: Apply rotation first at origin, then translate to final position\n- Stability: N/A for static object\n- Verification: Check final transform matrix matches expected position and orientation\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 3.0, 3.0)\n- cube_location: (2.0, 2.0, 2.0)\n- cube_rotation_y: 0.785398 (45° in radians)\n- base_scale_factor: 1.5 (3.0/2.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube at origin (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Target_Cube\"\n\n# Scale to 3x3x3 (scale factor = desired/initial = 3/2 = 1.5)\ncube.scale = (1.5, 1.5, 1.5)\n\n# Apply scale transform to make it actual geometry\nbpy.ops.object.transform_apply(scale=True)\n\n# Set rotation (45° around Y axis)\ncube.rotation_euler = (0, math.radians(45), 0)\n\n# Set final position\ncube.location = (2.0, 2.0, 2.0)\n\n# Verify transformations\nprint(f\"Cube created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (degrees): {[math.degrees(a) for a in cube.rotation_euler]}\")\n```\n</implementation>"}
{"id": 46, "instruction": "Place a sphere with radius 1 at (5, 5, 5) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a simple static sphere with specific geometric properties and transformation. No mechanical systems or dynamics are required. We simply need to construct a sphere mesh with radius 1, position it at coordinates (5, 5, 5), and apply a 120° rotation about the Z-axis. The key considerations are correct unit handling (degrees vs radians) and transformation order.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center location: (x, y, z) = (5.0, 5.0, 5.0)\n- Sphere radius: r = 1.0\n- Rotation angle: θ_z = 120° = 2.09439510239 radians (since Blender uses radians)\n- Transformation order: Apply location then rotation (scale remains identity)\n- Bounding box: The axis-aligned bounding box will be [4, 6] in all dimensions after rotation (since sphere is symmetric)\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere_object (Single static mesh with no parent, no armature or joints required)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation needed for this static placement task\n- Collision considerations: None specified\n- The rotation about Z-axis doesn't change the sphere's visual appearance due to symmetry, but the transformation matrix will contain the rotation\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.0\n- sphere_location: (5.0, 5.0, 5.0)\n- rotation_angle_z_degrees: 120.0\n- rotation_angle_z_radians: 2.09439510239\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with radius 1\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,\n    location=(0, 0, 0)  # Will set location separately\n)\nsphere = bpy.context.active_object\nsphere.name = \"Sphere_Object\"\n\n# Set location\nsphere.location = (5.0, 5.0, 5.0)\n\n# Set rotation (120 degrees about Z-axis)\nsphere.rotation_euler = (0.0, 0.0, math.radians(120.0))\n\n# Optional: Set display properties\nsphere.display_type = 'SOLID'\nbpy.context.object.data.use_auto_smooth = True\n\n# Verify transformations\nprint(f\"Sphere created: {sphere.name}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation (radians): {sphere.rotation_euler}\")\nprint(f\"Radius: {sphere.dimensions.x / 2}\")  # Approximate verification\n```\n</implementation>"}
{"id": 40, "instruction": "Place a 5x2x1 cube at (6, 2, 2) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThis task involves precise static object placement with specific dimensions, location, and orientation. The 5x2x1 cube will be created and positioned at world coordinates (6,2,2), then rotated 20 degrees around the global Z-axis. No dynamic simulation is required - this is purely a geometric modeling task.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 5.0m, Depth (Y) = 2.0m, Height (Z) = 1.0m\n- Target location: Center point at (6, 2, 2) in world coordinates\n- Rotation: 20° around global Z-axis (positive rotation follows right-hand rule)\n- Default cube origin: Center of geometry\n- Coordinate system: Right-handed (X-right, Y-forward, Z-up)\n- Rotation conversion: 20° × π/180 = 0.34906585 radians\n</spatial_layout>\n\n<kinematic_topology>\nStatic object hierarchy:\n- world (global coordinate system)\n  └── cube_5x2x1 (static mesh with transform applied)\nNo joints or constraints required for this static placement.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The cube is static and will remain at the specified transform. Ensure the rotation is applied correctly around the global Z-axis rather than local axes.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (5.0, 2.0, 1.0)\ntarget_location: (6.0, 2.0, 2.0)\nrotation_angle_deg: 20.0\nrotation_angle_rad: 0.34906585\nrotation_axis: (0.0, 0.0, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"cube_5x2x1\"\n\n# Apply scaling to achieve 5x2x1 dimensions\n# Default cube is 2m per side, so scale factors = desired/2\nscale_x = 5.0 / 2.0\nscale_y = 2.0 / 2.0\nscale_z = 1.0 / 2.0\ncube.scale = (scale_x, scale_y, scale_z)\n\n# Apply scale transform to make dimensions permanent\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location\ncube.location = (6.0, 2.0, 2.0)\n\n# Set rotation: 20 degrees around global Z-axis\nrotation_angle_rad = math.radians(20.0)\ncube.rotation_euler = (0.0, 0.0, rotation_angle_rad)\n\n# Apply rotation transform\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Verify final transform\nprint(f\"Cube created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (Euler): {cube.rotation_euler}\")\n\n# Optional: Add material for visibility\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n```\n</implementation>"}
{"id": 50, "instruction": "Place a sphere with radius 0.6 at (-4, -4, 0) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is straightforward: create a single sphere primitive with specific geometric properties. This involves creating the sphere mesh, positioning it in 3D space via translation, and applying a rotation transformation around the X-axis. No complex physics or mechanisms are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (r): 0.6 units.\n- Sphere Center Location (x, y, z): (-4.0, -4.0, 0.0).\n- Rotation Angle (θ_x): 60.0 degrees about the X-axis, applied in the local object space.\n- The sphere's geometry is defined by its radius. Its final pose is defined by the translation and rotation transformation.\n</spatial_layout>\n\n<kinematic_topology>\nA single, independent object exists in the scene:\n- world -> sphere_object (A mesh object with no parent)\n</kinematic_topology>\n\n<predictive_simulation>\nThere are no dynamic elements, stability concerns, or collision risks to assess in this static modeling task.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.6\n- sphere_location: (-4.0, -4.0, 0.0)\n- rotation_angle_x_degrees: 60.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear the existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a UV Sphere with the specified radius\n# The sphere is created initially at the world origin (0,0,0)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.6)\nsphere = bpy.context.active_object\nsphere.name = \"Sphere_Object\"\n\n# Set the sphere's location\nsphere.location = (-4.0, -4.0, 0.0)\n\n# Apply rotation of 60 degrees around the X-axis.\n# Blender's rotation_euler uses radians.\nrotation_radians = math.radians(60.0)\nsphere.rotation_euler = (rotation_radians, 0.0, 0.0)\n\n# Optionally, update the scene to ensure transformations are applied\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 49, "instruction": "Place a 1x1x5 cube at (0, 2, -6) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a single rectangular prism in 3D space. This is a basic rigid body transformation exercise requiring accurate translation and rotation operations. The cube's dimensions (1x1x5) indicate a tall, slender shape that will be rotated 90° around the Z-axis, changing its orientation while maintaining its world position.\n</strategic_analysis>\n\n<spatial_layout>\n- Initial object: Cube with dimensions (1, 1, 5)\n- Target location: (0, 2, -6) in world coordinates\n- Target rotation: 90° (π/2 radians) around global Z-axis\n- Transformation order: Scale to correct dimensions → Translate to target location → Rotate around Z-axis\n- Note: Default Blender cube is 2x2x2, so scaling factor = (0.5, 0.5, 2.5)\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world → transformed_cube\n- No joints or constraints needed\n- Static transformation only\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required for this static placement\n- The slender shape (5 units tall) when rotated 90° around Z-axis will lie horizontally in the XY plane\n- Center of mass remains at specified location\n</predictive_simulation>\n\n<parameter_summary>\n- base_dimensions: (1.0, 1.0, 5.0)\n- target_location: (0.0, 2.0, -6.0)\n- target_rotation_z: 90.0 (degrees)\n- scale_factors: (0.5, 0.5, 2.5)  # from default 2x2x2 cube\n- rotation_radians: 1.57079632679  # π/2\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"target_cube\"\n\n# Apply scaling to achieve 1x1x5 dimensions\n# Default cube is 2x2x2, so scale factors = desired/2\ncube.scale = (0.5, 0.5, 2.5)\n\n# Apply scale transformation to make it permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (0.0, 2.0, -6.0)\n\n# Set rotation (90° around Z-axis)\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Update scene\nbpy.context.view_layer.update()\n\n# Optional: Add visual materials for clarity\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blue color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Cube created at {cube.location} with rotation {cube.rotation_euler}\")\nprint(f\"Dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 51, "instruction": "Place a cylinder (radius 1, height 5) at (3, -5, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a simple cylindrical obstacle with specified dimensions, position, and orientation. This static object placement requires accurate geometric modeling but no complex physics or kinematics. The cylinder will be created as a passive rigid body by default for potential future simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0m\n- Cylinder height: 5.0m\n- World location: (x=3.0m, y=-5.0m, z=0.0m)\n- Rotation: 15° around Y-axis\n- Conversion to radians: 15° × (π/180) = 0.261799 rad\n- The cylinder's base will be at z=0, extending to z=5.0m with the origin at the center.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object with no hierarchical relationships:\n- world -> cylinder (passive rigid body)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder has uniform mass distribution and wide base (radius=1m, height=5m).\n- Center of mass: At (3, -5, 2.5) when upright, remains stable as a passive object.\n- No dynamic risks for static placement.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 5.0\n- location_x: 3.0\n- location_y: -5.0\n- location_z: 0.0\n- rotation_y_deg: 15.0\n- rotation_y_rad: 0.261799\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=5.0,\n    location=(3.0, -5.0, 0.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Cylinder_Obstacle\"\n\n# Apply rotation (15° around Y-axis)\ncylinder.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add rigid body physics (passive by default)\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 45, "instruction": "Place a 4x1x2 cube at (1, 4, -4) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nWe need to place a rectangular prism with dimensions 4×1×2 units at coordinates (1, 4, -4) and rotate it 75° around the Y-axis. This is a straightforward transformation operation in Blender involving scaling a default cube primitive to match the target dimensions, then applying translation and rotation transforms.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 4.0, Depth (Y) = 1.0, Height (Z) = 2.0\n- Default Blender cube is 2×2×2 units (vertices at ±1 on each axis)\n- Scaling factors: (4.0/2.0, 1.0/2.0, 2.0/2.0) = (2.0, 0.5, 1.0)\n- Target location: (1.0, 4.0, -4.0)\n- Rotation: 75° around Y-axis = 75 × π/180 ≈ 1.30899694 radians\n- Transform order: Scale, then rotate, then translate (standard Blender object transformation)\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no joints or constraints. Simple hierarchy:\n- world → cube_object (transformed mesh)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The cube will remain statically positioned. Ensure the rotation is applied correctly around the object's local Y-axis, not the global Y-axis.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 1.0, 2.0)\n- cube_location: (1.0, 4.0, -4.0)\n- cube_rotation_y_degrees: 75.0\n- cube_rotation_y_radians: 1.30899694\n- default_cube_size: 2.0\n- scale_factors: (2.0, 0.5, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 4×1×2 dimensions\ncube.scale = (2.0, 0.5, 1.0)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (1.0, 4.0, -4.0)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Optional: Set visual properties\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)\ncube.data.materials.append(mat)\n\nprint(f\"Cube created at {cube.location} with rotation {math.degrees(cube.rotation_euler.y):.1f}°\")\nprint(f\"Dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 54, "instruction": "Place a sphere with radius 2.2 at (8, 1, -1) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static sphere with specific geometric properties. This requires setting the sphere's radius to 2.2 units, positioning it at coordinates (8, 1, -1), and applying a 90-degree rotation around the Y-axis. In Blender, rotations are typically applied in radians, so conversion is needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 2.2 units\n- Translation vector: (8.0, 1.0, -1.0)\n- Rotation: 90° around Y-axis = π/2 radians ≈ 1.5708 radians\n- The sphere is a primitive mesh centered at the origin initially. Transformation is applied directly.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world → sphere (static mesh with no joints)\n- No constraints or parent-child relationships required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Sphere is a uniform convex shape; placement is inherently stable.\n- No dynamic risks since the object is static and non-physics enabled.\n- Transformation order: Blender applies rotation then translation when using the add operator with parameters.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.2\n- sphere_location: (8.0, 1.0, -1.0)\n- sphere_rotation_y_degrees: 90.0\n- sphere_rotation_y_radians: 1.5708\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified parameters\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.2,\n    location=(8.0, 1.0, -1.0),\n    rotation=(0.0, math.radians(90.0), 0.0)\n)\n\n# Rename the sphere object\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Optionally set smooth shading for better visualization\nbpy.ops.object.shade_smooth()\n```\n</implementation>"}
{"id": 55, "instruction": "Place a cylinder (radius 0.8, height 3) at (-3, 4, -2) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a static placement task requiring precise dimensional and rotational control. The cylinder must be created with exact radius (0.8) and height (3), positioned at coordinates (-3, 4, -2), and rotated 120° around the Z-axis. No dynamic simulation or physical constraints are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center position: (x, y, z) = (-3.0, 4.0, -2.0)\n- Cylinder dimensions: radius = 0.8 m, height = 3.0 m\n- Rotation: 120° counterclockwise around global Z-axis (Euler rotation in radians: 120° × π/180 = 2.0944 rad)\n- Local origin: Blender's default cylinder origin is at geometric center (midpoint along height axis)\n- No spatial relationships with other objects are specified\n</spatial_layout>\n\n<kinematic_topology>\n- world → cylinder (Static Mesh, no parent-child relationships or joints)\n- Single rigid body transformation with translation and rotation only\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder's base at z = -2 - (height/2) = -3.5 m, center at z = -2.0 m, top at z = -0.5 m\n- Risk: None identified for static placement\n- Verification: Ensure rotation is applied correctly (120° around Z, not local axis unless specified)\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.8\n- cylinder_height: 3.0\n- cylinder_location: (-3.0, 4.0, -2.0)\n- cylinder_rotation_z_degrees: 120.0\n- cylinder_rotation_z_radians: 2.0943951023931953\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects (optional, but ensures clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,  # Standard resolution\n    radius=0.8,\n    depth=3.0,\n    location=(-3.0, 4.0, -2.0),\n    rotation=Euler((0.0, 0.0, math.radians(120.0)), 'XYZ')\n)\n\n# Rename for clarity\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Optional: Apply rotation to object data for clean transforms\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Verify parameters\nprint(f\"Cylinder created:\")\nprint(f\"  Radius: {cylinder.dimensions.x / 2:.3f}\")\nprint(f\"  Height: {cylinder.dimensions.z:.3f}\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation (Euler Z): {math.degrees(cylinder.rotation_euler.z):.1f}°\")\n```</implementation>"}
{"id": 56, "instruction": "Place a 4x1x3 cube at (0, 3, 6) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static rectangular prism (cube) with given dimensions and transforming it to a specific location and orientation. This is a fundamental 3D modeling operation requiring precise geometric placement. Since it's a static object, no dynamic simulation or complex kinematics are required.\n</strategic_layout>\n\n<spatial_layout>\n- Cube Dimensions: 4m (width, X-axis), 1m (depth, Y-axis), 3m (height, Z-axis).\n- Target Location: (X=0m, Y=3m, Z=6m). This positions the object's origin at these world coordinates.\n- Target Rotation: 60° about the X-axis. In radians: 60° * (π/180) ≈ 1.04719755 rad.\n- Local vs. Global: Blender applies rotation in object's local space. A 60° X-rotation will tilt the cube forward, making its top face point downward at a 30° angle from horizontal (since 90° - 60° = 30°).\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body with no parent or joints.\n- Hierarchy: world -> cube_object (static mesh).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The object is static; no dynamic stability concerns.\n- Risk: None. The object is placed in free space with no collisions specified.\n- Verification: Ensure rotation is applied correctly (X-axis) and dimensions match the specified 4x1x3 ratio.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (4.0, 1.0, 3.0)\n- location: (0.0, 3.0, 6.0)\n- rotation_x_degrees: 60.0\n- rotation_x_radians: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects in the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create the cube with specified dimensions\n# Blender's default cube is 2x2x2, so we scale by half the desired dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"PlacedCube\"\n\n# Set the dimensions directly (more accurate than scaling)\ncube.dimensions = (4.0, 1.0, 3.0)\n\n# Apply the scale to make dimensions permanent and avoid distortion\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 3.0, 6.0)\ncube.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Optional: Add a passive rigid body for potential physics scenes\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\nprint(f\"Cube '{cube.name}' created at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 52, "instruction": "Place a 2x2x4 cube at (-2, 0, -6) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a simple static geometric primitive with specific transformations. The core requirements are accurate dimension scaling, precise positioning, and correct rotational transformation around the Z-axis. Since it's a static mesh, no physics or kinematics are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Default Blender cube dimensions: 2m x 2m x 2m.\n- Target dimensions: width=2m (X), depth=2m (Y), height=4m (Z). This requires scaling factor of (1, 1, 2) on the default cube.\n- Location coordinates: X=-2m, Y=0m, Z=-6m.\n- Rotation: 30° around global Z-axis, which is 0.523599 radians (π/6).\n- Transformation order: Scale → Location → Rotation.\n</spatial_layout>\n\n<kinematic_topology>\nStatic mesh hierarchy:\n- world → cube_object (Static mesh with transform)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The cube is purely static geometry. All transformations are applied directly to the mesh data or object transform.\n</predictive_simulation>\n\n<parameter_summary>\n- base_dimensions: (2.0, 2.0, 2.0)\n- target_dimensions: (2.0, 2.0, 4.0)\n- scale_factors: (1.0, 1.0, 2.0)\n- location: (-2.0, 0.0, -6.0)\n- rotation_angle_degrees: 30.0\n- rotation_angle_radians: 0.5235987755982988\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create base cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling for 2x2x4 dimensions\ncube.scale = (1.0, 1.0, 2.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-2.0, 0.0, -6.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Optional: Add visual material for clarity\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\n# Update viewport\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 58, "instruction": "Place a sphere with radius 1.8 at (2, -6, 2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: place a sphere with specified radius at given coordinates and apply a Z-axis rotation. Since rotation doesn't change a sphere's appearance, this tests transformation application rather than physical behavior. The implementation focuses on precise object creation and transformation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (x, y, z) = (2.0, -6.0, 2.0)\n- Sphere radius: r = 1.8 units\n- Rotation: θ = 45° about global Z-axis (Euler angles (0, 0, π/4 radians))\n- Transformation order: Scale (radius) → Rotation → Translation (location)\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere_object (Single rigid body with no parent)\n- No joints or constraints required for static placement\n</kinematic_topology>\n\n<predictive_simulation>\n- Static stability: Sphere is symmetric and will remain stable at given coordinates.\n- Rotation impact: Since spheres are isotropic, Z-rotation is visually irrelevant but tests transformation pipeline.\n- Collision considerations: Sphere may intersect other objects at radius 1.8 from center (2, -6, 2).\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.8\nsphere_location: (2.0, -6.0, 2.0)\nsphere_rotation_z_deg: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\n# Default sphere has radius 1.0, so we scale by 1.8\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,  # Will be scaled\n    location=(0, 0, 0),\n    scale=(1.8, 1.8, 1.8)\n)\nsphere = bpy.context.active_object\nsphere.name = \"TargetSphere\"\n\n# Apply rotation (45° about Z-axis)\nsphere.rotation_euler = (0, 0, math.radians(45.0))\n\n# Apply location\nsphere.location = (2.0, -6.0, 2.0)\n\n# Apply transforms to make transformations explicit in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Optional: Add rigid body physics for future simulations\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.collision_shape = 'SPHERE'\n```\n</implementation>"}
{"id": 59, "instruction": "Place a cylinder (radius 1.3, height 2.7) at (4, 1, 5) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static cylindrical object with precise dimensional and positional constraints. This is a fundamental 3D modeling operation involving primitive creation, geometric transformation, and coordinate system manipulation. The cylinder's orientation requires converting angular displacement from degrees to radians for Blender's internal representation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: Radius (r) = 1.3 units, Height (h) = 2.7 units\n- World coordinate placement: Center at (x, y, z) = (4.0, 1.0, 5.0)\n- Rotation transformation: 35° about global X-axis\n- Angular conversion: θ_x = 35° × (π/180°) ≈ 0.610865 radians\n- Vertex computation: Default cylinder has 32 vertices (Blender default)\n- Origin location: At geometric center (default cylinder creation)\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body with no hierarchical dependencies:\n- world → cylinder_object (Static mesh with transform)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Collision risk: None specified\n- Render consideration: Ensure smooth shading for cylindrical surface\n- Coordinate system: Blender uses right-handed Z-up coordinate system\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 1.3\ncylinder_height: 2.7\ncylinder_location: (4.0, 1.0, 5.0)\ncylinder_rotation_x_degrees: 35\ncylinder_rotation_x_radians: 0.610865\ncylinder_vertices: 32\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified parameters\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.3,\n    depth=2.7,\n    location=(4.0, 1.0, 5.0),\n    rotation=(0.610865, 0.0, 0.0)  # 35° in radians about X-axis\n)\n\n# Get reference to created cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Apply smooth shading for better visual representation\nbpy.ops.object.shade_smooth()\n\n# Optional: Add subdivision surface modifier for higher mesh resolution\nsubdiv = cylinder.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nsubdiv.levels = 2\nsubdiv.render_levels = 2\n\n# Update scene\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 60, "instruction": "Place a 3x2x4 cube at (-1, -1, -7) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves precise 3D object placement with specific dimensions, location, and rotation. We must create a rectangular prism (cube in the generic sense) with non-uniform scaling, position it in world space, and apply a rotational transformation. This requires careful attention to Blender's coordinate system and transformation order (scale, rotation, translation).\n</strategic_layout>\n\n<spatial_layout>\n- Object dimensions: 3m (X) × 2m (Y) × 4m (Z)\n- World location: (-1, -1, -7) in meters\n- Rotation: 15° around global Y-axis = 0.261799 radians\n- Since Blender's default cube is 2×2×2, scaling factors are:\n  Scale X = 3/2 = 1.5\n  Scale Y = 2/2 = 1.0  \n  Scale Z = 4/2 = 2.0\n- Transform order: Apply scale first, then rotation, then translation to achieve desired final state.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_object (Static mesh with rigid body properties if simulating)\n- No joints or hierarchy needed for static placement.\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required for static placement.\n- If rigid body physics were added, the object's center of mass would be at its geometric center (-1, -1, -7) with mass proportional to volume (24 m³).\n- Stability: The object rests on its XY-plane face (normal along Z) given its dimensions.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (3.0, 2.0, 4.0)\n- location: (-1.0, -1.0, -7.0)\n- rotation_y_degrees: 15.0\n- scale_factors: (1.5, 1.0, 2.0)\n- default_cube_size: 2.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"3x2x4_Cube\"\n\n# Apply scaling to achieve 3x2x4 dimensions\ncube.scale = (1.5, 1.0, 2.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-1.0, -1.0, -7.0)\ncube.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Optional: Add rigid body for physics simulation\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 24.0  # Proportional to volume (3*2*4 = 24 m³)\n\n# Verify dimensions\nprint(f\"Object: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (degrees): {math.degrees(cube.rotation_euler.y):.1f}°\")\n```\n</implementation>"}
{"id": 63, "instruction": "Place a cylinder (radius 1, height 1.5) at (-2, 6, 1) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static cylinder with specific dimensions, position, and orientation. No mechanical assembly, physics simulation, or complex kinematics are needed. The solution involves straightforward geometric modeling using Blender's primitive creation and transform operations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0 m\n- Cylinder height: 1.5 m\n- World position: (-2.0, 6.0, 1.0) in meters\n- Rotation: 45° around global Z-axis (0.7854 radians)\n- Note: The cylinder's local origin will be at its geometric center\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object: cylinder_001 (no hierarchy or joints required)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The cylinder is static and will remain at the specified transform. Ensure the rotation is applied correctly to avoid future animation issues.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 1.5\n- location_x: -2.0\n- location_y: 6.0\n- location_z: 1.0\n- rotation_z_deg: 45.0\n- rotation_z_rad: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=1.5,\n    location=(-2.0, 6.0, 1.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"cylinder_001\"\n\n# Apply 45-degree rotation around Z-axis (convert degrees to radians)\ncylinder.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Optional: Apply transforms to make rotation permanent in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(f\"Cylinder '{cylinder.name}' created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 57, "instruction": "Place a 2x5x1 cube at (-5, 2, 0) and rotate it 25° on the Y-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static rectangular prism (cube with non-uniform dimensions) at a specific location with a simple rotation. This involves basic 3D modeling operations: creating a mesh primitive, scaling to achieve non-uniform dimensions, positioning in world space, and applying a rotation transformation. No physics or dynamic constraints are involved.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2 units (X) × 5 units (Y) × 1 unit (Z)\n- Location: World coordinates (-5, 2, 0)\n- Rotation: 25° around global Y-axis (counterclockwise from +X toward +Z)\n- Blender's default cube is 2×2×2, so scaling factors: X=1.0, Y=2.5, Z=0.5\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object: rectangular_prism\n- No hierarchy or joints required\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation needed for static placement\n- Object will remain fixed at specified location and orientation\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (2.0, 5.0, 1.0)\n- location: (-5.0, 2.0, 0.0)\n- rotation_y_degrees: 25.0\n- scale_factors: (1.0, 2.5, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"rectangular_prism\"\n\n# Apply non-uniform scaling for 2×5×1 dimensions\n# Default cube dimensions: 2×2×2, so scale factors:\n# X: 2.0/2.0 = 1.0, Y: 5.0/2.0 = 2.5, Z: 1.0/2.0 = 0.5\ncube.scale = (1.0, 2.5, 0.5)\n\n# Apply scale to mesh data to avoid distortion\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (-5.0, 2.0, 0.0)\n\n# Set rotation (25° around Y-axis)\ncube.rotation_euler = (0.0, radians(25.0), 0.0)\n\n# Optional: Set display properties\ncube.data.name = \"RectangularPrismMesh\"\ncube.show_wire = True\ncube.show_all_edges = True\n\nprint(f\"Created {cube.name} at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 62, "instruction": "Place a sphere with radius 2.7 at (0, 8, 0) and rotate it 30° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward 3D modeling task requiring precise geometric placement. A sphere with defined radius must be positioned at specific coordinates and oriented with a Y-axis rotation. No complex physics or kinematics are involved—pure static mesh transformation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: (0, 8, 0).\n- Sphere radius: 2.7 units.\n- Rotation: 30° around global Y-axis (Euler angles: 0, 30°, 0).\n- Bounding box dimensions: Diameter = 5.4 units in all axes.\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent mesh object: sphere_01.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The sphere is a static mesh with no constraints or collisions configured.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.7\n- sphere_location: (0, 8, 0)\n- sphere_rotation_y_deg: 30\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with 32 segments/rings for smooth appearance\nbpy.ops.mesh.primitive_uv_sphere_add(\n    segments=32,\n    ring_count=16,\n    radius=2.7,\n    location=(0, 8, 0),\n    rotation=(0, math.radians(30), 0)\n)\n\n# Name the sphere object\nsphere = bpy.context.active_object\nsphere.name = \"sphere_01\"\n\n# Ensure correct scale\nsphere.scale = (1.0, 1.0, 1.0)\n\n# Apply rotation and scale transformations\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Update scene\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 64, "instruction": "Place a 2x4x2 cube at (5, 0, -5) and rotate it 20° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a simple static 3D object - a rectangular prism (cube) with specific dimensions, placement, and orientation. This requires precise control over the object's geometry, location, and rotation in 3D space. Since it's a static object, no dynamic physics or mechanisms are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 2m, height (Y) = 4m, depth (Z) = 2m\n- Location: X=5.0m, Y=0.0m, Z=-5.0m (Blender uses Z-up coordinate system)\n- Rotation: 20° around the X-axis\n- Rotation conversion: 20° × (π/180) = 0.349066 radians\n- Object center: The cube will be centered at the specified location\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (Static Mesh with transform only)\n- No joints or constraints needed for static placement\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required for static placement\n- Ensure object is properly scaled and rotated before placement\n- Verify rotation axis (X-axis) corresponds to Blender's coordinate system\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 4.0, 2.0)\n- cube_location: (5.0, 0.0, -5.0)\n- cube_rotation_degrees: 20.0\n- cube_rotation_radians: 0.349066\n- rotation_axis: 'X'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\n# Blender's default cube is 2x2x2, so we need to scale it\nbpy.ops.mesh.primitive_cube_add(size=2.0)  # Size is the overall dimension\ncube = bpy.context.active_object\ncube.name = \"Cube_2x4x2\"\n\n# Apply scaling to achieve 2x4x2 dimensions\n# Since default cube is 2x2x2, scaling factors are: (2/2, 4/2, 2/2) = (1, 2, 1)\ncube.scale = (1.0, 2.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (5.0, 0.0, -5.0)\n\n# Set rotation (20 degrees around X-axis)\nrotation_rad = math.radians(20.0)\ncube.rotation_euler = Euler((rotation_rad, 0.0, 0.0), 'XYZ')\n\n# Apply rotation to make it permanent\nbpy.ops.object.transform_apply(rotation=True)\n\n# Alternative approach: Create with correct dimensions directly\n# bpy.ops.mesh.primitive_cube_add(size=1.0, location=(5, 0, -5))\n# cube = bpy.context.active_object\n# cube.scale = (1.0, 2.0, 1.0)  # Results in 2x4x2 dimensions\n# cube.rotation_euler = Euler((math.radians(20), 0, 0), 'XYZ')\n# bpy.ops.object.transform_apply(scale=True, rotation=True)\n\nprint(f\"Cube created at {cube.location} with dimensions {cube.dimensions}\")\n```\n</implementation>"}
{"id": 66, "instruction": "Place a sphere with radius 1.1 at (3, 7, -2) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement task with no dynamic constraints. The core requirements are precise geometric positioning (location and rotation) of a primitive sphere. Since there are no interactions or physics requirements, we can implement this as a static mesh with exact transformations.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 1.1 units (diameter 2.2 units)\n- Sphere center location: (X=3.0, Y=7.0, Z=-2.0) in global coordinates\n- Rotation: 60° about the Z-axis (applied after location)\n- Transform order: First scale by radius, then rotate, then translate to final position\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent object hierarchy:\n- world → sphere_object (Static Mesh with transform)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic behavior required. The sphere will remain statically positioned. Rotation about Z-axis only affects visual orientation, not collision properties (if added later).\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.1\n- sphere_location: (3.0, 7.0, -2.0)\n- sphere_rotation_z_degrees: 60.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with 32 segments and rings\nbpy.ops.mesh.primitive_uv_sphere_add(\n    segments=32,\n    ring_count=16,\n    radius=1.0,  # Will scale to correct radius\n    location=(0, 0, 0)  # Create at origin\n)\nsphere = bpy.context.active_object\nsphere.name = \"Sphere\"\n\n# Apply transformations based on parameters\nsphere.scale = (1.1, 1.1, 1.1)  # Scale from unit radius to 1.1\nsphere.location = (3.0, 7.0, -2.0)\nsphere.rotation_euler = (0, 0, math.radians(60.0))  # Convert degrees to radians\n\n# Apply transformations to make them base transformations\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Optional: Add material for visibility\nmat = bpy.data.materials.new(name=\"Sphere_Material\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nif sphere.data.materials:\n    sphere.data.materials[0] = mat\nelse:\n    sphere.data.materials.append(mat)\n```\n</implementation>"}
{"id": 53, "instruction": "Place a 1x3x2 cube at (6, -2, 1) and rotate it 45° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static rectangular prism (1x3x2 units) at a specified world coordinate with a 45° rotation around the X-axis. This is a basic 3D modeling operation requiring precise placement and orientation. We'll create the cube using Blender's primitive system and apply transformations directly.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (width×depth×height): X=1, Y=3, Z=2 units\n- World location: (6, -2, 1)\n- Rotation: 45° around X-axis (0.785398 radians)\n- The cube's local origin will be at its geometric center after creation\n- No clearance or interference checks needed for this static object\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no joints or hierarchy:\n- world → rotated_cube (Mesh with transform)\n</kinematic_topology>\n\n<predictive_simulation>\n- Static object with no dynamics required\n- No collision or stability risks for basic placement\n- Rotation applied in local coordinate system (X-axis rotation relative to object's orientation)\n</predictive_simulation>\n\n<parameter_summary>\ncube_width: 1.0\ncube_depth: 3.0\ncube_height: 2.0\nlocation_x: 6.0\nlocation_y: -2.0\nlocation_z: 1.0\nrotation_x_deg: 45.0\nrotation_x_rad: 0.7853981633974483\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with specified dimensions\n# Default cube in Blender is 2x2x2, so we'll scale accordingly\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"RotatedCube\"\n\n# Set dimensions (scale from default 2x2x2 cube)\ncube.scale.x = 0.5  # 1.0 / 2.0\ncube.scale.y = 1.5  # 3.0 / 2.0\ncube.scale.z = 1.0  # 2.0 / 2.0\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location.x = 6.0\ncube.location.y = -2.0\ncube.location.z = 1.0\n\n# Set rotation (45° around X-axis)\ncube.rotation_euler.x = math.radians(45.0)\ncube.rotation_euler.y = 0.0\ncube.rotation_euler.z = 0.0\n\n# Add visual verification by setting material\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Cube created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (degrees): ({math.degrees(cube.rotation_euler.x):.1f}, {math.degrees(cube.rotation_euler.y):.1f}, {math.degrees(cube.rotation_euler.z):.1f})\")\n```\n</implementation>"}
{"id": 67, "instruction": "Place a cylinder (radius 0.6, height 2.4) at (1, -7, 1) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves precise 3D object placement with specific geometric parameters and orientation. A cylinder must be created with exact dimensions, positioned at a defined coordinate, and rotated 90° around the X-axis. This requires understanding Blender's coordinate system, default cylinder orientation (vertical along Z-axis), and rotation transformation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: radius = 0.6 m, height = 2.4 m\n- Default cylinder in Blender: centered at origin, axis along Z (height)\n- Target location: (x=1.0 m, y=-7.0 m, z=1.0 m)\n- Rotation: 90° about X-axis converts vertical cylinder (Z-axis) to horizontal along Y-axis\n- Post-rotation analysis: After 90° X rotation, cylinder axis aligns with Y-axis. Height dimension (2.4 m) now extends along Y. Center point remains at specified location.\n</spatial_layout>\n\n<kinematic_topology>\nStatic object hierarchy:\n- World origin\n  └── Cylinder (single mesh object, no parent)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder placed on ground plane at z=1 (center height). With radius 0.6, bottom at z=1 - (2.4/2) = -0.2 m, so partially below ground.\n- Risk: None beyond placement accuracy.\n- Verification: Rotation doesn't affect position due to order of operations (rotation then translation).\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.6\n- cylinder_height: 2.4\n- location: (1.0, -7.0, 1.0)\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.570796\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='DESELECT')\nbpy.ops.object.select_by_type(type='MESH')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.6,\n    depth=2.4,\n    location=(1.0, -7.0, 1.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply 90° rotation around X-axis (π/2 radians)\ncylinder.rotation_euler[0] = math.radians(90.0)\n\n# Update transformation\nbpy.context.view_layer.update()\n\n# Optional: Add ground plane for reference\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0,0,0))\nground = bpy.context.active_object\nground.name = \"Ground\"\n```\n</implementation>"}
{"id": 65, "instruction": "Place a 3x1x3 cube at (-6, -1, -3) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a simple static placement task requiring precise geometric transformation. The primary considerations are coordinate system orientation (Blender uses Z-up), dimension interpretation (3x1x3 likely corresponds to width×height×depth), and rotation order. No physical simulation or kinematics are needed - just correct mesh creation and transformation application.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 3m, Height (Z) = 1m, Depth (Y) = 3m (Blender uses Z-up)\n- Target location: (-6, -1, -3) in world coordinates\n- Rotation: 75° around Y-axis (Euler rotation in Blender: (0, 75°, 0) in degrees)\n- Default cube in Blender is 2×2×2 with origin at center, so scaling factors: (1.5, 1.5, 0.5)\n- Final transform: Translate to (-6, -1, -3), then rotate 75° around Y\n</spatial_layout>\n\n<kinematic_topology>\nNo kinematic chain needed - single static object.\n- world → cube (static mesh with transform)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. Static placement ensures no collisions or stability issues. The rotation is purely aesthetic/positional with no physical consequences.\n</predictive_simulation>\n\n<parameter_summary>\n- target_location: (-6.0, -1.0, -3.0)\n- target_rotation_y: 75.0\n- dimensions: (3.0, 3.0, 1.0)  # X, Y, Z in Blender (width, depth, height)\n- scale_factors: (1.5, 1.5, 0.5)  # From default 2m cube\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default 2m dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling for 3×1×3 dimensions (X=width, Y=depth, Z=height in Blender)\n# Default cube is 2×2×2, so scale by (3/2, 3/2, 1/2) = (1.5, 1.5, 0.5)\ncube.scale = (1.5, 1.5, 0.5)\n\n# Apply transforms to make scaling permanent\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (-6.0, -1.0, -3.0)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Verify dimensions\nprint(f\"Cube created at: {cube.location}\")\nprint(f\"Rotation: {math.degrees(cube.rotation_euler.y):.1f}° around Y\")\nprint(f\"Dimensions (after scaling): X=3.0, Y=3.0, Z=1.0\")\n```\n</implementation>"}
{"id": 70, "instruction": "Place a sphere with radius 2.4 at (-8, 0, 0) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a sphere at specified coordinates with a specific rotation. No physical simulation or complex mechanisms are required. The implementation involves basic mesh creation, transformation, and clear documentation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 2.4 units\n- Initial center position: (-8.0, 0.0, 0.0)\n- Rotation: 15° around the X-axis (requires conversion to radians: 15° × π/180 = 0.2618 rad)\n- Final transformation: translation then rotation applied to mesh.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world → sphere_mesh (no joints or constraints needed)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic risks; static object placement.\n- Rotation around local X-axis will tilt the sphere's poles relative to world axes.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.4\n- sphere_location: (-8.0, 0.0, 0.0)\n- rotation_x_degrees: 15.0\n- rotation_x_radians: 0.2618\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create UV sphere with 32 segments and rings for smooth appearance\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.4,\n    location=(-8.0, 0.0, 0.0),\n    segments=32,\n    ring_count=16\n)\nsphere = bpy.context.active_object\nsphere.name = \"Positioned_Sphere\"\n\n# Apply 15-degree rotation around X-axis (convert to radians)\nsphere.rotation_euler.x = math.radians(15.0)\n\n# Update viewport and set smooth shading\nbpy.context.view_layer.update()\nbpy.ops.object.shade_smooth()\n\n# Optional: Add a material for visual clarity\nmat = bpy.data.materials.new(name=\"Sphere_Material\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # RGBA\nsphere.data.materials.append(mat)\n\nprint(f\"Sphere created at {sphere.location} with radius 2.4, rotated {sphere.rotation_euler.x:.4f} rad around X.\")\n```\n</implementation>"}
{"id": 71, "instruction": "Place a cylinder (radius 1.7, height 3.3) at (2, 2, -6) and rotate it 25° on the Y-axis.", "answer": "<strategic_analysis>\nTask requires placing a static cylinder with precise geometric properties. The cylinder is positioned at a specific 3D coordinate with a rotation around the Y-axis. This is a simple transformation operation with no mechanical constraints or dynamics. Implementation involves creating the cylinder primitive, applying location, and setting rotation in Euler angles (converted from degrees).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.7 units\n- Cylinder height: 3.3 units\n- World location: (x=2.0, y=2.0, z=-6.0)\n- Y-axis rotation: 25° (converted to radians: 25 * π/180 ≈ 0.436332 radians)\n- Cylinder origin: By default, Blender cylinders are centered at (0,0,0) with height along Z-axis.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static mesh, no joints or hierarchy)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder is static, no dynamic risks.\n- Positioning: Rotation around Y-axis will tilt the cylinder laterally.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.7\n- cylinder_height: 3.3\n- location_x: 2.0\n- location_y: 2.0\n- location_z: -6.0\n- rotation_y_degrees: 25.0\n- rotation_y_radians: 0.436332\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.7,\n    depth=3.3,\n    location=(2.0, 2.0, -6.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply rotation (25° around Y-axis)\ncylinder.rotation_euler = (0.0, math.radians(25.0), 0.0)\n\n# Optional: Set object origin to base for clarity (height starts at z=-6)\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\ncylinder.location.z += 1.65  # Half height adjustment\n```\n</implementation>"}
{"id": 68, "instruction": "Place a 4x3x1 cube at (-4, 3, 4) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nWe are tasked with creating a static rectangular prism (commonly called a cube in the prompt) with specified dimensions, location, and rotation. This is a straightforward 3D modeling task requiring accurate placement and orientation. The cube will be a single rigid object with no kinematic linkages or dynamic simulation required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (Width, Depth, Height): 4.0m (X), 3.0m (Y), 1.0m (Z).\n- Location: World coordinates (-4.0, 3.0, 4.0).\n- Rotation: 35.0 degrees about the global Y-axis.\n- Note: Blender's default cube is 2m per side. To achieve 4x3x1, scale factors are calculated as (4/2, 3/2, 1/2) = (2.0, 1.5, 0.5).\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object: world -> cube (Rigid Body, but set as passive if physics is considered. No joints or constraints required).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cube is placed at a non-zero height (Z=4m). In a physics simulation, without a fixed base or sufficient mass, it could fall. However, the task does not specify a simulation. For static representation, we can ignore dynamics.\n- Risk: None for static placement. If physics were enabled, we would set the cube as a passive rigid body or anchor it.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 3.0, 1.0)\n- cube_location: (-4.0, 3.0, 4.0)\n- cube_rotation_y_degrees: 35.0\n- scale_factors: (2.0, 1.5, 0.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a cube primitive (default size 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve dimensions 4x3x1\ncube.scale = (2.0, 1.5, 0.5)\n\n# Apply scale to avoid distortion in transformations\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-4.0, 3.0, 4.0)\n# Convert degrees to radians\ncube.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Optional: Add rigid body if simulation is desired (passive by default)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set display to wireframe or solid, and set origin to geometry\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n\nprint(\"Cube created successfully.\")\n```\n</implementation>"}
{"id": 61, "instruction": "Place a 1x1x3 cube at (7, 2, 0) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a rectangular prism with specific dimensions, position it at given coordinates, and apply a 90-degree rotation around the X-axis. This involves basic 3D modeling operations in Blender without any physical simulation requirements.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width=1m (X), height=1m (Y), depth=3m (Z).\n- Original orientation: The default Blender cube is axis-aligned (edges parallel to X, Y, Z axes).\n- Rotation transformation: 90° rotation around X-axis will align the 3m dimension vertically (Y-axis) if originally along Z, or along Z if originally along Y. We'll verify the effect.\n- Location: The cube's origin will be positioned at world coordinates (7, 2, 0).\n- Note: Blender's default cube has vertices at ±0.5 on each axis, so a 1×1×3 cube requires scaling the default 2×2×2 cube by (0.5, 0.5, 1.5).\n</spatial_layout>\n\n<kinematic_topology>\nStatic object with no joints or hierarchy. Single mesh object \"Cube\" parented directly to world origin.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic behavior required. The cube will remain statically placed. No stability risks as it's not subject to gravity or forces.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (1.0, 1.0, 3.0)\n- location: (7.0, 2.0, 0.0)\n- rotation_degrees: (90.0, 0.0, 0.0)\n- scale_factor: (0.5, 0.5, 1.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TaskCube\"\n\n# Apply scale to achieve 1×1×3 dimensions\ncube.scale = (0.5, 0.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (7.0, 2.0, 0.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Optional: Add wireframe viewport display for clarity\ncube.display_type = 'WIRE'\ncube.show_wire = True\ncube.show_all_edges = True\n```\n</implementation>"}
{"id": 75, "instruction": "Place a cylinder (radius 1.1, height 2.2) at (7, -1, -2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a direct 3D modeling task with no complex mechanics. The objective is precise object placement and orientation in global 3D space. The cylinder must be created with exact dimensions, positioned at the specified coordinates, and rotated around the Z-axis by 45 degrees.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.1 units\n- Cylinder height: 2.2 units\n- World location: (X=7.0, Y=-1.0, Z=-2.0)\n- Rotation: 45° about the global Z-axis. In radians: θ = 45° × (π/180) = 0.785398 rad.\n- Default cylinder origin is at its center. With Z location = -2.0, the cylinder extends from Z = -3.1 to Z = -0.9.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object: cylinder_001. No joints or hierarchy required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The cylinder is a static object placed in the scene.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.1\n- cylinder_height: 2.2\n- location_xyz: (7.0, -1.0, -2.0)\n- rotation_z_degrees: 45.0\n- rotation_z_radians: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.1,\n    depth=2.2,\n    location=(7.0, -1.0, -2.0),\n    rotation=(0, 0, math.radians(45.0))\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"cylinder_001\"\n```\n</implementation>"}
{"id": 74, "instruction": "Place a sphere with radius 0.9 at (-3, 1, 7) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a single sphere object in 3D space. This is a fundamental modeling operation that tests understanding of coordinate systems, rotation conventions, and Blender's object transformation properties. The sphere will be created with the specified radius, then transformed.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center location in world coordinates: (x, y, z) = (-3.0, 1.0, 7.0)\n- Sphere radius: r = 0.9 units\n- Rotation: 60° about the global Y-axis (counter-clockwise when looking down the positive Y-axis toward origin)\n- Rotation conversion to radians: θ = 60° × (π/180) ≈ 1.0472 rad\n- Resulting object transformations:\n    - Translation: (-3, 1, 7)\n    - Rotation: (0, 1.0472, 0) in Euler angles (XYZ convention)\n- Bounding box dimensions: diameter = 1.8 units in all axes\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body hierarchy:\n- world (global coordinate system)\n  └── sphere_object (mesh with transform: location + rotation)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Collision risk: None (single object)\n- Visual verification: Sphere will appear rotated such that any surface texture or asymmetry will show 60° Y-axis rotation\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 0.9\nsphere_location: (-3.0, 1.0, 7.0)\ny_rotation_degrees: 60.0\ny_rotation_radians: 1.0471975512\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius at origin\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.9, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply transformations\nsphere.location = (-3.0, 1.0, 7.0)\nsphere.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Update scene\nbpy.context.view_layer.update()\n\nprint(f\"Created sphere '{sphere.name}'\")\nprint(f\"  Radius: {sphere.dimensions.x/2}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation (degrees): {tuple(math.degrees(r) for r in sphere.rotation_euler)}\")\n```\n</implementation>"}
{"id": 73, "instruction": "Place a 2x3x3 cube at (4, -4, 4) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nWe need to create a single cube with non-uniform dimensions (2x3x3) at a specific world coordinate (4, -4, 4) and apply a 30-degree rotation around the X-axis. This is a basic object transformation task requiring precise scaling, translation, and rotation. Since Blender's default cube is 2x2x2, we must scale it appropriately.\n</strategic_layout>\n\n<kinematic_topology>\nThis is a static single object with no hierarchy or joints.\n- world → cube_object (Mesh with transform)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic risks since this is a static mesh placement. However, note that rotations in Blender use radians, and the object's origin will be at its geometric center after scaling.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 3.0, 3.0)  # width (x), depth (y), height (z)\n- target_location: (4.0, -4.0, 4.0)\n- target_rotation_x_deg: 30.0\n- target_rotation_x_rad: 0.523599  # 30° in radians\n- default_cube_size: 2.0  # Blender's default cube edge length\n- scale_factors: (1.0, 1.5, 1.5)  # (2/2, 3/2, 3/2)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply non-uniform scaling for 2x3x3 dimensions\n# Default cube is 2x2x2, so scale factors: (2/2, 3/2, 3/2) = (1, 1.5, 1.5)\ncube.scale = (1.0, 1.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (4.0, -4.0, 4.0)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Verify transformations\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation (degrees): {[math.degrees(angle) for angle in cube.rotation_euler]}\")\n```\n</implementation>"}
{"id": 76, "instruction": "Place a 3x4x1 cube at (0, -8, 1) and rotate it 20° on the X-axis.", "answer": "<strategic_analysis>\nThis task involves creating a simple static object - a rectangular prism with given dimensions, position, and rotation. The 20° X-axis rotation suggests an inclined plane or sloped surface oriented along the Y-axis direction (since location is at y=-8). This could serve as a ramp, obstacle, or foundation element in a larger mechanical assembly.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 3m, depth (Y) = 4m, height (Z) = 1m\n- World position: (X=0.0, Y=-8.0, Z=1.0)\n- Rotation: 20° around X-axis (pitch rotation)\n- Note: Blender uses radians internally. 20° = 20 × π/180 ≈ 0.349066 radians\n- The Z=1.0 position plus 20° rotation means the cube's local origin will be at world Z=1.0, with the cube tilted forward\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object with no parent-child hierarchy\n- No joints or constraints required\n- Object exists independently in world space\n</kinematic_topology>\n\n<predictive_simulation>\n- Static object with no dynamic behavior\n- Rotation creates inclined surface with slope angle of 20°\n- If used as ramp, objects would slide along local Y-direction with acceleration component of g×sin(20°) ≈ 3.35 m/s²\n- No stability concerns for fixed object\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 4.0, 1.0)\n- cube_location: (0.0, -8.0, 1.0)\n- cube_rotation_x_degrees: 20.0\n- cube_rotation_x_radians: 0.349066\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Vector, Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"TiltedCube\"\n\n# Set dimensions: Blender scales from unit cube\ncube.scale = (3.0, 4.0, 1.0)\n\n# Set location\ncube.location = Vector((0.0, -8.0, 1.0))\n\n# Set rotation: 20 degrees around X-axis\n# Convert degrees to radians\nrotation_rad = math.radians(20.0)\ncube.rotation_euler = Euler((rotation_rad, 0.0, 0.0), 'XYZ')\n\n# Apply transformations to make values explicit in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Optional: Add passive rigid body for physics simulations\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\nprint(f\"Created cube '{cube.name}'\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {math.degrees(cube.rotation_euler.x):.1f}° around X-axis\")\n```\n</implementation>"}
{"id": 69, "instruction": "Place a 1x2x4 cube at (6, 1, -3) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cube with given dimensions, position, and orientation. No physical simulation or dynamic constraints are required. The task is purely geometric and can be accomplished by directly creating and transforming the cube in Blender's 3D space.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 1.0m (X) × 2.0m (Y) × 4.0m (Z).\n- Cube location: (6.0, 1.0, -3.0).\n- Cube rotation: 45° around the Z-axis, which is 0.785398 radians.\n- The cube's center is placed at the specified location. The rotation is applied about the cube's local Z-axis passing through its center.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single static mesh object with no parent or hierarchy)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic risks or stability concerns as the cube is static and not subject to physics.\n- The cube's placement and rotation are exact and do not interact with other objects.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 4.0)\n- cube_location: (6.0, 1.0, -3.0)\n- cube_rotation_z_deg: 45.0\n- cube_rotation_z_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Add a cube at the origin with default size (2m)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TaskCube\"\n\n# Set dimensions to 1x2x4 meters\ncube.dimensions = (1.0, 2.0, 4.0)\n\n# Set location and rotation\ncube.location = (6.0, 1.0, -3.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Update mesh to apply transformations (optional, but ensures dimensions are correct)\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 77, "instruction": "Place a 1x3x5 cube at (-7, 2, 2) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static rectangular prism with specific dimensions, location, and orientation. Since this is a purely geometric modeling task without moving parts or physical simulation requirements, the approach focuses on precise object creation, scaling to achieve non-uniform dimensions, and applying the correct translation and rotation transformations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (Width × Depth × Height): 1 × 3 × 5 units.\n- Target location (X, Y, Z): (-7, 2, 2).\n- Rotation: 35 degrees around the global Y-axis (Euler rotation).\n- Since Blender's default cube is 2×2×2, scaling factors are: (1/2, 3/2, 5/2) = (0.5, 1.5, 2.5).\n- No complex spatial reasoning required beyond direct application of transformations.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world → custom_cube (Static Mesh)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The object is static and will remain at rest. No stability risks.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (1.0, 3.0, 5.0)\n- location: (-7.0, 2.0, 2.0)\n- rotation_y_degrees: 35.0\n- scale_factors: (0.5, 1.5, 2.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"custom_cube\"\n\n# Apply scaling to achieve 1x3x5 dimensions\ncube.scale = (0.5, 1.5, 2.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-7.0, 2.0, 2.0)\ncube.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Optionally, set display to wireframe to see dimensions clearly\ncube.display_type = 'WIRE'\n```\n</implementation>"}
{"id": 78, "instruction": "Place a sphere with radius 1.6 at (2, 4, 6) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is a straightforward 3D modeling operation: create a sphere with specified dimensions, position it in world space, and apply a rotation transformation. No complex physics or kinematics are required. The main consideration is understanding Blender's coordinate system and rotation conventions.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 1.6 units\n- World coordinates: X=2, Y=4, Z=6\n- Rotation: 90° around global Z-axis (positive counter-clockwise when looking down -Z)\n- Mathematical conversion: 90° = π/2 ≈ 1.5708 radians\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object (sphere) with no hierarchy or joints\n- Transformation applied directly to mesh object\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic behavior required\n- Static placement ensures stability\n- Rotation is purely visual with no physical consequences\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.6\n- location_x: 2.0\n- location_y: 4.0\n- location_z: 6.0\n- rotation_z_degrees: 90.0\n- rotation_z_radians: 1.5708\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with radius 1.6\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.6, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"TargetSphere\"\n\n# Set location and rotation\nsphere.location = (2.0, 4.0, 6.0)\nsphere.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Verify transformation\nprint(f\"Sphere created: {sphere.name}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation (radians): {sphere.rotation_euler}\")\nprint(f\"Rotation (degrees): ({math.degrees(sphere.rotation_euler.x)}, \"\n      f\"{math.degrees(sphere.rotation_euler.y)}, \"\n      f\"{math.degrees(sphere.rotation_euler.z)})\")\n```\n</implementation>"}
{"id": 79, "instruction": "Place a cylinder (radius 2.2, height 1.8) at (-5, -3, 1) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylinder with specific dimensions, placement, and orientation. This involves precise geometric creation followed by transformation operations. No physics simulation is required, just accurate 3D modeling.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 2.2 units\n- Cylinder height: 1.8 units\n- Location coordinates: (-5, -3, 1) in (X, Y, Z) space\n- Rotation: 15° about the X-axis. Note: Blender uses radians internally, requiring conversion: 15° × (π/180) = 0.2618 radians\n- The cylinder's base will be at Z=1 (since default cylinder origin is at its center). The actual bottom will be at Z = 1 - (height/2) = 1 - 0.9 = 0.1\n- No scaling transformations needed.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world → cylinder (static mesh)\n- No joints or constraints required for this static placement.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Dynamic risks: None\n- Collision considerations: None specified\n- The cylinder will remain fixed at the specified location and orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.2\n- cylinder_height: 1.8\n- location_x: -5.0\n- location_y: -3.0\n- location_z: 1.0\n- rotation_x_degrees: 15.0\n- rotation_x_radians: 0.2618\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene for clean execution\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,        # Default resolution for smooth appearance\n    radius=2.2,\n    depth=1.8,\n    location=(-5.0, -3.0, 1.0)\n)\n\n# Get reference to the created cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"Positioned_Cylinder\"\n\n# Apply 15° rotation around X-axis (convert to radians)\ncylinder.rotation_euler.x = math.radians(15.0)\n\n# Update object transformation\nbpy.context.view_layer.update()\n\n# Optional: Add a material for visual clarity\nmaterial = bpy.data.materials.new(name=\"Cylinder_Material\")\nmaterial.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blue color\ncylinder.data.materials.append(material)\n\nprint(f\"Cylinder created at {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.x):.1f}° on X-axis\")\n```\n</implementation>"}
{"id": 80, "instruction": "Place a 4x2x2 cube at (1, 6, -1) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rectangular prism with specific dimensions, position, and orientation. This is a straightforward 3D modeling operation involving translation and rotation transformations. The primary consideration is ensuring the rotation is applied correctly around the object's local Y-axis after positioning.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: (width=4, height=2, depth=2) along X, Y, Z axes respectively.\n- Target location: (x=1, y=6, z=-1).\n- Rotation: 75° around the Y-axis. Converting to radians: 75 * π/180 ≈ 1.308997 rad.\n- Default Blender cube (2x2x2) requires scaling by (2,1,1) to achieve 4x2x2 dimensions.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world → custom_cube (Static Mesh)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. Object will remain statically placed at specified coordinates with fixed orientation. No collision or stability risks.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (4.0, 2.0, 2.0)\n- location: (1.0, 6.0, -1.0)\n- rotation_y_degrees: 75.0\n- scale_factors: (2.0, 1.0, 1.0)\n- default_cube_size: 2.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='DESELECT')\nfor obj in bpy.data.objects:\n    if obj.type == 'MESH':\n        obj.select_set(True)\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"custom_cube\"\n\n# Apply scaling to achieve 4x2x2 dimensions\ncube.scale = (2.0, 1.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (1.0, 6.0, -1.0)\ncube.rotation_euler = (0, math.radians(75.0), 0)\n\n# Optional: Set visual properties\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)\ncube.data.materials.append(mat)\n\nprint(f\"Created cube '{cube.name}' at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 82, "instruction": "Place a sphere with radius 3.2 at (9, 0, 1) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a sphere with specified radius, position, and orientation. No dynamic simulation or complex assembly is required. We must ensure the sphere's dimensions and transformation match the given parameters exactly.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 3.2 units\n- Center coordinates: (x=9.0, y=0.0, z=1.0)\n- Rotation: 30° around X-axis (converted to radians: 30 * π/180 ≈ 0.5236 rad)\n- The sphere's local origin remains at its geometric center after rotation.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object with no hierarchy or joints:\n- world -> sphere (Mesh object with transform)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic behavior required. The sphere will remain fixed at its location and orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 3.2\n- location: (9.0, 0.0, 1.0)\n- rotation_x_degrees: 30.0\n- rotation_x_radians: 0.5235987755982988\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=3.2)\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Set location\nsphere.location = (9.0, 0.0, 1.0)\n\n# Apply rotation (30° around X-axis)\nsphere.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Optional: Set smooth shading for better visualization\nbpy.ops.object.shade_smooth()\n\nprint(f\"Created sphere '{sphere.name}'\")\nprint(f\"  Radius: {sphere.dimensions.x/2:.1f}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {[math.degrees(r) for r in sphere.rotation_euler]}\")\n```\n</implementation>"}
{"id": 86, "instruction": "Place a sphere with radius 0.7 at (-6, 4, 3) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a static placement task requiring no mechanical dynamics or constraints. The objective is to position a sphere with specific geometric properties (radius 0.7) at exact coordinates (-6, 4, 3) and apply a 15° rotation about the Y-axis. Since the sphere is a passive object, we can directly create it with the required transform in Blender.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (x, y, z) = (-6.0, 4.0, 3.0)\n- Sphere radius: 0.7\n- Rotation: 15° about Y-axis, which in radians is θ = 15 * π / 180 ≈ 0.2618 rad\n- Bounding box: The sphere will occupy [-6.7, -5.3] in X, [3.3, 4.7] in Y, [2.3, 3.7] in Z when unrotated. Rotation about Y-axis doesn't change these bounds.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Static Mesh, no joints or constraints required)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation needed. The sphere is static and will remain at its placed location and orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.7\n- sphere_location: (-6.0, 4.0, 3.0)\n- sphere_rotation_y_deg: 15.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing mesh objects (optional, to start fresh)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with radius 0.7\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.7, location=(-6.0, 4.0, 3.0))\nsphere = bpy.context.active_object\nsphere.name = \"Sphere\"\n\n# Apply 15-degree rotation around Y-axis\nsphere.rotation_euler = (0, radians(15.0), 0)\n\n# (Optional) Set smooth shading for better appearance\nbpy.ops.object.shade_smooth()\n```\n</implementation>"}
{"id": 87, "instruction": "Place a cylinder (radius 0.9, height 3.6) at (3, 0, -8) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a simple static object placement task. The primary considerations are correctly interpreting the provided parameters (radius, height, location, rotation) and applying them in Blender's coordinate system. No dynamic simulation or complex assembly is required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius (r): 0.9 units.\n- Cylinder height (h): 3.6 units.\n- Cylinder center location: (X, Y, Z) = (3.0, 0.0, -8.0).\n- Cylinder rotation: 45° (0.785398 radians) around the global Z-axis.\n- Blender's default cylinder is created centered at the origin with its local Z-axis as the central axis. The provided height is along the local Z-axis.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh, no hierarchy or joints required).\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation is requested. The cylinder is a passive, static object in the scene.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.9\n- cylinder_height: 3.6\n- cylinder_location: (3.0, 0.0, -8.0)\n- cylinder_rotation_z_deg: 45.0\n- cylinder_rotation_z_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, for a clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create the cylinder with specified radius\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.9,\n    depth=3.6,\n    location=(3.0, 0.0, -8.0)\n)\n\n# Get the reference to the newly created cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Apply the 45-degree rotation around the Z-axis\ncylinder.rotation_euler = (0, 0, math.radians(45.0))\n\n# Optional: Set the object as a passive rigid body for future physics simulation\n# bpy.ops.rigidbody.object_add()\n# cylinder.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 83, "instruction": "Place a cylinder (radius 1.4, height 4.1) at (0, 1, 9) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical object with specified dimensions at a precise location and orientation. This involves straightforward 3D modeling with no mechanical interactions or dynamic simulations required. The primary consideration is accurate geometric placement using Blender's coordinate system (Y-up by default). The rotation should be applied in Euler angles, converting from degrees to radians.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: radius = 1.4 units, height = 4.1 units.\n- World location: (x=0.0, y=1.0, z=9.0).\n- Rotation: 60° around the global Y-axis. In Blender's default coordinate system (Z-up), this would be rotation around the Z-axis, but the problem statement uses Y-axis rotation, implying a Y-up system. Assuming Y-up: rotation_euler = (0.0, 60.0° in radians, 0.0).\n- Radians conversion: 60° × (π/180) ≈ 1.0471975511965976 rad.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static mesh, no hierarchy or joints).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cylinder is static and securely placed at the given coordinates. No dynamic risks exist.\n- Collision: Placement does not intersect with default scene objects (e.g., origin, camera, light).\n- Verification: The cylinder's base will be centered at its location with half the height extending in both local Z directions (if aligned to global axes before rotation).\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.4\n- cylinder_height: 4.1\n- location_x: 0.0\n- location_y: 1.0\n- location_z: 9.0\n- rotation_y_degrees: 60.0\n- rotation_y_radians: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects (optional clean start)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.4,\n    depth=4.1,\n    location=(0.0, 1.0, 9.0),\n    rotation=(0.0, math.radians(60.0), 0.0)\n)\n\n# Rename the cylinder object\ncylinder = bpy.context.active_object\ncylinder.name = \"Target_Cylinder\"\n\n# Optional: Set smooth shading for better visual appearance\nbpy.ops.object.shade_smooth()\n\n# Optional: Add a material for visual distinction\nmat = bpy.data.materials.new(name=\"Cylinder_Material\")\nmat.use_nodes = True\ncylinder.data.materials.append(mat)\n```\n</implementation>"}
{"id": 81, "instruction": "Place a 2x1x5 cube at (-2, -6, -2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a rectangular prism with specific dimensions, position, and orientation. No mechanical or dynamic reasoning required. I'll create a 2×1×5 unit cube (X×Y×Z dimensions) at world coordinates (-2, -6, -2) with 45° rotation around the global Z-axis. This involves basic mesh creation, scaling for non-uniform dimensions, translation, and rotation transformation.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions (width×depth×height): X=2.0m, Y=1.0m, Z=5.0m.\n- World position: (X=-2.0, Y=-6.0, Z=-2.0).\n- Rotation: 45° (π/4 radians) around global Z-axis.\n- Default Blender cube is 2×2×2 units centered at origin.\n- Scaling factors: (2.0/2.0=1.0, 1.0/2.0=0.5, 5.0/2.0=2.5).\n- Final transformation order: Scale → Rotate → Translate.\n</spatial_layout>\n\n<kinematic_topology>\nStatic mesh only. No joints or constraints required.\n- world → cube_object (static mesh)\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamics involved. Pure static placement. Verification: after transformation, the cube's bounding box should be centered at (-2,-6,-2) with Z-axis rotation.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (2.0, 1.0, 5.0)\n- location: (-2.0, -6.0, -2.0)\n- rotation_z_deg: 45.0\n- scale_factors: (1.0, 0.5, 2.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Target_Cube\"\n\n# Apply scaling for 2×1×5 dimensions\ncube.scale = (1.0, 0.5, 2.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-2.0, -6.0, -2.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\nbpy.ops.object.transform_apply(rotation=True)\n\n# Verify dimensions\nprint(f\"Created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (Z): {math.degrees(cube.rotation_euler.z):.1f}°\")\n```\n</implementation>"}
{"id": 90, "instruction": "Place a sphere with radius 2.1 at (0, -9, 0) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a sphere with specific geometric properties and spatial transformation. This involves creating a 3D mesh primitive, setting its radius, positioning it in world coordinates, and applying a rotation transformation around the Z-axis.\n</strategic_layout>\n\n<spatial_layout>\n- Sphere radius: 2.1 units (diameter = 4.2)\n- World location coordinates: (x=0, y=-9, z=0)\n- Rotation: 90° around the Z-axis. Mathematical conversion: radians = degrees × (π/180). Therefore, 90° = π/2 ≈ 1.5708 radians.\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object: sphere_mesh (no parent-child hierarchy or joints required).\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation needed for this static placement task.\n- The sphere's mass properties don't affect the outcome since no physics are simulated.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.1\n- sphere_location: (0.0, -9.0, 0.0)\n- sphere_rotation_z: 90.0 (degrees)\n- sphere_rotation_z_radians: 1.5708\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects for clean execution\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.1, location=(0, -9, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Sphere\"\n\n# Apply 90° rotation around Z-axis\nsphere.rotation_euler = (0, 0, math.radians(90))\n\n# Verify transformations\nprint(f\"Sphere created: {sphere.name}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation (degrees): {tuple(math.degrees(r) for r in sphere.rotation_euler)}\")\n```\n</implementation>"}
{"id": 84, "instruction": "Place a 1x4x3 cube at (-1, 7, -3) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a rectangular prism (referred to as a cube in the task) with specified dimensions, place it at a given location, and apply a rotation. This is a simple static modeling task with no dynamics or complex kinematics. The primary consideration is ensuring the correct order of transformations (scale, then rotate, then translate) to achieve the desired result. Since the default Blender cube has dimensions 2x2x2, scaling is required before applying the rotation and translation to avoid distortion.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (X, Y, Z): 1, 4, 3.\n- Location: (-1, 7, -3) in world coordinates.\n- Rotation: 20° around the global Z-axis.\n- Scaling Factors: (0.5, 2, 1.5) derived from (desired/2) for each axis.\n- The cube is centered at its origin, so after scaling, the geometric center remains at (0,0,0) before translation.\n</spatial_layout>\n\n<kinematic_topology>\n- Single static object: \"Cube\" with no parent or children.\n- No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation is involved; the object is static.\n- Risk of misplacement if transformation order is incorrect (e.g., rotating before scaling may cause unintended orientation of scaled axes).\n- Mitigation: Apply scaling first, then rotation, then translation.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (1.0, 4.0, 3.0)\n- location: (-1.0, 7.0, -3.0)\n- rotation_z_degrees: 20.0\n- rotation_z_radians: 0.3490658503988659\n- scale_factors: (0.5, 2.0, 1.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects in the scene (optional, for clean start)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add a default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Cube\"\n\n# Scale to desired dimensions (1, 4, 3)\ncube.scale = (0.5, 2.0, 1.5)\n\n# Apply rotation: 20 degrees around Z-axis (convert to radians)\nrotation_rad = math.radians(20.0)\ncube.rotation_euler = (0, 0, rotation_rad)\n\n# Set location\ncube.location = (-1.0, 7.0, -3.0)\n\n# Update the mesh to apply transformations (optional, for clarity)\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n```\n</implementation>"}
{"id": 88, "instruction": "Place a 2x5x2 cube at (-4, -2, 5) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis task involves creating a static rectangular prism (cube with non-uniform scaling) at a specified location with a rotation around the X-axis. The primary challenge is accurately setting the object's transform (location and rotation) in Blender's 3D space. No physics simulation or complex kinematics are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Dimensions: Width (X) = 2m, Height (Y) = 5m, Depth (Z) = 2m.\n- Location: (x, y, z) = (-4.0, -2.0, 5.0) in world coordinates.\n- Rotation: 30 degrees around the global X-axis. In radians, this is 30 * (π/180) ≈ 0.5236 rad.\n- Note: The rotation is applied after placement (Euler rotation order XYZ by default).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh with no parent). The cube is a single rigid body (if physics were enabled, it would be passive).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cube is placed at a height of 5m. If physics were active, it would fall without support. However, the task only specifies placement and rotation, so we assume a static scene.\n- Risk: None, as it is a simple static object.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 5.0, 2.0)\n- cube_location: (-4.0, -2.0, 5.0)\n- cube_rotation_x_degrees: 30.0\n- cube_rotation_x_radians: 0.5235987755982988\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a cube (default 2x2x2, but we will scale)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TaskCube\"\n\n# Scale to achieve 2x5x2 dimensions (since default size=1 gives a 2x2x2 cube, we adjust)\n# The default cube with size=1 has vertices from -1 to 1, so total dimension is 2.\n# To get width=2, height=5, depth=2, we set scale accordingly.\n# Scale X = desired_width / default_width = 2 / 2 = 1.0\n# Scale Y = desired_height / default_height = 5 / 2 = 2.5\n# Scale Z = desired_depth / default_depth = 2 / 2 = 1.0\ncube.scale = (1.0, 2.5, 1.0)\n\n# Set location\ncube.location = (-4.0, -2.0, 5.0)\n\n# Set rotation (30 degrees around X-axis)\ncube.rotation_euler[0] = math.radians(30.0)  # 30 degrees in radians\n\n# Optionally, we can set the object to be a passive rigid body if physics is needed.\n# For this static placement, we leave it without physics.\n# If physics were required, we would add:\n# bpy.ops.rigidbody.object_add()\n# cube.rigid_body.type = 'PASSIVE'\n\n# Update the scene\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 72, "instruction": "Place a 5x1x2 cube at (-1, 5, 3) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nWe need to create a rectangular prism (cube is a misnomer since dimensions aren't equal) with specified dimensions, position it at world coordinates, and apply a rotation. This is a basic 3D modeling operation without dynamic simulation requirements. The rotation will be applied around the object's local Z-axis after placement.\n</strategic_analysis>\n\n<spatial_layout>\n- Dimensions: 5 units (X), 1 unit (Y), 2 units (Z).\n- World Location: (-1, 5, 3) in (X, Y, Z) coordinates.\n- Rotation: 90° about the Z-axis. In radians: 90° * (π/180°) = π/2 ≈ 1.5708 rad.\n- Origin: Default cube center will be at the specified location after transformation.\n- Local vs. World: Rotation is applied in object's local space after translation.\n</spatial_layout>\n\n<kinematic_topology>\nStatic mesh with no joints or hierarchy. Single object transformation.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. Object is static. No collision or stability risks.\n</predictive_simulation>\n\n<parameter_summary>\ndimensions_x: 5.0\ndimensions_y: 1.0\ndimensions_z: 2.0\nlocation_x: -1.0\nlocation_y: 5.0\nlocation_z: 3.0\nrotation_z_deg: 90.0\nrotation_z_rad: 1.57079632679\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, enter_editmode=False, align='WORLD')\n\ncube = bpy.context.active_object\ncube.name = \"RectangularPrism\"\n\n# Apply scaling to achieve 5x1x2 dimensions\ncube.scale.x = 5.0 / 2.0  # Original cube is 2 units wide\ncube.scale.y = 1.0 / 2.0\ncube.scale.z = 2.0 / 2.0\n\n# Apply scale transformation to make scaling permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location.x = -1.0\ncube.location.y = 5.0\ncube.location.z = 3.0\n\n# Apply 90° rotation around Z-axis\ncube.rotation_euler.z = math.radians(90.0)\n\n# Update scene\nbpy.context.view_layer.update()\n\nprint(f\"Created {cube.name} at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 89, "instruction": "Place a 1x2x6 cube at (6, 3, -2) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a rectangular prism in 3D space. This is a fundamental modeling operation where we must ensure the object's dimensions, location, and rotation match the specification exactly. The 60° rotation around the Y-axis will transform the cube's local coordinate system, affecting how the dimensions (1, 2, 6 along X, Y, Z respectively) are oriented in world space.\n</strategic_analysis>\n\n<spatial_layout>\n- Original cube dimensions (X×Y×Z): 1 × 2 × 6 units.\n- Target location (world coordinates): (6, 3, -2).\n- Rotation: 60° around the global Y-axis. In Blender, Y-axis rotation is applied in radians: 60° × (π/180) ≈ 1.0472 radians.\n- Since Blender's default cube is 2×2×2, we calculate scale factors:\n  Scale X = 1/2 = 0.5\n  Scale Y = 2/2 = 1.0\n  Scale Z = 6/2 = 3.0\n- The transformed cube will have its center at (6, 3, -2) with local axes rotated.\n</spatial_layout>\n\n<kinematic_topology>\nStatic single object hierarchy:\n- world → cube (rigid mesh, no parent)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The object is static. Verification:\n- The cube's bounding box after transformation should have center at (6, 3, -2).\n- The longest dimension (6 units along local Z) will be oriented according to the rotation.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (1.0, 2.0, 6.0)\n- location: (6.0, 3.0, -2.0)\n- rotation_y_degrees: 60.0\n- rotation_y_radians: 1.0471975511965976\n- scale_factors: (0.5, 1.0, 3.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply dimensions via scale (based on default 2×2×2)\ncube.scale = (0.5, 1.0, 3.0)  # Results in 1×2×6\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (6.0, 3.0, -2.0)\ncube.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Optional: Add visual materials for clarity\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.1, 0.6, 0.9, 1.0)  # Blue color\ncube.data.materials.append(mat)\n\n# Add coordinate axes at origin for reference\nbpy.ops.object.empty_add(type='ARROWS', location=(0, 0, 0))\naxis = bpy.context.active_object\naxis.name = \"WorldOrigin\"\naxis.empty_display_size = 2.0\n```\n</implementation>"}
{"id": 91, "instruction": "Place a cylinder (radius 1.6, height 2.9) at (-3, 5, -4) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires placing a static cylindrical object at a precise location with a specific orientation. No complex kinematics or dynamics are needed. The primary consideration is correct coordinate system handling in Blender (right-handed, Z-up). The cylinder must be created with exact dimensions and transformed using the given translation and rotation values.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder origin (local coordinate center) will be at world coordinates (-3, 5, -4).\n- Rotation: 15° around global X-axis. In radians: θ = 15° × (π/180) ≈ 0.261799 rad.\n- Dimensions: radius = 1.6 m, height = 2.9 m.\n- The cylinder's local Z-axis aligns with its height. A positive X-rotation will tilt the top toward negative Y (forward in Blender's default view).\n</spatial_layout>\n\n<kinematic_topology>\nStatic mesh only. No joints or hierarchy needed.\n</kinematic_topology>\n\n<predictive_simulation>\nStatic object; no motion or stability risks. Ensure the cylinder doesn't intersect with existing scene geometry (scene is cleared).\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.6\n- cylinder_height: 2.9\n- location: (-3.0, 5.0, -4.0)\n- rotation_x_degrees: 15.0\n- rotation_x_radians: 0.261799\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.6,\n    depth=2.9,\n    location=(-3.0, 5.0, -4.0),\n    rotation=(0.261799, 0.0, 0.0)  # 15° in radians around X\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Verify transformations\nprint(f\"Cylinder created: {cylinder.name}\")\nprint(f\"Location: {cylinder.location}\")\nprint(f\"Rotation (rad): {cylinder.rotation_euler}\")\nprint(f\"Dimensions: Radius=1.6, Height=2.9\")\n```\n</implementation>"}
{"id": 94, "instruction": "Place a sphere with radius 1.4 at (2, -2, 8) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a spherical primitive. This is a foundational 3D modeling operation requiring accurate coordinate transformation (translation then rotation). The sphere's radius is significant (1.4 units), and its final location in 3D space (X=2, Y=-2, Z=8) and rotation (60° about the X-axis) must be explicitly set. The implementation must ensure the sphere is created with the correct dimensions and undergoes the specified transformations in the correct order.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (R): 1.4 units.\n- Sphere Center Location: (X, Y, Z) = (2.0, -2.0, 8.0).\n- Rotation: 60° (π/3 radians) about the global X-axis.\n- Transformation Order: First, create the sphere with the specified radius at the origin. Then, translate its center to the target location. Finally, apply the rotation about the X-axis. In Blender, applying rotation after translation is standard for object-level transforms.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single static mesh object with no parent, no rigid body physics required by the task).\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None. This is a static placement task. The sphere will not move or interact with other objects unless additional physics are added later.\n- Mitigation: Ensure the object is created with a clear name and at the correct scale to avoid confusion in subsequent operations.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.4\n- sphere_location: (2.0, -2.0, 8.0)\n- sphere_rotation_x_degrees: 60.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects for a clean start\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create the UV sphere primitive with the specified radius\n# The primitive is created at the world origin (0,0,0) by default\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.4, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply translation: move sphere to specified location\nsphere.location = (2.0, -2.0, 8.0)\n\n# Apply rotation: 60 degrees about the X-axis (convert to radians)\nsphere.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Optional: Update the viewport to show the changes\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 92, "instruction": "Place a 3x2x5 cube at (4, 2, 7) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nCreate a static rectangular prism with specified dimensions, position it at the given coordinates, and apply a 45-degree rotation around the Y-axis. This is a straightforward modeling task without dynamics or complex kinematics.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 3 units (X) × 2 units (Z) × 5 units (Y) in object space\n- World location: (4, 2, 7) - this positions the object's origin/center point\n- Rotation: 45° around global Y-axis (π/4 radians)\n- No scaling transformations needed since dimensions are set directly\n- The rotation is applied after positioning, maintaining the object's pivot at its geometric center\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (Static Mesh with no parent)\n- No joints or constraints needed for this static object\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic simulation required for this static placement\n- The cube will maintain its position and orientation without stability concerns\n- Rotation around Y-axis doesn't affect center of mass positioning\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 5.0, 2.0)  # X, Y, Z in Blender convention\n- cube_location: (4.0, 2.0, 7.0)\n- cube_rotation_y_degrees: 45.0\n- cube_rotation_y_radians: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with correct dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)  # Start with unit cube\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Set dimensions: 3(X) × 2(Z) × 5(Y) in Blender axes\n# Blender uses X(width), Y(depth), Z(height)\ncube.dimensions = (3.0, 5.0, 2.0)\n\n# Set location\ncube.location = (4.0, 2.0, 7.0)\n\n# Apply 45° rotation around Y-axis\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Apply transformations to make them permanent in object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Verify final properties\nprint(f\"Cube created:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 95, "instruction": "Place a cylinder (radius 2.5, height 1.5) at (5, 5, -5) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static cylinder with precise geometric properties and spatial transformation. This is a foundational 3D modeling operation with no dynamic components. The primary considerations are correct parameter application and coordinate system awareness in Blender.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 2.5 units\n- Cylinder height: 1.5 units  \n- World location: X=5.0, Y=5.0, Z=-5.0\n- Rotation: 90° around Y-axis (π/2 radians = 1.5708 rad)\n- Origin: Default cylinder origin at center of geometry (midpoint along height axis)\n- Local axes: After 90° Y-rotation, the cylinder's local Z-axis (height direction) aligns with world X-direction\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world -> cylinder (no parent, no constraints)\nNo joints or dynamic relationships required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Collision risk: None specified\n- Coordinate verification: Negative Z-position (-5) places cylinder below default view; camera adjustment may be needed for visibility\n- Rotation effect: 90° Y-rotation makes cylinder lay horizontally along X-axis instead of vertical\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.5\n- cylinder_height: 1.5  \n- location_x: 5.0\n- location_y: 5.0\n- location_z: -5.0\n- rotation_y_degrees: 90.0\n- rotation_y_radians: 1.5708\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, but good practice for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,  # Default resolution\n    radius=2.5,\n    depth=1.5,    # Blender uses 'depth' for cylinder height\n    location=(5.0, 5.0, -5.0),\n    rotation=(0.0, math.radians(90.0), 0.0)  # Convert 90° to radians for Y-rotation\n)\n\n# Get reference to the created cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Optional: Add material for better visibility\nmaterial = bpy.data.materials.new(name=\"CylinderMaterial\")\nmaterial.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\ncylinder.data.materials.append(material)\n\n# Optional: Adjust 3D view to see the cylinder at negative Z\nfor area in bpy.context.screen.areas:\n    if area.type == 'VIEW_3D':\n        for space in area.spaces:\n            if space.type == 'VIEW_3D':\n                space.region_3d.view_location = (5.0, 5.0, 0.0)  # Center view\n                space.region_3d.view_distance = 15.0  # Zoom out\n                break\n```\n</implementation>"}
{"id": 85, "instruction": "Place a 3x3x2 cube at (5, -5, 0) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires precise geometric manipulation of a rectangular prism in 3D space. The core challenge involves correctly interpreting dimension specifications (3×3×2) within Blender's coordinate system, applying proper scaling to the default 2×2×2 cube primitive, and executing axis-aligned rotation. The location placement at (5, -5, 0) is straightforward, but the rotation must be handled carefully to match the expected orientation.\n</strategic_analysis>\n\n<spatial_layout>\n- Default Cube Dimensions: Blender's primitive cube has side length 2 units (vertex span from -1 to +1 on each axis).\n- Target Dimensions: 3×3×2 (width×depth×height in world space). Scale factors per axis: X=3/2=1.5, Y=3/2=1.5, Z=2/2=1.0.\n- Rotation Transformation: 90° rotation around X-axis (π/2 radians). This reorients the local axes: original +Y becomes +Z, original +Z becomes -Y.\n- World Position: Translation to (5, -5, 0) after scaling and rotation.\n- Coordinate System: Right-handed, Z-up. Rotation follows Blender's Euler convention.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body transformation hierarchy: world → cube_object (no joints needed).\n- Local transformation order: scale → rotate → translate (applied in Blender's object matrix).\n- Mesh topology remains unchanged from default cube (8 vertices, 12 faces).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Static placement with no dynamic constraints.\n- Risk: Potential misinterpretation of dimension order (X,Y,Z vs width,height,depth).\n- Mitigation: Explicit scaling factors derived from target/initial dimension ratio.\n- Verification: After transformation, bounding box should measure exactly 3×3×2 in world coordinates with rotated orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- target_width: 3.0\n- target_depth: 3.0\n- target_height: 2.0\n- default_cube_size: 2.0\n- scale_x: 1.5\n- scale_y: 1.5\n- scale_z: 1.0\n- location: (5.0, -5.0, 0.0)\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.57079632679\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling for 3×3×2 dimensions\ncube.scale = (1.5, 1.5, 1.0)  # X, Y, Z scale factors\n\n# Apply 90° rotation around X-axis (convert degrees to radians)\nrotation_rad = math.radians(90.0)\ncube.rotation_euler = (rotation_rad, 0.0, 0.0)\n\n# Apply translation to target location\ncube.location = (5.0, -5.0, 0.0)\n\n# Update transformations\nbpy.context.view_layer.update()\n\n# Verification output\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Dimensions (world): {cube.dimensions}\")\nprint(f\"Rotation (degrees): {tuple(math.degrees(r) for r in cube.rotation_euler)}\")\n```\n</implementation>"}
{"id": 96, "instruction": "Place a 2x2x6 cube at (0, 4, -7) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a simple static object placement task. The goal is to create a cube with specific dimensions (2x2x6), position it at coordinates (0,4,-7), and apply a 20-degree rotation around the Z-axis. The primary consideration is correctly applying transformations in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X)=2m, Depth (Y)=2m, Height (Z)=6m.\n- Location: (X=0, Y=4, Z=-7).\n- Rotation: 20° around the global Z-axis (which in Blender points upwards).\n- Transformation Order: We will apply scale first to achieve the correct dimensions, then set location and rotation.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static mesh object with no joints or constraints.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation required. The object will remain statically placed.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 6.0)\n- cube_location: (0.0, 4.0, -7.0)\n- cube_rotation_z_degrees: 20.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a cube with initial size 2 (creates 2x2x2 cube)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Scale to achieve 2x2x6 dimensions\n# Default cube is 2x2x2, so Z must be scaled by 3 to get 6m height\ncube.scale = (1.0, 1.0, 3.0)\n\n# Apply the scale so dimensions are correct and rotation works properly\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (0.0, 4.0, -7.0)\n\n# Set rotation: 20 degrees around Z-axis\ncube.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Optional: Set origin to geometry center for clarity\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n```\n</implementation>"}
{"id": 98, "instruction": "Place a sphere with radius 0.5 at (7, -3, 3) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nSimple static object placement task with no mechanical constraints or dynamics. The core requirement is precise geometric transformation: create a UV sphere at specified coordinates and apply a Y-axis rotation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.5 units (diameter = 1.0)\n- Translation vector: (7.0, -3.0, 3.0) in world coordinates\n- Rotation: 45° around Y-axis (local transform)\n- Blender internal conversion: 45° × (π/180) = 0.785398 radians\n- Bounding box: [-0.5, -0.5, -0.5] to [0.5, 0.5, 0.5] in object space before transformation\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body (sphere) with no parent-child hierarchy\n- No joints or constraints required\n- Transform applied directly to mesh object\n</kinematic_topology>\n\n<predictive_simulation>\n- Static placement only; no dynamics or collisions specified\n- If rigid body physics were enabled, mass would be proportional to volume (4/3 × π × r³)\n- Rotation purely visual with no mechanical consequences\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 0.5\nsphere_location: (7.0, -3.0, 3.0)\nsphere_rotation_y_deg: 45.0\nsphere_rotation_y_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.5)\nsphere = bpy.context.active_object\nsphere.name = \"Target_Sphere\"\n\n# Apply location transform\nsphere.location = (7.0, -3.0, 3.0)\n\n# Apply rotation (convert degrees to radians)\nsphere.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Update scene\nbpy.context.view_layer.update()\n\nprint(f\"Created sphere '{sphere.name}'\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {math.degrees(sphere.rotation_euler.y):.1f}° around Y-axis\")\nprint(f\"  Radius: {sphere.dimensions.x/2:.3f} (verified)\")\n```\n</implementation>"}
{"id": 99, "instruction": "Place a cylinder (radius 1, height 6) at (-1, -1, 10) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static cylinder with specific dimensions, position, and orientation. This is a foundational 3D modeling operation that tests understanding of coordinate systems, Euler rotations, and Blender's primitive creation workflow. No dynamics or complex hierarchies are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Center Position: (-1, -1, 10) in world coordinates (x, y, z).\n- Cylinder Dimensions: Radius = 1.0 m, Height = 6.0 m.\n- Rotation Specification: 30° rotation around the global Z-axis.\n- Transformation Order: In Blender, applying location then rotation (using Euler angles) achieves the desired placement. The rotation is applied after setting the location, rotating the cylinder about its center.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world -> cylinder (static mesh). No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Static stability: The cylinder is free-floating in space with no gravity or collisions enabled. Placement is purely visual.\n- Verification: The cylinder's base and top will be at z = 10 ± 3 (center at z=10, height=6). The 30° Z-rotation will orient it within the XY-plane.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 6.0\n- cylinder_location: (-1.0, -1.0, 10.0)\n- cylinder_rotation_z_degrees: 30.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\n# Default cylinder in Blender is aligned with Z-axis, centered at origin\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=6.0,\n    location=(-1.0, -1.0, 10.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"TargetCylinder\"\n\n# Apply 30-degree rotation around Z-axis\ncylinder.rotation_euler = (0, 0, math.radians(30.0))\n\n# Optional: Set object origin to geometry center (already centered by default)\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 101, "instruction": "Place a Passive 1x1x1 cube at (0, 0, 0) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves placing a simple passive cube with specific location and rotation. While minimal physics reasoning is required, we must ensure accurate 3D modeling and rigid body setup. The cube should be stationary and non-responsive to external forces due to its passive rigid body type. We'll create a default cube and adjust its properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube origin: (0, 0, 0)\n- Cube dimensions: 1m × 1m × 1m\n- Rotation: 30° about X-axis (0.5236 radians)\n- No translation or scaling needed beyond initial placement\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube_object (Static mesh with passive rigid body)\n- No joints or constraints required\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is grounded at origin with passive rigid body, ensuring zero movement\n- Risk: None for static object\n- Note: Passive rigid bodies don't respond to dynamics but can collide\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (0.0, 0.0, 0.0)\n- cube_dimensions: (1.0, 1.0, 1.0)\n- cube_rotation_x_degrees: 30.0\n- cube_rotation_x_radians: 0.5235987756\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default dimensions\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Set rotation (30° about X-axis)\ncube.rotation_euler = (math.radians(30), 0, 0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Verify properties\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Cube rotation (degrees): {[math.degrees(r) for r in cube.rotation_euler]}\")\nprint(f\"Rigid body type: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 93, "instruction": "Place a 5x1x3 cube at (-8, 1, 0) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement of a rectangular prism with specific dimensions, position, and orientation. This is a static modeling task without dynamics. The cube's center will be at the specified location after transformation. Rotation around the Z-axis (global or local) will tilt the object in the XY plane while keeping vertical faces vertical but slanted relative to world axes.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (W×H×D): 5m (X), 1m (Y), 3m (Z). These are half-extents? Blender's default cube is 2×2×2, so scaling factors = (5/2, 1/2, 3/2) = (2.5, 0.5, 1.5).\n- Target Location (center): (-8, 1, 0).\n- Rotation: 30° around Z-axis = 0.5236 radians.\n- No dependencies on other objects; purely geometric.\n</spatial_layout>\n\n<kinematic_topology>\nStatic mesh object with no joints or hierarchy. Single rigid transform from object space to world space.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamics involved. The cube will remain fixed at specified pose. Ensure scaling is applied before rotation to avoid distortion of rotation axes.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (5.0, 1.0, 3.0)\n- target_location: (-8.0, 1.0, 0.0)\n- rotation_z_deg: 30.0\n- scale_factors: (2.5, 0.5, 1.5)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scaling to achieve 5×1×3 dimensions\ncube.scale = (2.5, 0.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-8.0, 1.0, 0.0)\ncube.rotation_euler = Euler((0.0, 0.0, math.radians(30.0)), 'XYZ')\n\n# Optional: Add material for visibility\nmat = bpy.data.materials.new(name=\"CubeMaterial\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Cube '{cube.name}' created at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 97, "instruction": "Place a 4x3x2 cube at (-2, 8, 1) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a rectangular prism with specified dimensions (4×3×2 units), positioning it at coordinates (-2, 8, 1), and applying a 35° rotation around the X-axis. This is a static placement task with no dynamic or interactive requirements. The main considerations are accurate geometric representation, correct transformation order (scale, then rotation, then translation), and ensuring the rotation is applied in the correct coordinate space.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (Width×Depth×Height): 4.0 (X), 3.0 (Y), 2.0 (Z)\n- Base cube primitive in Blender is 2×2×2 (vertices at ±1), so scale factors: (2.0, 1.5, 1.0)\n- Target location (center): (-2, 8, 1) in global coordinates\n- Rotation: 35° around X-axis = 35 × π/180 = 0.610865 radians\n- Transformation order: Apply scale first (implicit in cube creation), then rotation, then translation to final location\n</spatial_layout>\n\n<kinematic_topology>\nStatic single-object hierarchy:\n- world → cube_object (no parent, static mesh)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: N/A (static object)\n- Collision: N/A (no other objects)\n- Rotation: 35° X rotation will tilt the cube forward (positive rotation around X-axis in right-handed coordinate system)\n- Coordinate system: Blender uses right-handed Z-up, so X rotation tilts forward/backward\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 3.0, 2.0)\n- cube_location: (-2.0, 8.0, 1.0)\n- cube_rotation_x_degrees: 35.0\n- cube_rotation_x_radians: 0.610865\n- base_cube_size: 2.0 (Blender default)\n- scale_factors: (2.0, 1.5, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default 2×2×2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"TargetCube\"\n\n# Apply scale to achieve 4×3×2 dimensions\n# Default cube vertices at ±1, so scale by (4/2, 3/2, 2/2) = (2.0, 1.5, 1.0)\ncube.scale = (2.0, 1.5, 1.0)\n\n# Apply rotation (35° around X-axis)\nrotation_rad = math.radians(35.0)\ncube.rotation_euler = (rotation_rad, 0.0, 0.0)\n\n# Apply location\ncube.location = (-2.0, 8.0, 1.0)\n\n# Apply transforms to make these the object's base transforms\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Verify final properties\nprint(f\"Cube created:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Euler): {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 103, "instruction": "Place a Passive sphere (radius 1) at (0, 3, 2) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is straightforward: create a passive rigid body sphere with specific geometric properties. This involves setting the sphere's radius, location, and rotation in 3D space, then configuring its physics properties as passive. No complex kinematics are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Center Position: (x=0.0m, y=3.0m, z=2.0m) as specified.\n- Sphere Radius: 1.0m, meaning diameter is 2.0m.\n- Sphere Rotation: 90° about the Z-axis. In Blender's right-handed coordinate system (Z-up), this corresponds to a rotation vector of (0, 0, π/2) radians.\n- Bounding Box: The sphere will occupy the axis-aligned bounding box from (-1, 2, 1) to (1, 4, 3).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single rigid body with no parent or child relationships)\n- No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the sphere will remain fixed in the simulation unless acted upon by external active bodies.\n- Risk: None. The sphere is static and will not fall or move unintentionally.\n- Verification: Ensure the rigid body type is set to 'PASSIVE' to prevent gravity from affecting it.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.0\n- sphere_location: (0.0, 3.0, 2.0)\n- sphere_rotation_z_degrees: 90.0\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere primitive (default segments=32, rings=16)\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.0,\n    location=(0.0, 3.0, 2.0),\n    scale=(1.0, 1.0, 1.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Passive_Sphere\"\n\n# Apply 90-degree rotation around Z-axis (convert degrees to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Add rigid body physics and set to passive\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'PASSIVE'\n\n# Optional: Set mass (not strictly needed for passive, but good practice)\nsphere.rigid_body.mass = 1.0\n\nprint(f\"Created passive sphere '{sphere.name}'\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {tuple(math.degrees(r) for r in sphere.rotation_euler)}\")\nprint(f\"  Radius: {sphere.dimensions.x / 2.0}\")\n```\n</implementation>"}
{"id": 102, "instruction": "Place an Active 2x2x2 cube at (2, 5, 0) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward modeling and rigid body assignment. The task is to create a 2-meter cube, position it at (2,5,0), apply a 45° rotation around the Y-axis, and assign it active rigid body physics. Since no ground plane or collisions are specified, the cube will simply fall under gravity when the simulation runs.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 2m x 2m x 2m.\n- Cube center position: (2.0, 5.0, 0.0).\n- Rotation: 45° around the global Y-axis.\n- Radian conversion: 45° = π/4 ≈ 0.7853981634 radians.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> active_cube (Active Rigid Body, no parent or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\n- With active rigid body physics enabled, the cube will immediately fall under gravity (default -9.81 m/s² along Z).\n- Without a passive collision object (e.g., a ground plane), the cube will fall indefinitely.\n- The rotation is applied as an initial transformation, not as a continuous torque.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_size: 2.0\n- cube_location: (2.0, 5.0, 0.0)\n- cube_rotation_y_rad: 0.785398\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create 2x2x2 cube\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply transformations from parameter summary\ncube.location = (2.0, 5.0, 0.0)\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)  # 45° around Y\n\n# Assign active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n# Use default mass (1.0 kg) and collision shape (CONVEX_HULL)\n\nprint(f\"Created active cube: {cube.name}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (degrees): ({math.degrees(cube.rotation_euler.x):.1f}, {math.degrees(cube.rotation_euler.y):.1f}, {math.degrees(cube.rotation_euler.z):.1f})\")\n```\n</implementation>"}
{"id": 107, "instruction": "Place a Passive sphere (radius 2) at (5, 0, 1) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static (passive) sphere with specific geometric properties and orientation. As a passive rigid body, it will serve as an immovable object in the simulation environment, acting as an obstacle or environmental element. The primary considerations are accurate placement, scaling for the radius, and applying the correct rotation transformation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 2.0 units.\n- Sphere Location: (X=5.0, Y=0.0, Z=1.0) in global coordinates.\n- Rotation: 45° around the Y-axis. In radians: θ = 45 * (π/180) = 0.7853981634 rad.\n- Bounding Box: The sphere will extend from 3.0 to 7.0 in X, -2.0 to 2.0 in Y, and -1.0 to 3.0 in Z (pre-rotation). Rotation around Y-axis will swap X and Z extents for the bounding box.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single passive rigid body with no joints or hierarchy).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body with default mass (based on volume and density), it will remain static.\n- Collision: The sphere will interact with active rigid bodies through Blender's physics engine.\n- Risk: None for the sphere itself. The 45° rotation is purely visual/orientational and does not affect collision geometry (which remains spherical).\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.0\n- sphere_location: (5.0, 0.0, 1.0)\n- rotation_y_degrees: 45.0\n- rotation_y_radians: 0.7853981634\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, but ensures clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV Sphere with 32 segments and rings (default)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.0, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Passive_Sphere\"\n\n# Scale to achieve radius of 2.0\nsphere.scale = (2.0, 2.0, 2.0)\n\n# Apply scale to make radius intrinsic\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\nsphere.location = (5.0, 0.0, 1.0)\n\n# Rotate 45 degrees around Y-axis\nsphere.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Add rigid body physics and set to PASSIVE\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'PASSIVE'\n\n# Optionally, set mass (but not required for passive)\n# sphere.rigid_body.mass = 10.0\n\nprint(f\"Created passive sphere: {sphere.name}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation Y: {math.degrees(sphere.rotation_euler.y):.1f}°\")\nprint(f\"  Scale (applied): {sphere.scale}\")\n```\n</implementation>"}
{"id": 105, "instruction": "Place a Passive 3x1x1 cube at (-3, 0, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static passive rigid body cube with specific dimensions, position, and orientation. This involves basic 3D modeling with precise geometric transformations. The cube will be scaled from default Blender dimensions (2x2x2) to the target 3x1x1, then positioned and rotated. As a passive rigid body, it will remain stationary during simulations while interacting with other objects.\n</strategic_layout>\n\n<spatial_layout>\n- Target dimensions: Length (X) = 3m, Width (Y) = 1m, Height (Z) = 1m\n- Default Blender cube dimensions: 2m × 2m × 2m (centered at origin)\n- Required scale factors: X = 3/2 = 1.5, Y = 1/2 = 0.5, Z = 1/2 = 0.5\n- Target location: (-3, 0, 0) in world coordinates\n- Target rotation: 15° around Y-axis = 0.261799 radians (π/12)\n- Object origin will remain at geometric center after scaling\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_object (Single rigid body mesh with passive physics)\n- No joints or hierarchies needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Passive rigid body ensures complete stability\n- Collision: Properly scaled dimensions ensure accurate collision boundaries\n- Risk: None for this static object\n- Note: Default collision margin of 0.04m may slightly extend effective dimensions\n</predictive_simulation>\n\n<parameter_summary>\n- target_dimensions: (3.0, 1.0, 1.0)\n- target_location: (-3.0, 0.0, 0.0)\n- target_rotation_y_degrees: 15.0\n- target_rotation_y_radians: 0.2617993877991494\n- scale_factors: (1.5, 0.5, 0.5)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Apply scale transformation\ncube.scale = (1.5, 0.5, 0.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set position and rotation\ncube.location = (-3.0, 0.0, 0.0)\ncube.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add rigid body physics (passive)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX for accuracy\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 104, "instruction": "Place an Active cylinder (radius 1, height 2) at (1, 6, 1) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a single active rigid body cylinder with specific dimensions, location, and rotation. The main considerations are ensuring the cylinder's geometry matches the parameters (radius=1, height=2), placing it at coordinates (1, 6, 1), and applying a 60° rotation around the X-axis. As an active rigid body, it will respond to gravity and collisions in Blender's physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: radius = 1.0 m, height = 2.0 m.\n- Location: world coordinates (x=1.0, y=6.0, z=1.0). Note that z=1.0 means the cylinder's base will be at z=0 and top at z=2 if unrotated, since Blender centers cylinders vertically by default.\n- Rotation: 60° around X-axis. In radians: 60 * π/180 = π/3 ≈ 1.0472 rad.\n- Since the cylinder is centered, the rotation will tilt it forward (if X-axis is horizontal).\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent object: cylinder (active rigid body) with no hierarchical parent.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cylinder will fall under gravity (default -9.8 m/s² in Z direction).\n- The 60° X rotation means it will initially tilt and likely roll upon impact with any collision surface.\n- Without additional objects (like a floor), the cylinder will fall indefinitely. We'll add a large passive floor plane to ground the simulation.\n- Risk: The cylinder may intersect the floor if placed at z=1.0 (its center). With height 2.0 and radius 1.0, the bottom is at z=0.0, so it will initially rest on the floor at z=0.0.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 2.0\n- cylinder_location: (1.0, 6.0, 1.0)\n- cylinder_rotation_x_degrees: 60.0\n- cylinder_rotation_x_radians: 1.0472\n- floor_size: 20.0\n- floor_location: (0.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=2.0,\n    location=(1.0, 6.0, 1.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Active_Cylinder\"\n\n# Apply rotation (60 degrees around X-axis)\ncylinder.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 10.0  # Reasonable mass for size\ncylinder.rigid_body.friction = 0.5\ncylinder.rigid_body.restitution = 0.2\n\n# Create floor plane for simulation stability\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0.0, 0.0, 0.0))\nfloor = bpy.context.active_object\nfloor.name = \"Floor\"\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\nfloor.rigid_body.type = 'PASSIVE'\nfloor.rigid_body.friction = 0.5\nfloor.rigid_body.restitution = 0.2\n\n# Set up world physics\nbpy.context.scene.gravity = (0.0, 0.0, -9.81)\n\n# Frame settings for animation\nbpy.context.scene.frame_start = 1\nbpy.context.scene.frame_end = 250\n```\n</implementation>"}
{"id": 108, "instruction": "Place an Active cylinder (radius 0.5, height 3) at (0, 7, 3) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a single rigid body cylinder with specified geometry, position, and orientation. Since the cylinder is marked as \"Active,\" it will participate in Blender's physics simulations (e.g., respond to gravity and collisions). The primary requirement is accurate placement and rotation, with no complex assembly or interactions specified.\n</strategic_layout>\n\n<spatial_layout>\n- Cylinder radius: 0.5 units.\n- Cylinder height: 3 units.\n- Location: (x=0, y=7, z=3). Note: In Blender, the local origin of a cylinder is at its geometric center.\n- Rotation: 120° about the global Z-axis. Convert to radians: 120° × π/180° = 2π/3 ≈ 2.0944 rad.\n- The cylinder's local Z-axis will be its axis of symmetry. A 120° rotation about global Z rotates the cylinder's local X and Y axes.\n</spatial_layout>\n\n<kinematic_topology>\n- Single object: cylinder (Active rigid body). No hierarchy or joints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an Active rigid body, the cylinder will fall under gravity unless constrained. Its initial orientation (120° about Z) does not affect its center of mass for uniform density, so stability is not a concern.\n- Risk: None beyond typical rigid body simulation behavior.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.5\n- cylinder_height: 3.0\n- cylinder_location: (0.0, 7.0, 3.0)\n- cylinder_rotation_z_deg: 120.0\n- cylinder_rotation_z_rad: 2.0943951023931953\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with radius 0.5 and depth 3 (Blender's cylinder depth is along local Z)\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.5,\n    depth=3.0,\n    location=(0.0, 7.0, 3.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"ActiveCylinder\"\n\n# Rotate 120° about global Z-axis (convert degrees to radians)\nrotation_rad = math.radians(120.0)\ncylinder.rotation_euler = (0.0, 0.0, rotation_rad)\n\n# Add Active rigid body component\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 1.0  # default mass\ncylinder.rigid_body.collision_shape = 'MESH'  # matches the cylinder geometry accurately\n\n# Ensure the cylinder is visible and rendered\ncylinder.display_type = 'TEXTURED'\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 100, "instruction": "Place a 3x3x1 cube at (9, 0, -2) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThis is a simple static placement task requiring accurate geometric transformations. We'll create a rectangular prism (3×3×1 dimensions), position it at the specified coordinate, and apply the 90° X-axis rotation. Since it's a static object, no physics or kinematics are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Target location: (9.0, 0.0, -2.0)\n- Target rotation: 90° around X-axis = 1.5708 radians\n- Dimensions: 3×3×1 (width×depth×height)\n- The default Blender cube has vertices at ±1 unit on each axis (2×2×2). To achieve 3×3×1:\n  Scale factors: (3/2, 3/2, 1/2) = (1.5, 1.5, 0.5)\n- After scaling, the object's local origin remains at its geometric center.\n</spatial_layout>\n\n<kinematic_topology>\nStatic single object with no parent-child relationships or joints required.\n</kinematic_topology>\n\n<predictive_simulation>\nNo dynamic simulation needed. The object will be placed statically. Ensure rotation is applied correctly so the cube's local Z-axis aligns with world Y-axis after 90° X-rotation.\n</predictive_simulation>\n\n<parameter_summary>\n- location: (9.0, 0.0, -2.0)\n- rotation_euler: (1.5708, 0.0, 0.0)\n- scale: (1.5, 1.5, 0.5)\n- dimensions: (3.0, 3.0, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube at origin\nbpy.ops.mesh.primitive_cube_add()\ncube = bpy.context.active_object\ncube.name = \"3x3x1_Cube\"\n\n# Apply transformations\ncube.scale = (1.5, 1.5, 0.5)\ncube.location = (9.0, 0.0, -2.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Apply scale to make dimensions explicit in mesh data\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Verify dimensions\nprint(f\"Object location: {cube.location}\")\nprint(f\"Object rotation: {cube.rotation_euler}\")\nprint(f\"Object dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 106, "instruction": "Place an Active 1x3x1 cube at (0, 4, -2) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single rigid body object with specific geometric properties and placement. The cube dimensions (1x3x1) suggest an elongated rectangular prism oriented along the Y-axis by default. The 90° X-axis rotation will change its primary orientation, making it effectively 3x1x1 in world space after rotation. We need to ensure proper scaling, location, and rotation before applying rigid body physics.\n</strategic_analysis>\n\n<spatial_layout>\n- Default Blender cube vertices: ±0.5 on each local axis (1m³ total volume)\n- Target dimensions: X=1.0m, Y=3.0m, Z=1.0m\n- Required scale factors: (1.0, 3.0, 1.0) relative to default\n- Location: (0, 4, -2) in world coordinates\n- Rotation: 90° about X-axis = π/2 radians\n- After X-rotation: Local Y becomes vertical, local Z becomes depth\n- Final world-space bounding box: ~3m tall (Y), 1m wide (X), 1m deep (Z)\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy:\n  - world → cube_object (Active Rigid Body)\n- No joints or constraints required\n- Mass calculated automatically from volume and default density\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Object will fall under gravity from height y=4 with initial rotation\n- Dynamic risk: Asymmetric mass distribution may cause tumbling during fall\n- Collision geometry: Mesh collision shape recommended for accurate physics\n- Ground interaction: Requires passive ground plane for realistic simulation\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 3.0, 1.0)\n- location: (0.0, 4.0, -2.0)\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.570796\n- rigidbody_type: ACTIVE\n- collision_shape: MESH\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (1m³ at origin)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scale for 1x3x1 dimensions\ncube.scale = (1.0, 3.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 4.0, -2.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'MESH'\ncube.rigid_body.mass = 1.0  # Explicit mass (optional)\n\n# Create ground plane for simulation context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, -5))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Set scene gravity for realistic fall\nbpy.context.scene.use_gravity = True\nbpy.context.scene.gravity = (0.0, 0.0, -9.81)\n```\n</implementation>"}
{"id": 111, "instruction": "Place a Passive 1x2x2 cube at (1, 0, 5) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static, non-moving cube with specific dimensions, position, and orientation. This is a foundational 3D modeling operation with rigid body physics initialization. The cube will serve as a passive environmental object that other active bodies can interact with. The transformation order (location then rotation) must be considered to achieve the intended final state.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 1.0m, Depth (Y) = 2.0m, Height (Z) = 2.0m.\n- World location: (X=1.0m, Y=0.0m, Z=5.0m).\n- Rotation: 45° around the global Z-axis (0, 0, 45) in degrees.\n- Since Blender's default cube primitive has vertices at ±0.5 on each local axis, the base scale for a 1x1x1m cube is 1.0. Therefore, the target scale vector is (0.5, 1.0, 1.0) to achieve 1x2x2m dimensions.\n- The transformation sequence: Create at origin → Scale to dimensions → Move to location → Apply rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world → static_cube (Passive Rigid Body Mesh)\n- No joints or constraints required; the object is fully static.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body with high mass (default), the cube will remain fixed during simulations.\n- Risk: None. The object is static and properly dimensioned.\n- Interaction: The 45° rotation may create inclined surfaces for dynamic objects to slide or roll on.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 2.0)\n- cube_location: (1.0, 0.0, 5.0)\n- cube_rotation: (0.0, 0.0, 45.0) # degrees\n- cube_scale: (0.5, 1.0, 1.0) # relative to default 2m Blender cube\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport mathutils\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2m)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scaling for target dimensions (1x2x2)\n# Default cube vertices at ±0.5 => scale (1,1,1) gives 1x1x1m\n# Target: X=1.0m (scale 0.5), Y=2.0m (scale 1.0), Z=2.0m (scale 1.0)\ncube.scale = (0.5, 1.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (1.0, 0.0, 5.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Apply rotation transformation\nbpy.ops.object.transform_apply(rotation=True)\n\n# Add rigid body physics as PASSIVE\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Verify final properties\nprint(f\"Cube created: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {cube.rotation_euler}\")\nprint(f\"  Rigid Body: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 110, "instruction": "Place an Active 4x1x1 cube at (3, 6, -1) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a dynamic rigid body cube with specified dimensions, position, and orientation. The \"Active\" designation indicates it should respond to physics forces. We'll create a cube primitive, scale it to the desired 4x1x1 dimensions, position it at (3,6,-1), rotate it 75° around the Y-axis, and assign an active rigid body property.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: 4m (X), 1m (Y), 1m (Z). Default Blender cube (size=1) is 2x2x2 meters, requiring scaling factors (2.0, 0.5, 0.5).\n- World position: (3, 6, -1) meters.\n- Rotation: 75° around Y-axis = 1.308996 radians (75° × π/180°).\n- Origin: Default cube origin at geometric center aligns with position coordinate.\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body hierarchy:\n- world → cube_object (Active Rigid Body)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body with default mass distribution, cube may fall due to gravity (Z=-1 is below origin).\n- Risk: Initial rotation (75° Y) may cause tumbling when simulation starts.\n- Mitigation: Default rigid body settings (mass=1kg, friction=0.5) are sufficient for demonstration.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 1.0, 1.0)\n- cube_location: (3.0, 6.0, -1.0)\n- cube_rotation_y_degrees: 75.0\n- cube_rotation_y_radians: 1.308996\n- scale_factors: (2.0, 0.5, 0.5)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube primitive (default 2x2x2 at origin)\nbpy.ops.mesh.primitive_cube_add(size=1.0, enter_editmode=False, align='WORLD', location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scale to achieve 4x1x1 dimensions (scale factors = desired/current = (4/2, 1/2, 1/2))\ncube.scale = (2.0, 0.5, 0.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set position and rotation\ncube.location = (3.0, 6.0, -1.0)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Verify dimensions\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 112, "instruction": "Place an Active sphere (radius 0.5) at (-2, 4, 1) and rotate it 180° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object instantiation and transformation task. The sphere must be created with the specified geometry, positioned, oriented, and assigned active rigid body physics for dynamic simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.5 m.\n- World location: (-2.0, 4.0, 1.0) in meters.\n- Rotation: 180° around the Y-axis (local coordinates). Conversion: 180° = π radians ≈ 3.14159 rad.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body entity: sphere (no hierarchy).\n- Rigid body type: ACTIVE for dynamic response.\n</kinematic_topology>\n\n<predictive_simulation>\n- Without a passive ground plane, the sphere will fall indefinitely under gravity (default -9.8 m/s² on Z-axis).\n- Rotation is purely visual/orientational initially; angular dynamics will depend on collisions.\n- Risk: None beyond expected gravitational fall.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.5\n- sphere_location: (-2.0, 4.0, 1.0)\n- sphere_rotation_y_radians: 3.14159\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with given radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.5)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation (Y-axis rotation by 180 degrees)\nsphere.location = (-2.0, 4.0, 1.0)\nsphere.rotation_euler = (0.0, math.pi, 0.0)  # X, Y, Z in radians\n\n# Assign active rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Optional: Set a distinct material color for visibility\nmat = bpy.data.materials.new(name=\"Sphere_Material\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Reddish\nif sphere.data.materials:\n    sphere.data.materials[0] = mat\nelse:\n    sphere.data.materials.append(mat)\n\nprint(f\"Sphere created at {sphere.location} with rotation {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 109, "instruction": "Place a Passive 2x1x3 cube at (-2, 0, 4) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a passive rigid body cube with specific dimensions, position, and rotation. No complex physics simulation or multi-body constraints are needed beyond setting up the object correctly in Blender. The main considerations are accurate dimension scaling, correct coordinate transformation for position, and proper rotation application about the object's local X-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 2m, Depth (Y) = 1m, Height (Z) = 3m.\n- Location: World coordinates (-2, 0, 4) represents the cube's geometric center.\n- Rotation: 30° about the X-axis, applied after scaling and positioning.\n- Geometric Note: Since the default Blender cube (size=2) has vertices at ±1 in all axes, we scale by (1, 0.5, 1.5) to achieve 2×1×3 dimensions.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single passive rigid body with no parent or joints)\n- Rigid body type: PASSIVE (immovable in simulation)\n- No constraints or hierarchical relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body anchored at (-2,0,4), the cube will remain fixed during simulations.\n- Risk: None beyond potential intersection with other objects at the specified location.\n- Validation: The 30° X-rotation will visibly tilt the cube's top surface relative to world horizontal.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions_xyz: (2.0, 1.0, 3.0)\n- location: (-2.0, 0.0, 4.0)\n- rotation_x_degrees: 30.0\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube (default 2x2x2 at origin)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Scale to achieve 2×1×3 dimensions (from default 2×2×2)\ncube.scale = (1.0, 0.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Move to target location\ncube.location = (-2.0, 0.0, 4.0)\n\n# Apply 30-degree rotation about X-axis\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Cube created: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (degrees): ({math.degrees(cube.rotation_euler.x):.1f}, {math.degrees(cube.rotation_euler.y):.1f}, {math.degrees(cube.rotation_euler.z):.1f})\")\nprint(f\"  Rigid Body Type: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 113, "instruction": "Place a Passive cylinder (radius 1, height 1) at (4, 0, 4) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nWe are creating a static passive cylinder as a kinematic obstacle. The primary considerations are precise placement and orientation. Since it's passive, it will remain stationary in simulations, serving as a collision object for other active bodies. The 90-degree X-axis rotation will orient the cylinder horizontally along the Y-axis (if default cylinder axis is Z).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center point: (4.0, 0.0, 4.0) in world coordinates.\n- Rotation: 90° about X-axis = π/2 radians.\n- Cylinder dimensions: Radius = 1.0m, Height = 1.0m (before rotation).\n- After 90° X-axis rotation, the cylinder's local Z-axis aligns with global Y-axis. The cylinder now extends along Y-direction from y = -0.5 to y = 0.5 (centered at y=0).\n- Bounding box extremes in world coordinates: \n  X: [3.0, 5.0], Y: [-0.5, 0.5], Z: [3.5, 4.5] (accounting for radius and half-height after rotation).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_body (Single rigid body, no joints)\n- cylinder_body: Passive rigid body, static in world space.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object, stability is inherent when placed on a surface. Here it's floating at Z=4, so may fall if gravity is enabled unless constrained or placed on another passive object.\n- Collision: The horizontal orientation creates a tunnel-like obstacle that objects might roll through or collide with.\n- Risk: Floating cylinder could fall if simulation starts with gravity. We'll set rigid body type to 'PASSIVE' to prevent motion.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 1.0\n- cylinder_location: (4.0, 0.0, 4.0)\n- cylinder_rotation_x: 90.0 (degrees)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with radius 1, depth 1 (default axis along Z)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=1.0,\n    location=(4.0, 0.0, 4.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"passive_cylinder\"\n\n# Rotate 90 degrees on X-axis (convert to radians)\ncylinder.rotation_euler[0] = math.radians(90.0)\n\n# Add rigid body physics (passive - static)\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Ensure proper scale\ncylinder.scale = (1.0, 1.0, 1.0)\n\n# Update transformations\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 117, "instruction": "Place a Passive cylinder (radius 2, height 1) at (0, 0, -5) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical obstacle as a rigid body for physical simulations. The cylinder must be positioned below ground level and rotated to create an angled obstruction, which could represent a tilted pipe, ramp, or barrier in a mechanical assembly or physics scenario.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Geometry: Radius = 2.0m, Height = 1.0m\n- World Position: (x=0.0, y=0.0, z=-5.0) placing the cylinder's origin 5 meters below world origin\n- Rotation: 45° about Y-axis (local rotation). In radians: 45 * π/180 = 0.7853981634 rad\n- Transform Order: Blender applies location then rotation (by default), so the cylinder will be rotated at its positioned location\n- Mesh Origin: Default cylinder origin is at its geometric center\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world → cylinder_object (passive rigid body)\n- No joints or constraints required\n- Static configuration with no parent relationships\n</kinematic_topology>\n\n<predictive_simulation>\n- Collision Geometry: Cylinder will interact with other rigid bodies as a static obstacle\n- Stability: As a passive rigid body, it will remain fixed regardless of collisions\n- Potential Use: Could serve as a ramp or barrier for rolling objects or projectiles\n- Note: Negative Z position places it below typical ground plane (z=0), which may require adjustment if interacting with ground-based objects\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.0\n- cylinder_height: 1.0\n- location: (0.0, 0.0, -5.0)\n- rotation_y_degrees: 45.0\n- rotation_y_radians: 0.7853981634\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene for clean execution\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=2.0,\n    depth=1.0,\n    location=(0.0, 0.0, -5.0),\n    rotation=(0.0, math.radians(45.0), 0.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add rigid body physics with passive type\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Optional: Set collision margin for stability\ncylinder.rigid_body.collision_margin = 0.0\n\nprint(f\"Created {cylinder.name} at {cylinder.location} with rotation {cylinder.rotation_euler}\")\nprint(f\"Radius: 2.0, Height: 1.0, Rigid Body Type: {cylinder.rigid_body.type}\")\n```\n</implementation>"}
{"id": 116, "instruction": "Place an Active sphere (radius 1.5) at (1, 6, 3) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a single active rigid body sphere with specific geometric properties. This is straightforward but requires precise parameter setting for location, rotation, and physics properties. The sphere should respond to gravity and collisions in Blender's physics simulation. No complex mechanisms or constraints are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius (r): 1.5 units\n- Center location: (x=1.0, y=6.0, z=3.0)\n- Rotation: 60° around the X-axis, equivalent to 1.0471975511965976 radians (using math.radians(60))\n- The sphere's local coordinate system will be rotated, affecting its collision shape orientation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Active Rigid Body)\n- No joints or parent-child relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere will immediately fall under gravity (default -9.81 m/s² on Z-axis) from its elevated starting position (z=3).\n- Without a ground plane, it will fall indefinitely. This matches an active rigid body in free space.\n- The initial X-axis rotation will be preserved until collisions impart torque.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.5\n- location_x: 1.0\n- location_y: 6.0\n- location_z: 3.0\n- rotation_x_degrees: 60.0\n- rotation_x_radians: 1.0471975511965976\n- rigid_body_type: ACTIVE\n- mass: 1.0 (default)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5)\nsphere = bpy.context.active_object\nsphere.name = \"ActiveSphere\"\n\n# Set location\nsphere.location = (1.0, 6.0, 3.0)\n\n# Set rotation (60° around X-axis, converted to radians)\nsphere.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Add active rigid body component\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n\n# Optional: Set mass if different from default (1.0kg)\n# sphere.rigid_body.mass = 2.0\n\nprint(f\"Created active sphere at {sphere.location} with rotation {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 115, "instruction": "Place a Passive 2x3x1 cube at (-5, 0, 2) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires placing a simple passive rigid body cube with specific dimensions, location, and rotation. No complex mechanical systems or physical interactions are needed—just accurate geometric modeling and rigid body setup in Blender.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 2m, depth (Y) = 3m, height (Z) = 1m.\n- Cube location: world coordinates (-5, 0, 2). The Z=2 places the cube's base at Z=1.5 and top at Z=2.5, assuming the origin is at the cube's geometric center.\n- Cube rotation: 35° around the global Y-axis, applied after scaling and translation.\n- Since the default Blender cube is 2×2×2, scaling factors are (1.0, 1.5, 0.5) to achieve the desired dimensions.\n</spatial_layout>\n\n<kinematic_topology>\n- World → passive_cube (static rigid body with no joints or constraints).\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube is passive and heavy, so it will remain stationary in simulations.\n- The 35° rotation is purely geometric and does not affect stability.\n- No dynamic risks; ensure rigid body mass is set high (e.g., 50 kg) to prevent unwanted movement if other objects interact with it.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 3.0, 1.0)\n- cube_location: (-5.0, 0.0, 2.0)\n- cube_rotation_y_deg: 35.0\n- cube_scale: (1.0, 1.5, 0.5)\n- rigidbody_mass: 50.0\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube (default 2m cube)\nbpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=(0, 0, 0), scale=(1, 1, 1))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scaling to achieve 2x3x1 dimensions\ncube.scale = (1.0, 1.5, 0.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (-5.0, 0.0, 2.0)\ncube.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Add rigid body properties\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.mass = 50.0\n```\n</implementation>"}
{"id": 114, "instruction": "Place an Active 3x3x1 cube at (2, 5, 0) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single 3x3x1 cube at the specified location (2,5,0) with a 20-degree rotation around the Z-axis and set it as an active rigid body for dynamic simulation. This is a straightforward modeling and physics setup task.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 3m (width) × 3m (depth) × 1m (height).\n- Cube Location: (2.0, 5.0, 0.0) in global coordinates.\n- Cube Rotation: 20° around the Z-axis (positive counter-clockwise when viewed from above).\n- Coordinate System: Blender uses a right-handed coordinate system with Z up.\n- Rotation Conversion: 20 degrees = 0.34906585 radians.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (single rigid body with no hierarchical dependencies).\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will fall under gravity (default -9.81 m/s² in Z) when the simulation runs.\n- With no other objects, it will fall indefinitely or until it hits a passive floor if present.\n- The rotation is applied initially and will be preserved in the simulation unless torque or collisions alter it.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 3.0, 1.0)\n- cube_location: (2.0, 5.0, 0.0)\n- cube_rotation_z_deg: 20.0\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Set dimensions to 3x3x1 (overrides scale automatically)\ncube.dimensions = (3.0, 3.0, 1.0)\n\n# Set location\ncube.location = (2.0, 5.0, 0.0)\n\n# Set rotation: 20 degrees around Z\ncube.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optional: Set mass based on volume (assuming density 1 kg/m³)\nvolume = 3.0 * 3.0 * 1.0\ncube.rigid_body.mass = volume\n```\n</implementation>"}
{"id": 121, "instruction": "Place a Passive sphere (radius 3) at (8, 0, 0) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a static object placement task. The objective is to create a non-moving sphere at a specified location and orientation, which will serve as a passive collision object in a physics simulation. This sphere acts as a fixed obstacle or environmental feature.\n</strategic_layout>\n\n<spatial_layout>\n- Sphere Radius: 3.0 units.\n- Sphere Location: (X=8.0, Y=0.0, Z=0.0).\n- Sphere Rotation: 45 degrees around the global Z-axis.\n- Derived: The sphere's bounding box will be approximately 6.0 units in all dimensions, centered at (8, 0, 0).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_sphere (Static Mesh, Passive Rigid Body).\n- No joints or hierarchical relationships.\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere is passive (static). It will not move under simulation forces but will collide with active rigid bodies.\n- Risk: None for the sphere itself. However, its placement at (8, 0, 0) may obstruct other objects if not considered in a larger scene context.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 3.0\n- sphere_location: (8.0, 0.0, 0.0)\n- sphere_rotation_z_degrees: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene (optional, ensures a clean start)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Add a UV sphere with the specified radius\n# Default segments and rings are fine for a simple sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=3.0, location=(8.0, 0.0, 0.0))\nsphere = bpy.context.active_object\nsphere.name = \"passive_sphere\"\n\n# Apply 45-degree rotation around the Z-axis\n# Rotation in Blender is in radians\nsphere.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Add a passive rigid body component\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'PASSIVE'\n# Ensure collision shape is appropriate (MESH for a sphere is accurate but heavier; SPHERE is efficient)\nsphere.rigid_body.collision_shape = 'SPHERE'\n```\n</implementation>"}
{"id": 122, "instruction": "Place an Active cylinder (radius 1, height 4) at (-6, 6, 0) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single rigid body cylinder with specific dimensions, position, and orientation. This is a foundational 3D modeling task requiring precise geometric placement. Since it's an \"Active\" cylinder, it must be set as an active rigid body for physics simulation. The primary challenge is ensuring the rotation is applied correctly in Blender's coordinate system (30° around the X-axis).\n</strategic_layout>\n\n<spatial_layout>\n- Cylinder dimensions: Radius (r) = 1.0m, Height (h) = 4.0m.\n- World Location: (x, y, z) = (-6.0, 6.0, 0.0).\n- Rotation: 30 degrees around the global X-axis. In radians: θ_x = 30° * (π/180) = π/6 ≈ 0.5236 rad.\n- The cylinder's local origin is at its geometric center. After rotation, the ends will be at z = ± (h/2) * cos(θ_x) relative to the world origin, but the center remains at z=0.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Single active rigid body, no hierarchy needed).\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cylinder will respond to gravity and collisions. With no other objects, it will fall downward (-Z).\n- The 30° X-axis tilt means it will initially have an asymmetric contact profile when landing, likely causing it to roll.\n- Risk: None, as this is a simple single-object scene.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 4.0\n- location_x: -6.0\n- location_y: 6.0\n- location_z: 0.0\n- rotation_x_deg: 30.0\n- rotation_x_rad: 0.5235987756\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with given dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=4.0,\n    location=(-6.0, 6.0, 0.0),\n    rotation=(math.radians(30.0), 0.0, 0.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Active_Cylinder\"\n\n# Assign active rigid body properties\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 10.0  # Default mass, can be adjusted\ncylinder.rigid_body.friction = 0.5\ncylinder.rigid_body.restitution = 0.1\n\n# Ensure viewport displays physics\nbpy.context.scene.rigidbody_world.steps_per_second = 60\nbpy.context.scene.rigidbody_world.solver_iterations = 10\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 120, "instruction": "Place an Active 5x1x1 cube at (6, 7, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rectangular prism (cube) with specific dimensions, location, and orientation in 3D space. An \"Active\" designation in a physics context typically means an active rigid body that responds to forces and collisions. The implementation will focus on precise geometric creation and property assignment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Length (X) = 5m, Depth (Y) = 1m, Height (Z) = 1m.\n- World Location: (X, Y, Z) = (6.0, 7.0, 0.0). The Z=0 position centers the 1m tall cube such that its base is at Z=-0.5 and top at Z=0.5.\n- Rotation: 15° around the global Y-axis. In radians: θ = 15 × (π/180) ≈ 0.2618 rad.\n- Local Origin: By default, a Blender cube's origin is at its geometric center. Therefore, the specified location places the cube's center at (6, 7, 0).\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world -> active_cube (Active Rigid Body with mesh collision).\n- No joints or constraints are required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body, the cube will fall under gravity unless supported. With its center at Z=0 and height of 1m, its bottom face is at Z=-0.5m, so it will rest on the ground plane (Z=0) if one exists.\n- Risk: None beyond standard rigid body simulation behavior.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (5.0, 1.0, 1.0)\n- cube_location: (6.0, 7.0, 0.0)\n- cube_rotation_y_degrees: 15.0\n- cube_rotation_y_radians: 0.2617993877991494\n- rigidbody_type: ACTIVE\n- mass: 5.0 (default density: 1 kg/m³ × volume 5 m³)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\n# Note: bpy.ops.mesh.primitive_cube_add creates a 2x2x2 cube by default, so we scale\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply dimensions (scale)\ncube.scale = (2.5, 0.5, 0.5)  # Default 1m cube becomes 5x1x1 after scaling\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (6.0, 7.0, 0.0)\ncube.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Assign active rigid body properties\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n# Optional: Set mass based on volume (5 m³) and density (1 kg/m³ default)\ncube.rigid_body.mass = 5.0\n```\n</implementation>"}
{"id": 119, "instruction": "Place a Passive 2x2x1 cube at (-1, 0, -1) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static, non-moving cube with specific dimensions, position, and orientation. This passive object will serve as a fixed environmental element in a physics simulation, potentially acting as an obstacle, platform, or anchor point. The 25° X-axis rotation tilts the cube forward, creating an inclined surface.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2m (X) × 2m (Y) × 1m (Z) scaling from default Blender cube (2×2×2).\n- World Location: (-1, 0, -1) meters.\n- Rotation: 25° about X-axis = 0.436332 radians (25 × π/180).\n- Origin: At cube center (default Blender behavior).\n- No clearance or interference considerations needed for single static object.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_object (Single static mesh with passive rigid body)\n- No joints or hierarchical relationships.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Fully stable as passive rigid body anchored to world.\n- Interaction: Will provide collision surface for active rigid bodies.\n- Risk: None for static object; ensure mass is sufficiently high if used as anchor.\n- Mitigation: Default passive rigid body settings appropriate.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 1.0)\n- cube_location: (-1.0, 0.0, -1.0)\n- cube_rotation_x_degrees: 25.0\n- cube_rotation_x_radians: 0.436332\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, ensures clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Scale to achieve 2×2×1 dimensions (default cube is 2×2×2)\n# Scaling factors: desired / default = (2/2, 2/2, 1/2) = (1, 1, 0.5)\ncube.scale = (1.0, 1.0, 0.5)\n\n# Apply scale to make dimensions explicit in mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-1.0, 0.0, -1.0)\ncube.rotation_euler.x = math.radians(25.0)  # 25° about X-axis\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set mass high for stability\ncube.rigid_body.mass = 100.0\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (degrees): {math.degrees(cube.rotation_euler.x)}° about X\")\n```\n</implementation>"}
{"id": 126, "instruction": "Place an Active cylinder (radius 0.75, height 2.5) at (1, 5, -4) and rotate it 40° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires placing a single dynamic cylinder with specific geometry at a precise location and orientation. This is a foundational 3D modeling task requiring coordinate system understanding and rigid body physics setup. The cylinder should be active (dynamic) to interact with gravity and other objects if present.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius (r): 0.75 units\n- Cylinder height (h): 2.5 units  \n- World location: (x=1.0, y=5.0, z=-4.0)\n- Rotation: 40° about global Y-axis (Euler rotation (0, 40°, 0) in degrees)\n- Blender's default cylinder origin is at its geometric center\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Single active rigid body with no joints)\n- All transformations applied directly to the cylinder mesh\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a standalone active rigid body, cylinder will fall under gravity unless supported\n- Risk: No collision risks with other objects in this minimal scene\n- Note: Cylinder's orientation affects its center of mass and how it rolls/falls\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.75\n- cylinder_height: 2.5  \n- cylinder_location: (1.0, 5.0, -4.0)\n- cylinder_rotation_y_degrees: 40.0\n- cylinder_rotation_y_radians: 0.6981317\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.75,\n    depth=2.5,\n    location=(1.0, 5.0, -4.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Active_Cylinder\"\n\n# Apply rotation (40° about Y-axis)\ncylinder.rotation_euler = (0.0, math.radians(40.0), 0.0)\n\n# Make cylinder an active rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 1.0\ncylinder.rigid_body.friction = 0.5\ncylinder.rigid_body.restitution = 0.3\n\n# Ensure proper collision shape\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Enable physics visualization (optional)\nbpy.context.scene.rigidbody_world.enabled = True\n```\n</implementation>"}
{"id": 118, "instruction": "Place an Active 1x1x4 cube at (2, 8, 1) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a single rigid body object with specific dimensions, location, and rotation. The term \"Active\" in Blender's physics context means the object should be an active rigid body that responds to forces like gravity. We need to ensure the cube's dimensions are scaled correctly from Blender's default 2m cube, apply the transformation, and set proper rigid body properties.\n</strategic_layout>\n\n<spatial_layout>\n- Default Blender cube dimensions: 2m × 2m × 2m\n- Target dimensions: 1m × 1m × 4m\n- Scaling factors: X = 1/2 = 0.5, Y = 1/2 = 0.5, Z = 4/2 = 2.0\n- Location: (2, 8, 1) in meters\n- Rotation: 90° about Z-axis = π/2 radians ≈ 1.5708 rad\n- Center of mass will be at the object origin after scaling\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent rigid body\n- No parent-child relationships or constraints required\n- Object origin remains at geometric center after scaling\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will fall under gravity starting at Z=1m\n- The 90° rotation about Z-axis will orient the long dimension (4m) along the X-axis initially\n- No collision objects exist, so it will fall indefinitely unless a floor is added\n- Mass should be calculated based on volume: 1×1×4 = 4m³\n- Assuming default density of 1 kg/m³, mass ≈ 4kg\n</predictive_simulation>\n\n<parameter_summary>\n- cube_scale: (0.5, 0.5, 2.0)\n- cube_location: (2.0, 8.0, 1.0)\n- cube_rotation_z_deg: 90.0\n- cube_rotation_z_rad: 1.5708\n- rigidbody_type: ACTIVE\n- rigidbody_mass: 4.0\n- rigidbody_shape: BOX\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scaling for 1x1x4 dimensions\ncube.scale = (0.5, 0.5, 2.0)\n\n# Apply scale transformation to mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (2.0, 8.0, 1.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 4.0  # Volume = 1*1*4 = 4m³\ncube.rigid_body.collision_shape = 'BOX'\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.3\n\n# Optional: Add a ground plane for context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Set viewport shading for better visibility\nfor area in bpy.context.screen.areas:\n    if area.type == 'VIEW_3D':\n        for space in area.spaces:\n            if space.type == 'VIEW_3D':\n                space.shading.type = 'SOLID'\n                space.shading.light = 'STUDIO'\n                space.shading.color_type = 'MATERIAL'\n                break\n\n# Frame the scene\nbpy.ops.view3d.view_selected(use_all_regions=False)\n```\n</implementation>"}
{"id": 125, "instruction": "Place a Passive sphere (radius 1) at (-2, 0, -2) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a single passive rigid body sphere with specified geometric transformations. No complex mechanisms or interactions are required. The sphere's passive rigid body property will make it immovable in physics simulations, acting as a fixed obstacle or environmental element. The 120° Z-axis rotation is applied, though visually imperceptible on a sphere due to symmetry, to demonstrate proper transformation handling.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center location: (-2.0, 0.0, -2.0)\n- Sphere radius: 1.0 m\n- Rotation: 120° about global Z-axis = 2.09439510239 radians (conversion: 120 × π/180)\n- Bounding box: From (-3.0, -1.0, -3.0) to (-1.0, 1.0, -1.0) [center ± radius]\n- No collision or clearance considerations needed for isolated object.\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere (Single rigid body, no hierarchy)\n- Joints: None\n- Constraints: None\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Perfectly stable as a passive rigid body fixed in world space.\n- Dynamic risks: None. The sphere won't move or interact unless struck by active rigid bodies.\n- Simulation role: Acts as a fixed collision object for other simulation elements.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.0\nsphere_location: (-2.0, 0.0, -2.0)\nsphere_rotation_z_deg: 120.0\nsphere_rotation_z_rad: 2.09439510239\nrigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with radius 1 at origin\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.0, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Passive_Sphere\"\n\n# Apply transformations from parameter summary\nsphere.location = (-2.0, 0.0, -2.0)\nsphere.rotation_euler = (0.0, 0.0, 120.0 * math.pi / 180.0)  # 120° Z-rotation\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'PASSIVE'\n\n# Set collision shape to sphere (optimal for performance)\nsphere.rigid_body.collision_shape = 'SPHERE'\n```\n</implementation>"}
{"id": 130, "instruction": "Place an Active sphere (radius 2.5) at (0, 10, 0) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single rigid body sphere with specific geometric placement and orientation. This is a foundational exercise in 3D scene setup, requiring precise application of translation and rotation transformations. The \"Active\" designation indicates the sphere should be subject to physics simulation (e.g., gravity, collisions) rather than static.\n</strategic_layout>\n\n<spatial_layout>\n- Sphere Radius (R): 2.5 units.\n- Translation Vector (T): (0, 10, 0). This moves the sphere's origin 10 units along the global Y-axis.\n- Rotation: 15° about the X-axis. In Blender's default coordinate system (Y-forward, Z-up), a positive rotation about X tilts the sphere forward.\n- Transformation Order: Apply rotation (local orientation change), then translation (world position).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single Active Rigid Body with no joints or constraints).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a single active rigid body, the sphere will fall under gravity (if enabled) from its starting position at (0,10,0). The rotation is purely visual/orientational and does not affect the center of mass or collision shape.\n- Risk: None. This is a simple static placement.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.5\n- sphere_location: (0.0, 10.0, 0.0)\n- sphere_rotation_x_degrees: 15.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV Sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.5)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation (converting degrees to radians)\nsphere.location = (0.0, 10.0, 0.0)\nsphere.rotation_euler = (math.radians(15.0), 0.0, 0.0)\n\n# Add Active Rigid Body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n```\n</implementation>"}
{"id": 124, "instruction": "Place an Active 2x2x3 cube at (3, 7, 3) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create an active rigid body cube with specific dimensions, location, and orientation. This involves precise geometric modeling and physics property assignment. Since it's an active rigid body, it will respond to gravity and collisions. The rotation of 90° around the X-axis means the cube's local coordinate system will be rotated relative to the world.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 2 units (X), 2 units (Y), 3 units (Z) in its local space.\n- World location: (3, 7, 3). The Z=3 means the base will be at Z=1.5 if centered (since height=3).\n- Rotation: 90° around X-axis = π/2 radians. This rotates the cube so its local Z-axis aligns with world -Y direction.\n- Since the cube is created centered at origin by default, after rotation and translation, the geometric center will be at (3,7,3).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single active rigid body with no joints or hierarchy)\n- The cube is a standalone mesh with rigid body physics active.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: The cube's center of mass is at its geometric center (3,7,3). With 90° X rotation, the long dimension (3 units) now lies along world -Y axis.\n- Mitigation: Default rigid body settings (mass=1kg, friction=0.5) are sufficient for basic simulation.\n- Stability: As an active rigid body, it will fall under gravity unless supported.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 3.0)\n- cube_location: (3.0, 7.0, 3.0)\n- cube_rotation_x_degrees: 90.0\n- cube_rotation_x_radians: 1.57079632679\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with unit dimensions initially\nbpy.ops.mesh.primitive_cube_add(size=1.0)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply dimensions (scale) to achieve 2x2x3\ncube.dimensions = (2.0, 2.0, 3.0)\n\n# Set location and rotation\ncube.location = (3.0, 7.0, 3.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optional: Set mass based on volume (assuming density 1 kg/m³)\n# Volume = 2*2*3 = 12 cubic units\ncube.rigid_body.mass = 12.0\n\nprint(f\"Created active cube at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 127, "instruction": "Place a Passive 3x1x2 cube at (-3, 0, 5) and rotate it 10° on the X-axis.", "answer": "<strategic_analysis>\nThis task involves creating a static passive rigid body with specific dimensions, location, and orientation. The 10° X-axis rotation will tilt the cube forward, creating an inclined surface. This could serve as a ramp, platform, or obstacle in a physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Target Location: (-3, 0, 5) meters in world coordinates.\n- Dimensions: Width (X) = 3m, Depth (Y) = 1m, Height (Z) = 2m.\n- Rotation: 10° about X-axis = 10 × (π/180) ≈ 0.174533 radians.\n- Cube center position: Since the default Blender cube is centered, the location parameter places the geometric center at (-3, 0, 5).\n- The rotation will make the top face slope downward in the positive Z direction.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Single static rigid body with no parent)\n- No joints or constraints needed (passive rigid body)\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed in world space.\n- The 10° tilt creates an inclined plane with slope tan(10°) ≈ 0.176, which could cause other objects to slide off.\n- With center at Z=5 and height=2m, the highest point is at Z=6m (top edge) and lowest at Z=4m (bottom edge).\n- No stability concerns since it's static and anchored.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (-3.0, 0.0, 5.0)\n- cube_dimensions: (3.0, 1.0, 2.0)\n- cube_rotation_x_degrees: 10.0\n- cube_scale_factors: (1.5, 0.5, 1.0)  # From default 2m cube\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Scale to desired dimensions (3×1×2)\n# Default cube is 2m, so scale factors = desired/2\ncube.scale = (1.5, 0.5, 1.0)  # (3/2, 1/2, 2/2)\n\n# Apply scale to avoid shearing\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-3.0, 0.0, 5.0)\ncube.rotation_euler = (math.radians(10.0), 0.0, 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set collision margin for stability\ncube.rigid_body.collision_margin = 0.0\n```\n</implementation>"}
{"id": 123, "instruction": "Place a Passive 1x4x1 cube at (0, 0, 6) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static passive rigid body obstacle with specified dimensions, location, and orientation. This cube can serve as a ramp, barrier, or platform in a physics simulation. Its 60-degree tilt around the Y-axis creates an inclined plane, which could be used for rolling objects or dynamic interactions.\n</strategic_analysis>\n\n<spatial_layout>\n- Target cube dimensions: width (X) = 1m, length (Y) = 4m, height (Z) = 1m.\n- Default Blender cube is 2x2x2, so required scale factors: (1/2, 4/2, 1/2) = (0.5, 2.0, 0.5).\n- Location: (0.0, 0.0, 6.0) in world coordinates.\n- Rotation: 60° around the Y-axis. Converted to radians: 60 * (π/180) ≈ 1.0472 rad.\n- After scaling and rotation, the cube's local Z-height is 1m, so its bottom face will be at Z = 6.0 - 0.5 = 5.5m and top face at Z = 6.0 + 0.5 = 6.5m.\n</spatial_layout>\n\n<kinematic_topology>\n- World -> PassiveCube (static mesh, no parent, passive rigid body).\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed during simulation, providing a stable inclined surface.\n- The 60° incline may cause dynamic objects to slide or roll with significant acceleration due to gravity.\n- No risk of tipping or movement since the cube is passive and anchored.\n</predictive_simulation>\n\n<parameter_summary>\ncube_scale: (0.5, 2.0, 0.5)\ncube_location: (0.0, 0.0, 6.0)\ncube_rotation_y_degrees: 60.0\ncube_rotation_y_radians: 1.0471975511965976\ncube_dimensions: (1.0, 4.0, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0.0, 0.0, 0.0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Scale to achieve 1x4x1 dimensions\ncube.scale = (0.5, 2.0, 0.5)\n\n# Apply scale to mesh data for accurate physics\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 0.0, 6.0)\ncube.rotation_euler = (0.0, radians(60.0), 0.0)\n\n# Add rigid body and set to passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 128, "instruction": "Place an Active 1x5x1 cube at (2, 9, 2) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a single dynamic object with specific dimensions, location, and orientation. The cube is defined as \"Active\" which in Blender's rigid body physics context means it will be affected by gravity and collisions. The 1x5x1 dimensions suggest a rectangular prism shape elongated along the Y-axis (if considering default cube orientation). The rotation of 90° around Z-axis will orient this elongated dimension. No complex mechanisms or multi-body systems are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 1m (X) × 5m (Y) × 1m (Z). Default Blender cube is 2×2×2m, so scaling factors are (0.5, 2.5, 0.5).\n- Location: World coordinates (2, 9, 2) places cube center at this point.\n- Rotation: 90° around Z-axis converts to radians: 90° × (π/180) = 1.5708 rad. This rotates the local X-axis to align with world negative Y, and local Y to align with world X.\n- Volume: 1×5×1 = 5 m³.\n- Mass: Assuming uniform density, mass = density × volume. We'll use default rigid body density (500 kg/m³) → mass = 2500 kg.\n</spatial_layout>\n\n<kinematic_topology>\nFlat hierarchy:\n- world → dynamic_cube (Single active rigid body with no joints or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Single object placement is inherently stable if gravity is aligned with world -Z.\n- Dynamic Risks: As an active rigid body, the cube will immediately fall due to gravity unless supported. At Z=2, it has potential energy mgh = 2500×9.8×2 = 49kJ.\n- Collision Geometry: The rotated elongated shape may cause unexpected tumbling if interacting with other objects.\n- Mitigation: Consider adding a large passive plane below to catch the falling cube if simulation is run.\n</predictive_simulation>\n\n<parameter_summary>\ncube_location: (2.0, 9.0, 2.0)\ncube_rotation_z_deg: 90.0\ncube_dimensions: (1.0, 5.0, 1.0)\ncube_scale: (0.5, 2.5, 0.5)\ncube_mass: 2500.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2×2×2m)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube_1x5x1\"\n\n# Apply dimensions via scale (default cube is 2m per side)\n# To get 1m in X: 1/2 = 0.5, 5m in Y: 5/2 = 2.5, 1m in Z: 1/2 = 0.5\ncube.scale = (0.5, 2.5, 0.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (2.0, 9.0, 2.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 2500.0  # 500 kg/m³ × 5 m³\n\n# Optional: Add ground plane for simulation\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nplane = bpy.context.active_object\nplane.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nplane.rigid_body.type = 'PASSIVE'\n\n# Set gravity to realistic Earth value (optional)\nbpy.context.scene.use_gravity = True\nbpy.context.scene.gravity = (0.0, 0.0, -9.81)\n```\n</implementation>"}
{"id": 132, "instruction": "Place an Active 4x2x1 cube at (5, 6, -1) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body cube with specific non-uniform dimensions (4x2x1), precise world-space positioning at (5, 6, -1), and a 25-degree rotation about the X-axis. This is a foundational rigid body modeling exercise. The cube must be active to respond to physics simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (Width, Depth, Height): (4.0, 2.0, 1.0) meters.\n- World Location: (x, y, z) = (5.0, 6.0, -1.0).\n- Rotation: 25° about the local X-axis. Convert to radians: 25 * (π/180) = 0.436332 radians.\n- Scaling Strategy: Default Blender cube primitive (size=2) has object-space dimensions 2x2x2. To achieve 4x2x1, apply scale factors: (4/2, 2/2, 1/2) = (2.0, 1.0, 0.5).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single Active Rigid Body with no parent-child hierarchy).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a single active body, the cube will respond to gravity. With no passive floor, it will fall indefinitely in simulations.\n- Collision Geometry: The non-uniform scaling and rotation will affect the collision mesh orientation.\n- Risk: None beyond basic rigid body dynamics.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 2.0, 1.0)\n- cube_location: (5.0, 6.0, -1.0)\n- cube_rotation_x_deg: 25.0\n- cube_rotation_x_rad: 0.436332\n- cube_scale_factors: (2.0, 1.0, 0.5)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2 in object space)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply dimensions via scale (4x2x1 in world space)\ncube.scale = (2.0, 1.0, 0.5)  # From parameter_summary\n\n# Set location and rotation\ncube.location = (5.0, 6.0, -1.0)\ncube.rotation_euler = (0.436332, 0.0, 0.0)  # 25° on X-axis\n\n# Apply transformations (finalize scale/rotation)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Add Active Rigid Body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optional: Set mass proportional to volume (4*2*1 = 8 m³). Density ~1 kg/m³.\ncube.rigid_body.mass = 8.0\n```\n</implementation>"}
{"id": 133, "instruction": "Place a Passive 1x1x2 cube at (1, 0, 6) and rotate it 180° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a simple passive rigid body cube with specific dimensions, location, and rotation. This is a foundational 3D modeling exercise that tests precision in object placement and orientation. The cube will serve as a static environmental object in a physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 1m × 1m × 2m (X, Y, Z).\n- World location: (1, 0, 6) in meters.\n- Rotation: 180° around Y-axis = π radians (3.14159 rad).\n- The cube's pivot point (origin) will be at its geometric center.\n- Since the cube is 2m tall, its bottom face will be at Z = 5m and top face at Z = 7m when unrotated.\n- After 180° Y rotation, the cube's local coordinate system flips, but its world bounds remain identical due to symmetry.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body with no joints or hierarchy.\n- Direct parent: World (no transformation inheritance).\n- Rigid body type: PASSIVE (static, infinite mass).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Perfectly stable as a passive object anchored in world space.\n- Collision: The cube's bounding box will correctly represent its oriented dimensions for physics.\n- Risk: None for this static placement.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 1.0, 2.0)\n- cube_location: (1.0, 0.0, 6.0)\n- cube_rotation_y_degrees: 180.0\n- cube_rotation_y_radians: 3.14159\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects (optional cleanup)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create base cube (default 1m³ at origin)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply dimensions: scale in Z direction for 2m height\ncube.scale = (1.0, 1.0, 2.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (1.0, 0.0, 6.0)\ncube.rotation_euler = (0.0, math.pi, 0.0)  # 180° around Y\n\n# Add rigid body physics as PASSIVE\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set display properties for clarity\ncube.display_type = 'SOLID'\nbpy.context.space_data.shading.type = 'SOLID'\n```\n</implementation>"}
{"id": 129, "instruction": "Place a Passive 2x1x2 cube at (4, 0, 4) and rotate it 33° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves creating a passive rigid body cube with specific dimensions, location, and orientation. This is a straightforward static object placement exercise requiring precise geometric transformation. The cube's passive rigid body property ensures it remains immovable during simulations, serving as an obstacle or platform. The 33° Y-axis rotation must be correctly applied in radians.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X)=2m, Height (Y)=1m, Depth (Z)=2m\n- World Location: (4, 0, 4) in global coordinates\n- Rotation: 33° around Y-axis = 33 × π/180 ≈ 0.5760 radians\n- Origin: Cube center at specified location\n- Note: Blender's default cube primitive has 2m sides when added with size=2. We'll scale appropriately.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Static mesh with passive rigid body)\n- No joints or hierarchy needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is passive with infinite mass, will not move under collisions\n- Collision Geometry: Box shape matches visual mesh exactly\n- Placement Risk: None beyond ensuring correct transform\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 1.0, 2.0)\n- cube_location: (4.0, 0.0, 4.0)\n- cube_rotation_y_degrees: 33.0\n- cube_rotation_y_radians: 0.5760\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional but good practice)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions\n# Default Blender cube with size=1 gives 2x2x2 vertices\n# We'll scale to achieve exact 2x1x2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scaling for exact dimensions (scale factors multiply the base 2x2x2)\n# Target: (2, 1, 2) from base (2, 2, 2) → scale = (1.0, 0.5, 1.0)\ncube.scale = (1.0, 0.5, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set final transform\ncube.location = (4.0, 0.0, 4.0)\ncube.rotation_euler = (0.0, math.radians(33.0), 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set display properties for clarity\ncube.data.materials.clear()\nmat = bpy.data.materials.new(name=\"Passive_Mat\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blue tint\ncube.data.materials.append(mat)\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Y): {math.degrees(cube.rotation_euler.y):.1f}°\")\n```\n</implementation>"}
{"id": 135, "instruction": "Place a Passive cylinder (radius 1, height 2) at (3, 0, -3) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis task involves creating a simple static object in 3D space with precise positioning and orientation. The cylinder will serve as a passive obstacle or environmental element. The main considerations are exact coordinate placement, axis-aligned rotation, and proper rigid body physics setup for future simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center at world coordinates: (3.0, 0.0, -3.0)\n- Base radius: 1.0 unit (diameter: 2.0 units)\n- Height: 2.0 units (extends from z = -4.0 to z = -2.0 at rotation 0)\n- Y-axis rotation: 45° = 0.785398 radians\n- Transform order: First scale for dimensions, then rotation, then translation\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Single static mesh with passive rigid body)\n- No joints or constraints required\n- Local origin at cylinder center\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, cylinder will remain fixed in place\n- Collision: Cylinder will interact with active rigid bodies with proper collision detection\n- Center of mass: At geometric center (0,0,0 in local space)\n- Risk: None for this static placement\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (3.0, 0.0, -3.0)\n- cylinder_radius: 1.0\n- cylinder_height: 2.0\n- cylinder_rotation_y: 45.0 (degrees)\n- rigidbody_type: PASSIVE\n- rigidbody_collision_shape: CYLINDER\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=2.0,\n    location=(3.0, 0.0, -3.0),\n    rotation=(0.0, math.radians(45.0), 0.0)\n)\n\n# Get reference to the cylinder\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Assign rigid body properties\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'CYLINDER'\n\n# Verify transformation\nprint(f\"Cylinder created:\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation: {cylinder.rotation_euler}\")\nprint(f\"  Dimensions: {cylinder.dimensions}\")\nprint(f\"  Rigid Body Type: {cylinder.rigid_body.type}\")\nprint(f\"  Collision Shape: {cylinder.rigid_body.collision_shape}\")\n```\n</implementation>"}
{"id": 138, "instruction": "Place an Active sphere (radius 1.2) at (7, 6, 2) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement and orientation task. The core requirement is creating a rigid body sphere with specified geometry, location, and rotation. The sphere is active, meaning it will respond to physics forces like gravity. No complex assembly or constraints are needed, just a single primitive with correct transform and physics properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center location: (x, y, z) = (7.0, 6.0, 2.0)\n- Sphere radius: r = 1.2 m\n- Rotation: 60° about the global Y-axis. In radians: θ = 60 * (π/180) = 1.0471975511965976 rad.\n- Bounding box: From (7-1.2, 6-1.2, 2-1.2) to (7+1.2, 6+1.2, 2+1.2).\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent rigid body:\n- world -> sphere (Active Rigid Body)\nNo joints or hierarchies.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will immediately fall under gravity from its starting height (z=2.0).\n- The rotation is purely visual/orientational for the mesh; physics simulation treats it as a sphere (isotropic inertia).\n- No collision or stability risks beyond standard falling and bouncing.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.2\nsphere_location: (7.0, 6.0, 2.0)\nsphere_rotation_y_degrees: 60.0\nsphere_rotation_y_radians: 1.0471975511965976\nsphere_mass: 1.0 (default)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(7.0, 6.0, 2.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 60-degree rotation around Y-axis\nsphere.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n# Optional: Set mass (default is 1.0 kg)\nsphere.rigid_body.mass = 1.0\n```</implementation>"}
{"id": 139, "instruction": "Place a Passive cylinder (radius 0.5, height 4) at (-1, 0, -1) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires placing a stationary cylindrical obstacle with specific dimensions and orientation. Since the cylinder is passive (non-moving), we need to ensure it's properly positioned and rotated, then assigned as a passive rigid body for physical simulations. The key considerations are accurate translation, rotation conversion (degrees to radians), and rigid body setup.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center position: (-1.0, 0.0, -1.0)\n- Cylinder dimensions: radius = 0.5m, height = 4.0m\n- Rotation: 30° around X-axis (Euler rotation: (30°, 0°, 0°) in degrees)\n- The cylinder's local Z-axis will be tilted 30° from the global Z-axis after rotation\n- Base alignment: Default cylinder in Blender is centered at origin with height along Z-axis\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n- No joints or constraints needed for passive object\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive object, the cylinder will act as an immovable obstacle in physics simulations\n- The 30° tilt may affect how other objects slide or roll against its surface\n- Mass properties are irrelevant for passive rigid bodies, but collision shape should match visual mesh\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (-1.0, 0.0, -1.0)\n- cylinder_radius: 0.5\n- cylinder_height: 4.0\n- rotation_x_degrees: 30.0\n- rotation_x_radians: 0.523599\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.5,\n    depth=4.0,\n    location=(-1.0, 0.0, -1.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply rotation (30° around X-axis)\ncylinder.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\ncylinder.rigid_body.use_margin = True\ncylinder.rigid_body.collision_margin = 0.0\n\n# Ensure smooth shading for better visualization\nbpy.ops.object.shade_smooth()\n\nprint(f\"Created passive cylinder at {cylinder.location}\")\nprint(f\"Rotation: {cylinder.rotation_euler}\")\n```\n</implementation>"}
{"id": 136, "instruction": "Place an Active 2x4x1 cube at (0, 8, 2) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a dynamically simulated rectangular prism with specified dimensions, position, and orientation. This is a fundamental rigid body manipulation exercise requiring precise geometric transformations. The cube must be set as an \"Active\" rigid body, meaning it will respond to physics forces (gravity, collisions) rather than remaining static. The rotation around the X-axis will orient the longest dimension vertically if we interpret the dimensions correctly.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 2m, Height (Y) = 4m, Depth (Z) = 1m.\n- Location: Center at world coordinates (0, 8, 2).\n- Rotation: 90° around X-axis (π/2 radians). This transforms the local coordinate system.\n- Transformation order: Apply scaling first to achieve dimensions, then rotation, then translation to final position.\n- Default Blender cube (2m³) scaling factors: (1.0, 2.0, 0.5) to achieve 2x4x1 dimensions.\n- Post-rotation orientation: The original Y-axis (now scaled to 4m) becomes aligned with global Z-axis? Actually, a +90° X-rotation maps local Y to local -Z, and local Z to local Y.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world -> cube_object\n- No joints or constraints required.\n- The cube is an active rigid body with mass derived from volume and default density.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The rotated configuration may be unstable if placed on edge due to high center of mass.\n- Dynamic behavior: As an active rigid body, it will immediately fall under gravity unless supported.\n- Collision geometry: Mesh collision shape (convex hull) is appropriate for this rectangular shape.\n- No risk of self-collision or complex constraints.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 4.0, 1.0)\n- cube_location: (0.0, 8.0, 2.0)\n- cube_rotation_x_degrees: 90.0\n- cube_scale_factors: (1.0, 2.0, 0.5)\n- rigidbody_type: 'ACTIVE'\n- collision_shape: 'CONVEX_HULL'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube primitive (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube_2x4x1\"\n\n# Apply scaling to achieve 2x4x1 dimensions\n# Default cube vertices range from -1 to +1 in all axes (2m side length)\n# Scale factors: (2/2=1.0, 4/2=2.0, 1/2=0.5)\ncube.scale = (1.0, 2.0, 0.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Apply rotation (90° around X-axis)\ncube.rotation_euler[0] = math.radians(90.0)\nbpy.ops.object.transform_apply(rotation=True)\n\n# Set final location\ncube.location = (0.0, 8.0, 2.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'CONVEX_HULL'\ncube.rigid_body.mass = 10.0  # Reasonable default mass (2*4*1=8m³ * density)\n\n# Optional: Add a ground plane for stability demonstration\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Set viewport display for clarity\ncube.show_bounds = True\ncube.display_type = 'SOLID'\n```\n</implementation>"}
{"id": 134, "instruction": "Place an Active sphere (radius 0.8) at (-5, 5, 2) and rotate it 50° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires placing an active rigid body sphere at a specific location and orientation. Since the sphere is active, it will respond to physics (gravity, collisions). We'll create a basic environment with a ground plane to contain the sphere's motion. The 50° Z-axis rotation sets the initial orientation, which may affect bounce dynamics if the sphere has surface features, but for a uniform sphere, the rotation primarily sets angular momentum if initial spin is applied. We'll create a simple scene with clear visual distinction.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (-5, 5, 2)\n- Sphere radius: 0.8 m\n- Ground plane: Z = 0 plane, extending ±20m in X and Y to catch the sphere when it falls\n- Safety margin: Sphere starting at Z=2 ensures it's above ground and will fall under gravity (9.8 m/s²)\n- Rotation: 50° about global Z-axis (converted to radians: 50° × π/180 = 0.8727 rad)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> ground_plane (Passive Rigid Body, static)\n- world -> sphere (Active Rigid Body, dynamic)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere will fall from Z=2 to Z=0.8 (ground contact) in approximately √(2×height/g) = √(2×1.2/9.8) ≈ 0.5 seconds.\n- With default bounciness (0.5), it will bounce to reduced height each time.\n- The initial Z-rotation will be preserved (angular velocity = 0) since no torque is applied.\n- Risk: Sphere may roll off plane edges if bounces are energetic. Mitigation: Large ground plane (40×40 m).\n- Collision margin: Sphere radius 0.8 ensures stable collision detection with default margins.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.8\n- sphere_location: (-5.0, 5.0, 2.0)\n- sphere_rotation_z_deg: 50.0\n- sphere_mass: 5.0\n- ground_size: 40.0\n- ground_location: (0.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create ground plane\nbpy.ops.mesh.primitive_plane_add(size=40, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\nground.rigid_body.friction = 1.0\nground.rigid_body.restitution = 0.5\nground.data.materials.clear()\nmat_ground = bpy.data.materials.new(name=\"Ground_Material\")\nmat_ground.diffuse_color = (0.2, 0.4, 0.1, 1.0)\nground.data.materials.append(mat_ground)\n\n# Create sphere\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.8, location=(-5, 5, 2))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\nsphere.rotation_euler = (0, 0, math.radians(50))  # 50° about Z-axis\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 5.0\nsphere.rigid_body.friction = 0.4\nsphere.rigid_body.restitution = 0.7\nsphere.data.materials.clear()\nmat_sphere = bpy.data.materials.new(name=\"Sphere_Material\")\nmat_sphere.diffuse_color = (0.8, 0.2, 0.2, 1.0)\nsphere.data.materials.append(mat_sphere)\n\n# Set up world physics\nbpy.context.scene.gravity = (0, 0, -9.8)\nbpy.context.scene.rigidbody_world.steps_per_second = 60\nbpy.context.scene.rigidbody_world.solver_iterations = 10\n\n# Add lighting\nbpy.ops.object.light_add(type='SUN', location=(10, 10, 20))\nsun = bpy.context.active_object\nsun.data.energy = 2.0\n\n# Add camera for better view\nbpy.ops.object.camera_add(location=(15, -15, 10))\ncamera = bpy.context.active_object\ncamera.rotation_euler = (math.radians(63.4), 0, math.radians(45))\nbpy.context.scene.camera = camera\n\n# Set render engine for better visualization\nbpy.context.scene.render.engine = 'BLENDER_EEVEE'\n```\n</implementation>"}
{"id": 137, "instruction": "Place a Passive 3x2x2 cube at (-2, 0, -5) and rotate it 15° on the Z-axis.", "answer": "<strategic_analysis>\nThis task involves creating a single static mesh with specific transformations and rigid body properties. The 3x2x2 cube dimensions represent its bounding box extents. Since it's passive rigid body physics, it will act as immovable collision geometry. The Z-axis rotation of 15° applies in the global coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 3m (X) × 2m (Y) × 2m (Z)\n- Location coordinates: X = -2.0m, Y = 0.0m, Z = -5.0m\n- Rotation: 15° around global Z-axis = 0.261799 radians\n- Since Blender's default cube has radius 1 (diameter 2), scale factors are:\n  Scale_X = 3/2 = 1.5\n  Scale_Y = 2/2 = 1.0  \n  Scale_Z = 2/2 = 1.0\n- The cube's center will be at (-2, 0, -5) with local origin at geometric center\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world → passive_cube (Mesh with Passive Rigid Body)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body with default mass, the cube will remain fixed.\n- Collision: The 15° rotation will affect collision normals and interactions with active bodies.\n- Coordinate System: Location in negative Z places it below default scene origin, which may affect camera visibility.\n</predictive_simulation>\n\n<parameter_summary>\ncube_location: (-2.0, 0.0, -5.0)\ncube_dimensions: (3.0, 2.0, 2.0)\ncube_rotation_z_deg: 15.0\ncube_rotation_z_rad: 0.261799\ncube_scale: (1.5, 1.0, 1.0)\nrigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Vector, Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default dimensions (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply transformation based on parameters\ncube.location = Vector((-2.0, 0.0, -5.0))\ncube.scale = Vector((1.5, 1.0, 1.0))\ncube.rotation_euler = Euler((0.0, 0.0, 15.0 * math.pi / 180.0), 'XYZ')\n\n# Add rigid body physics with PASSIVE type\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Verify dimensions\nprint(f\"Cube created at: {cube.location}\")\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube scale: {cube.scale}\")\nprint(f\"Rigid body type: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 141, "instruction": "Place a Passive 1x2x3 cube at (-6, 0, 1) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a basic rigid body placement task requiring precise geometric positioning and orientation. The primary considerations are: 1) Creating a rectangular prism with specified dimensions (1x2x3 units), 2) Positioning it at exact coordinates (-6, 0, 1), 3) Applying a 45° rotation around the Y-axis, and 4) Configuring it as a passive rigid body for physical simulation stability. No complex kinematic relationships or dynamic calculations are needed beyond the initial transform.\n</strategic_layout>\n\n<spatial_layout>\n- Default Blender cube dimensions: 2×2×2 units\n- Target dimensions: width (X)=1, depth (Y)=2, height (Z)=3\n- Scaling factors: (1/2, 2/2, 3/2) = (0.5, 1, 1.5)\n- Target location: (-6, 0, 1) in world coordinates\n- Target rotation: 45° around Y-axis = 0.785398 radians\n- Origin point: Cube's geometric center will be at specified location after transform\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world -> passive_cube (Static mesh with passive rigid body)\nNo joints or parent-child relationships required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Passive rigid body with infinite mass ensures complete immobility\n- Risk: None for this static placement\n- Collision: Default box collision shape matches visual geometry exactly\n- Ground clearance: Z=1 position places cube's bottom at (1 - 3/2) = -0.5 units, intersecting ground plane if present\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 3.0)\n- cube_location: (-6.0, 0.0, 1.0)\n- cube_rotation_y: 45.0 (degrees)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create base cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scaling for target dimensions (1x2x3)\ncube.scale = (0.5, 1.0, 1.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (-6.0, 0.0, 1.0)\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Add rigid body physics (passive)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 142, "instruction": "Place an Active sphere (radius 2) at (0, 9, 8) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nWe need to create a single active rigid body sphere with specified geometry and pose. This involves clearing the scene, adding a UV sphere primitive, setting its radius and location, applying a rotation transformation, and configuring rigid body physics. The main considerations are correct unit handling and ensuring the rigid body is active (dynamic).\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center position: (X=0.0, Y=9.0, Z=8.0) in world coordinates.\n- Sphere radius: 2.0 Blender units.\n- Rotation: 90° about the X-axis, meaning the sphere's local coordinate system is rotated. Since a sphere is isotropic, rotation won't change its visual appearance, but it will affect the orientation of any non-uniform textures or child objects.\n- No additional geometric constraints or obstacles are specified.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body node: sphere_object.\n- No joints or hierarchical constraints.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will respond to gravity and collisions if a simulation is run.\n- With default gravity (-9.81 m/s² on Z-axis), the sphere will fall from Z=8.0.\n- No stability risks for a single free body.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.0\n- sphere_location: (0.0, 9.0, 8.0)\n- sphere_rotation_degrees: (90.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a UV sphere with radius 2\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.0, location=(0.0, 9.0, 8.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply rotation: 90 degrees about X-axis\nsphere.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\n\nprint(f\"Created active sphere at {sphere.location} with radius 2.0\")\n```\n</implementation>"}
{"id": 143, "instruction": "Place a Passive cylinder (radius 1.5, height 2) at (2, 0, -2) and rotate it 10° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a passive static cylinder with precise dimensional and positional specifications. This is a foundational static scene setup task requiring accurate geometric placement. The cylinder will serve as an immovable obstacle or structural element in a larger physical simulation context.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.5 units\n- Cylinder height: 2.0 units\n- Translation vector: T = (2.0, 0.0, -2.0)\n- Rotation specification: 10° counterclockwise about the global Z-axis\n- Rotation in radians: θ = 10° × (π/180°) = 0.174532925 radians\n- Cylinder base center at (2.0, 0.0, -2.0) with top at (2.0, 0.0, 0.0) before rotation\n</spatial_layout>\n\n<kinematic_topology>\n- world (Global coordinate system)\n- passive_cylinder (Static rigid body with no parent, no joints)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cylinder is immovable and inherently stable\n- Collision geometry: Cylinder mesh provides continuous collision surface\n- Center of mass: Located at geometric center (2.0, 0.0, -1.0) after rotation\n, rotation doesn't affect COM position for homogeneous cylinder\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 1.5\ncylinder_height: 2.0\nlocation_x: 2.0\nlocation_y: 0.0\nlocation_z: -2.0\nrotation_z_degrees: 10.0\nrotation_z_radians: 0.174532925\nrigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.5,\n    depth=2.0,\n    location=(2.0, 0.0, -2.0),\n    rotation=(0.0, 0.0, math.radians(10.0))\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"passive_cylinder\"\n\n# Apply rotation and scale (ensures clean transforms)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Verify properties\nprint(f\"Cylinder created:\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation (Euler): {cylinder.rotation_euler}\")\nprint(f\"  Radius: {cylinder.dimensions.x/2}\")\nprint(f\"  Height: {cylinder.dimensions.z}\")\n```\n</implementation>"}
{"id": 140, "instruction": "Place an Active 5x2x1 cube at (6, 7, 2) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a simple rigid body cube with specified dimensions, position, and orientation. The cube must be set as an \"active\" rigid body, meaning it will respond to physics simulations (gravity, collisions, etc.). This requires creating a mesh object, transforming it, and applying appropriate rigid body physics settings.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (width, depth, height): 5m (X), 2m (Y), 1m (Z)\n- World position: (6, 7, 2)\n- Rotation: 20° around global Z-axis (0.349066 radians)\n- Origin point: Default cube origin at its geometric center\n- Note: Blender's default cube has 2m sides. We'll scale it by (2.5, 1, 0.5) to achieve 5×2×1 dimensions.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body: cube_object\n- No parent-child hierarchy needed\n- Rigid body type: ACTIVE (responds to physics forces)\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will immediately fall under gravity when simulation starts\n- The 20° Z-rotation will affect its initial orientation when falling\n- No stability concerns for a single free-falling object\n- Collision shape: BOX (matches mesh geometry exactly)\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (5.0, 2.0, 1.0)\n- cube_location: (6.0, 7.0, 2.0)\n- cube_rotation_z: 20.0 (degrees)\n- rigidbody_type: ACTIVE\n- collision_shape: BOX\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default dimensions (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Scale to achieve 5×2×1 dimensions\n# Default cube has vertices at ±0.5 in all axes, so scaling factors are:\n# X: 5.0/1.0 = 5.0, Y: 2.0/1.0 = 2.0, Z: 1.0/1.0 = 1.0\ncube.scale = (5.0, 2.0, 1.0)\n\n# Apply scale to make transformations clean\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set position and rotation\ncube.location = (6.0, 7.0, 2.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Ensure proper display of dimensions\ncube.show_bounds = True\ncube.display_type = 'SOLID'\n```\n</implementation>"}
{"id": 146, "instruction": "Place an Active sphere (radius 1) at (5, 8, 5) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single dynamic sphere in a 3D environment. The sphere must be placed at a specific world coordinate and rotated about the Z-axis. Since it's designated as \"Active,\" it should be a dynamic rigid body capable of responding to physics forces. The rotation is a one-time initial orientation, not an animation. The implementation will focus on precise object creation, transformation, and physics property assignment.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: X=5.0m, Y=8.0m, Z=5.0m.\n- Sphere radius: 1.0m.\n- Rotation: 120° about the global Z-axis. Conversion to radians: 120 * (π/180) = 2.09439510239 rad.\n- Since the rotation is applied in object mode, the sphere's local Z-axis rotation will be set to this value.\n- No collisions or interactions are specified, so default rigid body collision shape (sphere) and mass (calculated from density) are sufficient.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single rigid body with no joints or constraints)\n- The sphere is a standalone dynamic entity with all transformations applied directly to the object.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a single sphere in space, there are no stability concerns.\n- Dynamic Risk: The sphere will fall under gravity unless the scene gravity is disabled. This is acceptable for an \"Active\" rigid body.\n- Collision: Default collision margin may cause the sphere to appear slightly larger than 1m radius in physics simulations.\n- Mitigation: Use rigid body collision shape set to \"Sphere\" and match the radius exactly.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.0\nsphere_location: (5.0, 8.0, 5.0)\nsphere_rotation_z_degrees: 120\nsphere_rotation_z_radians: 2.09439510239\nrigid_body_type: ACTIVE\ncollision_shape: SPHERE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with radius 1.0\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.0, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply transformations from parameter summary\nsphere.location = (5.0, 8.0, 5.0)\nsphere.rotation_euler = (0.0, 0.0, 2.09439510239)  # 120 degrees in Z\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\nsphere.rigid_body.use_margin = True\nsphere.rigid_body.collision_margin = 0.0  # Exact sphere radius\n\n# Optional: Set mass based on volume (density ~1)\n# Volume = 4/3 * π * r^3 = 4.18879 m³\n# Mass = density * volume = 1.0 * 4.18879 ≈ 4.19 kg\nsphere.rigid_body.mass = 4.18879\n\n# Ensure smooth shading for visual clarity\nbpy.ops.object.shade_smooth()\n```\n</implementation>"}
{"id": 147, "instruction": "Place a Passive cylinder (radius 2, height 3) at (-7, 0, 2) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical obstacle for a physics simulation. This cylinder will serve as a passive collision object that other active rigid bodies can interact with. The specific placement and rotation will allow it to function as an inclined barrier or ramp-like structure in the scene.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 2.0 units\n- Cylinder height: 3.0 units  \n- Center location: (-7.0, 0.0, 2.0)\n- The cylinder's base will be at Z = 2.0 - (height/2) = 0.5, and top at Z = 3.5\n- Rotation: 25° about the X-axis (0.43633 radians)\n- The 2-unit radius creates a 4-unit diameter obstacle\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Single rigid body, no joints or hierarchy)\n- The cylinder is a passive rigid body that won't move during simulation\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive object, the cylinder will remain fixed during physics simulation\n- The 25° X-axis rotation creates an inclined surface that may cause objects to slide or roll\n- With center at Z=2 and height=3, the cylinder extends from Z=0.5 to Z=3.5, making it partially embedded in the ground plane\n- Risk: If other objects interact with it, they may get stuck under the inclined surface\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.0\n- cylinder_height: 3.0\n- cylinder_location: (-7.0, 0.0, 2.0)\n- cylinder_rotation_x_degrees: 25.0\n- cylinder_rotation_x_radians: 0.436332\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.0,\n    depth=3.0,\n    location=(-7.0, 0.0, 2.0),\n    rotation=(math.radians(25.0), 0.0, 0.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add rigid body physics (passive)\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Ensure proper shading\nbpy.ops.object.shade_smooth()\n\nprint(f\"Created passive cylinder: {cylinder.name}\")\nprint(f\"Location: {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.x):.1f}° on X-axis\")\n```\n</implementation>"}
{"id": 144, "instruction": "Place an Active 2x3x2 cube at (-3, 7, 3) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body cube with specific dimensions, location, and rotation. Since this involves no complex mechanisms or interactions beyond basic rigid body physics, the implementation focuses on precise geometric placement and proper physics property assignment. The cube should be created as an active rigid body to respond to gravity and collisions if other objects exist in the scene.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width=2.0m (X), Depth=3.0m (Y), Height=2.0m (Z)\n- Cube location: World coordinates (-3.0, 7.0, 3.0)\n- Cube rotation: 35° rotation about the X-axis (converted to radians: 35 * π/180 = 0.610865 rad)\n- Cube center: Default Blender cube center is at geometric center (0,0,0) relative to object origin\n- No scaling needed since dimensions will be set directly\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (Single rigid body with no joints or constraints)\n- Rigid body type: ACTIVE to respond to physics\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: With gravity enabled (default -9.8 m/s² Z), the cube will fall from Z=3.0m.\n- Stability: As an isolated object, the cube has no stability concerns.\n- Collision: The cube's collision shape should match its visual mesh for accurate physics.\n- Rotation: 35° X-rotation will be applied initially, affecting how it lands if dropped.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 3.0, 2.0)\n- cube_location: (-3.0, 7.0, 3.0)\n- cube_rotation_x_deg: 35.0\n- cube_rotation_x_rad: 0.610865\n- rigidbody_type: ACTIVE\n- rigidbody_mass: 1.0\n- collision_shape: BOX\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with unit dimensions (Blender default is 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Set dimensions (scale from unit cube)\ncube.dimensions = (2.0, 3.0, 2.0)\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-3.0, 7.0, 3.0)\ncube.rotation_euler = (math.radians(35.0), 0.0, 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0\ncube.rigid_body.collision_shape = 'BOX'\n\n# Update scene\nbpy.context.view_layer.update()\n\nprint(f\"Created active cube '{cube.name}'\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {[math.degrees(r) for r in cube.rotation_euler]}\")\nprint(f\"  Rigid Body: {cube.rigid_body.type}, Mass: {cube.rigid_body.mass}\")\n```\n</implementation>"}
{"id": 145, "instruction": "Place a Passive 4x1x2 cube at (1, 0, -4) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires placing a static, non-moving object (Passive rigid body) with specific dimensions, position, and orientation. This is a straightforward 3D modeling task with no dynamic simulation requirements beyond rigid body definition. The primary consideration is ensuring the cube's local coordinate system matches the world coordinate system after applying the rotation transformation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 4m, Depth (Y) = 1m, Height (Z) = 2m.\n- World Position: (1.0, 0.0, -4.0) in meters.\n- Rotation: 75° around the global Y-axis (up axis). Converted to radians: 75° × (π/180) ≈ 1.30899694 rad.\n- Since the default Blender cube is 2×2×2 meters, scaling factors are: X = 4/2 = 2.0, Y = 1/2 = 0.5, Z = 2/2 = 1.0.\n- The cube's center point will be at the specified location after transformation.\n</spatial_layout>\n\n<kinematic_topology>\n- World → cube_passive (Static Mesh with Passive Rigid Body)\n- No joints or hierarchies required for this static object.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cube is passive and won't move unless acted upon by active rigid bodies.\n- Risk: None, as it's a fixed geometric placement task.\n- Validation: Verify that the rotation is applied correctly (Y-axis) and that rigid body properties are set to PASSIVE.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 1.0, 2.0)\n- cube_location: (1.0, 0.0, -4.0)\n- cube_rotation_y_degrees: 75.0\n- cube_rotation_y_radians: 1.30899694\n- cube_scale_factors: (2.0, 0.5, 1.0)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube primitive (default 2x2x2 at origin)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"cube_passive\"\n\n# Apply scale to achieve 4x1x2 dimensions\ncube.scale = (2.0, 0.5, 1.0)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (1.0, 0.0, -4.0)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Add rigid body physics (Passive)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set display to show wireframe for clarity\ncube.show_wire = True\ncube.show_all_edges = True\n```\n</implementation>"}
{"id": 148, "instruction": "Place an Active 3x3x3 cube at (2, 9, 2) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a simple object placement task requiring precise location, scale, and rotation. The cube must be positioned in 3D space with an active rigid body for physics simulation. Since no additional context is provided about the environment or purpose, I will create a clean scene with default physics properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 3m × 3m × 3m (scale factor 3.0)\n- Cube Location: (x=2.0m, y=9.0m, z=2.0m)\n- Cube Rotation: 45° around Y-axis = 0.785398 radians (π/4)\n- Note: Blender's default cube is 2×2×2 meters, so scaling by 1.5 achieves 3×3×3 meters\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (single rigid body with no parent-child relationships)\n- No joints or constraints required for this static placement\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will fall under gravity if not supported\n- With only default floor plane, cube will fall 2 meters and come to rest on floor\n- Rotation doesn't affect stability since cube is symmetric\n- No collision risks given current scene setup\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: 3.0\n- cube_location: (2.0, 9.0, 2.0)\n- cube_rotation_y: 45.0\n- cube_mass: 1.0 (default)\n- cube_friction: 0.5 (default)\n- cube_bounce: 0.0 (default)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default floor plane for physics context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nfloor = bpy.context.active_object\nfloor.name = \"Floor\"\nbpy.ops.rigidbody.object_add()\nfloor.rigid_body.type = 'PASSIVE'\n\n# Create the 3×3×3 cube\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(2.0, 9.0, 2.0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Scale to achieve 3m dimensions (default cube is 2m, scale by 1.5)\ncube.scale = (1.5, 1.5, 1.5)\n\n# Apply scale transformation\nbpy.ops.object.transform_apply(scale=True)\n\n# Rotate 45° around Y-axis\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Add active rigid body properties\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.0\n\n# Set up physics world with default gravity\nif bpy.context.scene.rigidbody_world is None:\n    bpy.ops.rigidbody.world_add()\nbpy.context.scene.rigidbody_world.enabled = True\nbpy.context.scene.rigidbody_world.collection = bpy.data.collections.new(\"PhysicsCollection\")\nbpy.context.scene.rigidbody_world.collection.objects.link(cube)\nbpy.context.scene.rigidbody_world.collection.objects.link(floor)\n\n# Verify transformations\nprint(f\"Cube created at location: {cube.location}\")\nprint(f\"Cube rotation (degrees): {math.degrees(cube.rotation_euler.y)}\")\nprint(f\"Cube dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 150, "instruction": "Place an Active sphere (radius 0.6) at (-4, 6, 0) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single rigid body sphere with specific geometric properties. The sphere must be placed at the designated coordinates with an initial rotational state. As an active rigid body, it will respond to physics simulations like gravity and collisions.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.6 units (given)\n- Center location: (-4, 6, 0) in world coordinates\n- Rotation: 60° around the X-axis\n- Since Blender uses radians: rotation_x = 60° × (π/180°) = 1.0472 rad\n- No geometric constraints or interactions with other objects specified\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body element:\n- world → sphere (active rigid body)\nNo joints or constraints required\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere will fall under gravity (if enabled) from initial height y=6\n- Initial X-rotation won't affect collision behavior due to spherical symmetry\n- No stability concerns for isolated sphere\n- Potential risk: If placed above other objects, may create dynamic collisions\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 0.6\nsphere_location: (-4.0, 6.0, 0.0)\nsphere_rotation_x: 60.0 (degrees)\nsphere_mass: 1.0 (default active rigid body)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with radius 0.6\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.6, location=(-4.0, 6.0, 0.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 60° rotation around X-axis (convert to radians)\nsphere.rotation_euler[0] = math.radians(60.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0\n\n# Set scene physics settings (gravity enabled by default)\nbpy.context.scene.frame_end = 250  # Extended simulation time\n\nprint(f\"Created active sphere at {sphere.location}\")\nprint(f\"Radius: {sphere.dimensions.x/2:.3f}\")\nprint(f\"X-rotation: {math.degrees(sphere.rotation_euler[0]):.1f}°\")\n```\n</implementation>"}
{"id": 151, "instruction": "Place a Passive cylinder (radius 1, height 5) at (3, 0, 0) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cylindrical obstacle with precise positioning and orientation. Since the cylinder is passive, it will not move in simulations, but its exact spatial placement is critical for interaction with other mechanisms.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center location: (3.0, 0.0, 0.0)\n- Cylinder height: 5.0m (extends 2.5m above and below the center)\n- Cylinder radius: 1.0m\n- Y-axis rotation: 15° (0.2618 radians). Rotation is applied around the object's origin (center).\n- Final world coordinate of top face center: (3.0, 0.0, 2.5) rotated 15° about global Y-axis → (3.0 + 2.5*sin(15°), 0.0, 2.5*cos(15°)) ≈ (3.647, 0.0, 2.415)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_passive (Static Mesh with Passive Rigid Body)\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None for static object. However, ensure the cylinder's passive rigid body property is set to prevent unintended movement during collisions.\n- Mitigation: Use a PASSIVE rigid body type and set appropriate collision margin.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (3.0, 0.0, 0.0)\n- cylinder_radius: 1.0\n- cylinder_height: 5.0\n- cylinder_rotation_y_deg: 15.0\n- cylinder_rotation_y_rad: 0.2617993877991494\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, but ensures clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=5.0,\n    location=(3.0, 0.0, 0.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Cylinder_Passive\"\n\n# Apply 15-degree rotation around Y-axis (convert to radians)\ncylinder.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add rigid body physics as passive\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'  # Use mesh for accurate collision\ncylinder.rigid_body.collision_margin = 0.04   # Standard margin\n\n# Ensure transformations are applied\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Optional: Visualize origin and axes for debugging\nbpy.ops.object.empty_add(type='ARROWS', location=(3.0, 0.0, 0.0))\norigin_marker = bpy.context.active_object\norigin_marker.name = \"Origin_Marker\"\norigin_marker.scale = (0.5, 0.5, 0.5)\n```\n</implementation>"}
{"id": 155, "instruction": "Place a Passive cylinder (radius 0.8, height 3) at (-3, 0, -2) and rotate it 120° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static cylindrical obstacle with specific dimensions, location, and orientation. As a passive object, it will not move during simulations but can interact with other rigid bodies. The key challenge is accurately applying the rotation in Blender's coordinate system where angles are in radians.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 0.8 units\n- Cylinder height: 3.0 units\n- World location: (-3.0, 0.0, -2.0)\n- Z-axis rotation: 120° = 120 × π/180 ≈ 2.0943951 radians\n- Base position offset: Since default cylinder origin is at its center, the given coordinates represent the cylinder's center point.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_passive (Static mesh with passive rigid body)\n- No joints or constraints needed for a passive object\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object with default physics, the cylinder will remain fixed regardless of collisions.\n- Risk: None - static placement ensures predictable behavior.\n- Verification: Confirm rotation is applied before rigid body setup to ensure proper collision geometry alignment.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.8\n- cylinder_height: 3.0\n- location_xyz: (-3.0, 0.0, -2.0)\n- rotation_z_radians: 2.0943951\n- rigid_body_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.8,\n    depth=3.0,\n    location=(-3.0, 0.0, -2.0),\n    rotation=(0.0, 0.0, 2.0943951)  # 120° in radians\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Assign passive rigid body properties\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Ensure proper display and collision settings\ncylinder.display_type = 'SOLID'\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 152, "instruction": "Place an Active 2x2x4 cube at (-2, 8, -6) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nWe need to create a single dynamic rigid body cube with specified dimensions, position, and orientation. The cube should be an \"active\" rigid body in Blender's physics system, meaning it will respond to forces and collisions. No additional constraints or environmental objects are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width=2m (X), depth=2m (Y), height=4m (Z)\n- World location: (-2, 8, -6) in global coordinates\n- Rotation: 30° around global Z-axis (converted to radians: 30° × π/180 ≈ 0.5236 rad)\n- Local origin: Default cube origin at geometric center, so final position places the cube's center at specified coordinates\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent rigid body: cube -> active dynamic object\n- No joints or parent-child relationships required\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube will fall under gravity if a floor exists (not created here)\n- Rotation around Z-axis tilts the cube, affecting its collision response and resting orientation\n- With default Blender gravity (9.81 m/s² Z-down), the cube will accelerate downward from Z=-6\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 4.0)\n- cube_location: (-2.0, 8.0, -6.0)\n- cube_rotation_z_deg: 30.0\n- rigidbody_type: 'ACTIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube primitive (default 2m³)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Set dimensions to 2×2×4 by scaling (scale = desired_size / default_size)\n# Default cube is 2×2×2, so scale Z by 2 to get 4m height\ncube.scale = (1.0, 1.0, 2.0)\n\n# Apply scale to make dimensions permanent in mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (-2.0, 8.0, -6.0)\n\n# Set rotation (convert 30° to radians)\ncube.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Default mass (adjustable)\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.1\n\n# Optional: Set collision shape to BOX (optimal for cubes)\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Created active cube at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 157, "instruction": "Place a Passive 2x5x1 cube at (-5, 0, 0) and rotate it 25° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a passive rigid body cube with specific dimensions, position, and orientation. This is a foundational exercise in rigid body simulation setup. The cube's passive designation means it will remain static during physics simulations, serving as a fixed environmental element. The 25° Y-axis rotation will tilt the cube, affecting collision interactions and visual placement.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 2m, Depth (Y) = 5m, Height (Z) = 1m.\n- World Position: (-5, 0, 0) in global coordinates.\n- Rotation: 25° around the global Y-axis. In radians: 25 * (π/180) ≈ 0.436332 radians.\n- Local Origin: Default cube origin at its geometric center.\n- Resulting Orientation: The cube's local X and Z axes are rotated 25° relative to the world X and Z axes.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Single mesh object with passive rigid body property, no joints or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object anchored at its location, it will be perfectly stable.\n- Collision Geometry: The rotation creates an inclined plane surface, which will correctly interact with active rigid bodies (e.g., cause objects to slide).\n- Risk: None. This is a standard static object placement.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 5.0, 1.0)\n- cube_location: (-5.0, 0.0, 0.0)\n- cube_rotation_y_deg: 25.0\n- cube_rotation_y_rad: 0.436332\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\n# Note: bpy.ops.mesh.primitive_cube_add creates a 2x2x2 cube by default, so we scale\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"passive_cube\"\n\n# Apply dimensions: scale the default 2x2x2 cube to 2x5x1\n# Since default cube is 2x2x2, scaling factor per axis is desired/2\ncube.scale = (2.0/2.0, 5.0/2.0, 1.0/2.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-5.0, 0.0, 0.0)\ncube.rotation_euler = (0.0, math.radians(25.0), 0.0)\n\n# Add rigid body property and set to passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX for optimal performance\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 158, "instruction": "Place an Active sphere (radius 1.8) at (2, 8, 2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nA single active sphere requires placement and rotation without complex mechanical interactions. The sphere's active rigid body property ensures it responds to physics forces. The transformation involves setting the location and applying a Z-axis rotation. Since it's a simple primitive, we create the sphere with specified radius, position it, then rotate it 45° about its local Z-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 1.8 units\n- Initial Position: (X=2.0, Y=8.0, Z=2.0)\n- Rotation: 45° about Z-axis, equivalent to 0.7854 radians\n- Sphere Center: The sphere's center coincides with its origin at the given coordinates\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single rigid body, no parent-child hierarchy)\n- Sphere has 6 degrees of freedom (3 translational, 3 rotational)\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere will immediately fall under gravity from Z=2.0 unless supported\n- Rotation about Z-axis affects initial orientation but not falling trajectory\n- No stability risks since it's a single object\n- Collision detection will use sphere's radius of 1.8 units\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.8\n- sphere_location: (2.0, 8.0, 2.0)\n- sphere_rotation_z: 45.0 (degrees)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.8, location=(2.0, 8.0, 2.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 45° rotation about Z-axis (convert to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\n\n# Adjust collision margin to match visual radius\nsphere.rigid_body.collision_margin = 0.0\n\nprint(f\"Created active sphere: {sphere.name}\")\nprint(f\"Radius: 1.8, Location: {sphere.location}, Rotation: {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 149, "instruction": "Place a Passive 1x1x5 cube at (0, 0, -6) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a static passive cube with specific dimensions, position, and orientation. This will serve as a simple static obstacle or structural element in a physics simulation. The cube needs to be sized 1×1×5 units, placed at coordinates (0, 0, -6), and rotated 90° around the Z-axis. As a passive rigid body, it will remain immovable during physics simulations, providing collision boundaries or platforms.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: width (X) = 1, depth (Y) = 1, height (Z) = 5\n- Original center position: (0, 0, -6)\n- Rotation: 90° around Z-axis = π/2 radians\n- After rotation, the cube's local axes transform: \n  X' = -Y, Y' = X, Z' = Z (right-hand rule rotation)\n- The bounding box corners remain centered at (0,0,-6) but reoriented\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world\n  └── passive_cube (Passive Rigid Body, 1×1×5 dimensions, rotated 90° Z)\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed regardless of external forces\n- No dynamic instability risks due to static nature\n- The -6 Z position places it below typical ground plane (Z=0), which may be intentional for basement or sub-level structures\n- The 90° Z rotation may be for alignment with other scene elements or aesthetic positioning\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (1.0, 1.0, 5.0)\ncube_location: (0.0, 0.0, -6.0)\ncube_rotation_z_degrees: 90.0\ncube_rotation_z_radians: 1.57079632679\nrigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default 2×2×2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0.0, 0.0, -6.0))\ncube = bpy.context.active_object\ncube.name = \"passive_cube\"\n\n# Scale to achieve 1×1×5 dimensions\n# Default cube is 2 units wide, so scale factor = desired/2\ncube.scale = (0.5, 0.5, 2.5)  # (1/2, 1/2, 5/2)\n\n# Apply scale to make dimensions permanent in object data\nbpy.ops.object.transform_apply(scale=True)\n\n# Rotate 90° around Z-axis (convert degrees to radians)\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Apply rotation to make it permanent\nbpy.ops.object.transform_apply(rotation=True)\n\n# Add rigid body physics with PASSIVE type\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Verify final properties\nprint(f\"Cube created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation: {cube.rotation_euler}\")\nprint(f\"Rigid Body Type: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 154, "instruction": "Place an Active sphere (radius 2.2) at (8, 7, -1) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single physics-enabled sphere with specific geometric properties. This is a straightforward 3D modeling task involving rigid body physics setup. The sphere must be positioned and oriented precisely, then configured as an Active rigid body to respond to gravity and collisions in the Blender physics engine. No complex mechanisms or hierarchies are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 2.2 units (given).\n- Sphere Center: Cartesian coordinates (8, 7, -1).\n- Rotation: 90° around the Y-axis, which corresponds to π/2 radians.\n- No other geometry or constraints are specified.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (single object with no hierarchical dependencies)\n- The sphere has a single transformation (location + rotation) and is assigned an Active rigid body component.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an Active rigid body, the sphere will immediately fall under gravity (default -Z direction in Blender) from its starting position at Z=-1.\n- If the ground plane exists at Z=0, the sphere will collide with it and likely roll due to its initial Y-axis rotation.\n- With no other objects, the sphere's motion will be governed solely by gravity and any initial angular velocity from the rotation (though pure rotation without initial velocity won't cause translation).\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.2\n- sphere_location: (8.0, 7.0, -1.0)\n- sphere_rotation_y_degrees: 90.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.2,\n    location=(8.0, 7.0, -1.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"ActiveSphere\"\n\n# Apply 90-degree Y-axis rotation (convert to radians)\nsphere.rotation_euler = (0, math.radians(90.0), 0)\n\n# Add Active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Optionally add ground plane for physics interaction\nbpy.ops.mesh.primitive_plane_add(size=40.0, location=(0, 0, -5))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\nprint(f\"Created active sphere: radius={sphere_radius}, location={sphere_location}, rotation Y={sphere_rotation_y_degrees}°\")\n```\n</implementation>"}
{"id": 159, "instruction": "Place a Passive cylinder (radius 1.3, height 2.7) at (4, 0, 5) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical obstacle for a physics simulation. Since it's designated as \"Passive,\" it will not move in response to collisions. The critical steps are: 1) creating a cylinder with the specified dimensions, 2) placing it at the given world coordinates, 3) applying the exact rotation, and 4) configuring its rigid body physics as passive. No complex kinematics or dynamic simulation is required for this single object.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder base radius: 1.3m.\n- Cylinder total height: 2.7m.\n- World location: (x=4.0m, y=0.0m, z=5.0m). The z-coordinate (5) places the object's origin at that height.\n- Rotation: 35 degrees around the X-axis. In Blender, positive rotation is counter-clockwise when looking from the positive axis toward the origin.\n- The cylinder's origin defaults to its geometric center. With a height of 2.7m, the base and top are at z = 5 ± 1.35m.\n</spatial_layout>\n\n<kinematic_topology>\nSingle static object hierarchy:\n- world -> cylinder_passive (Static Mesh with Passive Rigid Body)\nNo joints or parent-child relationships.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cylinder will remain fixed and immovable during simulation.\n- Risk: None for this object. Its primary purpose is to act as a collision obstacle for other active bodies.\n- Note: Ensure the passive rigid body type is set correctly to avoid unintended movement.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.3\n- cylinder_height: 2.7\n- location: (4.0, 0.0, 5.0)\n- rotation_x_degrees: 35.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified radius and height\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.3,\n    depth=2.7,\n    location=(4.0, 0.0, 5.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"cylinder_passive\"\n\n# Apply rotation of 35 degrees around X-axis (convert to radians)\ncylinder.rotation_euler.x = math.radians(35.0)\n\n# Add rigid body physics and set to passive\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\ncylinder.rigid_body.mass = 100.0  # Mass is irrelevant for passive, but set for completeness\n\nprint(f\"Created passive cylinder: {cylinder.name}\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation (degrees): {math.degrees(cylinder.rotation_euler.x)}\")\n```</implementation>"}
{"id": 131, "instruction": "Place a Passive cylinder (radius 1.2, height 3.2) at (-4, 0, 1) and rotate it 70° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to place a static cylindrical obstacle with specified dimensions, location, and rotation. The cylinder must be a passive rigid body (non-moving) to serve as a fixed obstacle in a physics simulation. Key considerations: 1) Ensure the cylinder's pivot/center is correctly positioned after rotation, 2) Set appropriate rigid body properties for stability, 3) Use exact dimensions to match the specification.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius (r): 1.2 units\n- Cylinder height (h): 3.2 units\n- World location (x,y,z): (-4.0, 0.0, 1.0)\n- Rotation: 70° around global Z-axis (θ = 70°)\n- Pivot adjustment: The default Blender cylinder primitive is centered at origin with height along Z-axis. When placed, the cylinder's base will be at z = 1.0 - h/2 = 1.0 - 1.6 = -0.6, and top at z = 1.0 + 1.6 = 2.6. Rotation around Z-axis spins the cylinder about its vertical axis, not affecting height.\n</spatial_layout>\n\n<kinematic_topology>\n  world\n   └── cylinder_obstacle (Passive Rigid Body, Static Mesh)\n        - Location: (-4, 0, 1)\n        - Rotation: (0, 0, 70°) in Euler XYZ\n        - No parent/child relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cylinder will remain fixed regardless of mass or collisions.\n- Rotation effect: Rotating 70° around Z-axis visually orients the cylinder but doesn't affect collision shape (cylinder collision primitive is axis-aligned in Blender's rigid body simulation).\n- Risk: If using mesh collision, ensure the rotation is applied to avoid misalignment between visual and collision geometry.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.2\n- cylinder_height: 3.2\n- location: (-4.0, 0.0, 1.0)\n- rotation_z_deg: 70.0\n- rigidbody_type: PASSIVE\n- collision_shape: CYLINDER\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.2,\n    depth=3.2,\n    location=(-4.0, 0.0, 1.0),\n    rotation=(0.0, 0.0, math.radians(70.0))\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"cylinder_obstacle\"\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'CYLINDER'\n\n# Ensure collision shape matches visual (cylinder primitive already axis-aligned)\n# No scaling applied, so collision dimensions match object dimensions\n\nprint(f\"Cylinder created at {cylinder.location}, rotated {70}° on Z-axis\")\nprint(f\"Radius: {1.2}, Height: {3.2}, Rigid Body: PASSIVE\")\n```\n</implementation>"}
{"id": 160, "instruction": "Place an Active 3x2x4 cube at (-1, 7, -7) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe objective is to create a specific rigid body object for physics simulation. A cube with non-uniform scaling (3x2x4) must be placed at an exact world coordinate (-1, 7, -7) with a 15-degree Y-axis rotation. This is a foundational rigid body setup task requiring precise geometric placement and active physics properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 3.0m, Depth (Y) = 2.0m, Height (Z) = 4.0m\n- World Location: (x, y, z) = (-1.0, 7.0, -7.0)\n- Rotation: 15° about the global Y-axis = 0.261799 radians (15 × π/180)\n- Geometric Center: The cube's origin (and thus its rigid body center of mass) will be placed exactly at the specified location.\n- Note: Blender's default cube has dimensions 2×2×2, so scaling factors are (1.5, 1.0, 2.0).\n</spatial_layout>\n\n<kinematic_topology>\n- World → cube_object (Active Rigid Body)\n- No joints or constraints required for this static placement task.\n- The cube is a single rigid body with its local origin at the geometric center.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cube's base (4m height) may be tall relative to its 2m depth, potentially making it prone to tipping if subjected to lateral forces.\n- Collision Geometry: The non-uniform scaling will be correctly handled by Blender's rigid body system using the mesh's transformed vertices.\n- Risk: None for this placement task; the object will be stationary until influenced by other forces (gravity, collisions).\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 2.0, 4.0)\n- cube_location: (-1.0, 7.0, -7.0)\n- cube_rotation_y_deg: 15.0\n- cube_rotation_y_rad: 0.2617993877991494\n- scale_factors: (1.5, 1.0, 2.0)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply non-uniform scaling for 3x2x4 dimensions\ncube.scale = (1.5, 1.0, 2.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-1.0, 7.0, -7.0)\ncube.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n# Optional: Set mass based on volume (assuming density 1 kg/m³)\ncube.rigid_body.mass = 24.0  # Volume = 3×2×4 = 24 m³\n```</implementation>"}
{"id": 163, "instruction": "Place a Passive cylinder (radius 1, height 1.5) at (-2, 0, 1) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a simple static placement task requiring precise geometric positioning and orientation. The cylinder will serve as a static obstacle or structural element in the scene. The main considerations are accurate coordinate transformation and rigid body physics setup.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center location: (-2, 0, 1) in global coordinates.\n- Cylinder height (h): 1.5m, meaning it extends from z=1-0.75=0.25 to z=1+0.75=1.75.\n- Cylinder radius (r): 1m.\n- Rotation: 45° around the Z-axis (positive rotation is counterclockwise).\n- Transformation order: Scale first (dimensions), then rotate, then translate to final position.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (single rigid body, no joints)\n- Rigid body type: PASSIVE (immovable in simulations)\n</kinematic_topology>\n\n<predictive_simulation>\n- No dynamic motion expected since it's a passive rigid body.\n- Collision geometry matches visual mesh exactly (cylinder shape).\n- Stable placement with center of mass at geometric center (0,0,0 in local coordinates).\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (-2.0, 0.0, 1.0)\n- cylinder_radius: 1.0\n- cylinder_height: 1.5\n- cylinder_rotation_z_deg: 45.0\n- cylinder_rotation_z_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=1.5,\n    location=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply rotation (45 degrees around Z-axis)\ncylinder.rotation_euler[2] = math.radians(45.0)\n\n# Apply translation to final position\ncylinder.location = (-2.0, 0.0, 1.0)\n\n# Add passive rigid body physics\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Ensure transformation is applied\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(f\"Cylinder created at {cylinder.location} with rotation {math.degrees(cylinder.rotation_euler[2]):.1f}°\")\n```\n</implementation>"}
{"id": 162, "instruction": "Place an Active sphere (radius 2.7) at (0, 11, 0) and rotate it 30° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single dynamic sphere with specific geometric properties and initial conditions. This involves clearing any existing scene elements, creating the sphere mesh, applying the correct transformations, and configuring rigid body physics for dynamic simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 2.7 units\n- Center location: (x=0, y=11, z=0)\n- Rotation: 30° around global Y-axis (requires conversion: radians = 30 × π/180 ≈ 0.5236 rad)\n- Bounding box dimensions: 5.4 × 5.4 × 5.4 units (diameter in each axis)\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere (single dynamic object with no parent-child relationships)\n- Rigid body type: ACTIVE (responds to forces and collisions)\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere's initial rotation (30° around Y) won't affect its center of mass position.\n- As an active rigid body, it will immediately fall under gravity (default -9.8 m/s² in Z direction).\n- No collision objects present, so sphere will fall indefinitely until constrained by a passive object.\n- Risk: High initial Y-position (11 units) means longer fall distance before potential impact.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 2.7\n- location: (0.0, 11.0, 0.0)\n- rotation_y_degrees: 30.0\n- rotation_y_radians: 0.5235987755982988\n- rigidbody_type: \"ACTIVE\"\n- mesh_name: \"Active_Sphere\"\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.7, location=(0, 11, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 30° rotation around Y-axis\nsphere.rotation_euler[1] = math.radians(30.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Ensure proper viewport display\nbpy.context.view_layer.update()\nprint(f\"Created {sphere.name} with radius {sphere.dimensions.x/2}\")\n```\n</implementation>"}
{"id": 153, "instruction": "Place a Passive 1x3x2 cube at (6, 0, 1) and rotate it 45° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves placing a passive rigid body cube with specific dimensions and orientation. The primary considerations are ensuring the cube's dimensions (1×3×2) are correctly implemented, positioning it at coordinates (6,0,1), and applying a 45° rotation around the X-axis. As a passive rigid body, it will not move during simulation but will interact with other objects. The transformation order (scale, rotate, translate) is critical in Blender to avoid unexpected behavior.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: X=1m, Y=3m, Z=2m (extents from center).\n- Location: Center point at (6, 0, 1). Given the cube's height (Z=2m), the bottom face will be at Z=0 and top at Z=2.\n- Rotation: 45° around X-axis = π/4 ≈ 0.785398 radians.\n- Base Plane: The cube will be tilted such that its top face rotates upward in the +Z direction, while the bottom rotates downward in the -Z direction.\n- Safety Check: No collision risks as it's a standalone passive object.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Static Mesh with passive rigid body)\n- No joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cube will remain fixed in place during simulation.\n- Physical Accuracy: The 45° rotation will make the cube rest on one edge if unsupported, but since it's passive, it will not fall.\n- Risk: If other active rigid bodies collide with it, they will interact according to physics.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 3.0, 2.0)\n- cube_location: (6.0, 0.0, 1.0)\n- cube_rotation_x_deg: 45.0\n- cube_rotation_x_rad: 0.7853981633974483\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions (Blender default cube is 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Set dimensions: scale from default 2m to desired dimensions\ncube.scale.x = 1.0 / 2.0  # Target X=1, default=2 -> scale=0.5\ncube.scale.y = 3.0 / 2.0  # Target Y=3, default=2 -> scale=1.5\ncube.scale.z = 2.0 / 2.0  # Target Z=2, default=2 -> scale=1.0\n\n# Apply scale to make dimensions explicit\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (6.0, 0.0, 1.0)\n\n# Set rotation (45° around X-axis)\ncube.rotation_euler = (math.radians(45.0), 0.0, 0.0)\n\n# Add rigid body physics (passive)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 161, "instruction": "Place a Passive 1x1x3 cube at (7, 0, 0) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static obstacle in a physics simulation. A passive rigid body cube will be placed at a specific location and orientation to serve as a barrier or structural element. No dynamic motion is required, just correct geometric placement and physical property assignment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 1m (X) × 1m (Y) × 3m (Z).\n- World Location: (7, 0, 0) in global coordinates.\n- Rotation: 90° around the X-axis. In radians: 90° × (π/180) = 1.5708 rad.\n- After rotation, the local Z-axis (originally 3m height) becomes aligned with the global Y-axis, and the local Y-axis becomes aligned with the global negative Z-axis.\n- The cube's bounding box will extend 0.5m in ±X, 1.5m in ±Y (due to the 3m length rotated), and 0.5m in ±Z after rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_obstacle (Static Passive Rigid Body)\n- No joints or hierarchical relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cube is stable and immovable in simulations.\n- Collision Geometry: The rotated orientation changes the effective collision profile—now presenting a 3m length along the Y-axis instead of vertically.\n- Risk: None. This is a simple static object.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 1.0, 3.0)\n- cube_location: (7.0, 0.0, 0.0)\n- cube_rotation_x_deg: 90.0\n- cube_rotation_x_rad: 1.57079632679\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default 2x2x2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"cube_obstacle\"\n\n# Apply scaling to achieve 1x1x3 dimensions (default cube is 2x2x2)\n# Scale factors = desired_dimension / 2.0\ncube.scale = (0.5, 0.5, 1.5)\n\n# Apply rotation and translation\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\ncube.location = (7.0, 0.0, 0.0)\n\n# Apply transformations to make them direct object data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX (default for cubes)\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 156, "instruction": "Place an Active 4x1x3 cube at (0, 6, 6) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single active rigid body cube with specific dimensions, location, and rotation. This is a straightforward modeling and physics setup exercise requiring proper scaling, transformation, and rigid body configuration.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (L×W×H): 4m (X), 1m (Y), 3m (Z)\n- Final Location: (0, 6, 6) in world coordinates\n- Rotation: 60° about the X-axis, converting to radians: 60 × π/180 = 1.0472 rad\n- Default cube size (2×2×2) requires scaling by factors: (2.0, 0.5, 1.5) to achieve target dimensions\n</spatial_layout>\n\n<kinematic_topology>\n- World → ActiveCube (single dynamic rigid body with no joints or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\nAs an active rigid body, the cube will respond to gravity and collisions. With no floor or constraints, it will fall indefinitely starting from its initial rotated orientation. The center of mass is at the geometric center of the scaled mesh.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (4.0, 1.0, 3.0)\n- location: (0.0, 6.0, 6.0)\n- rotation_x_deg: 60\n- rotation_x_rad: 1.0472\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with correct dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Scale to target dimensions (4×1×3) from default 2×2×2\ncube.scale = (2.0, 0.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 6.0, 6.0)\ncube.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Configure as active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Explicitly set mass (default)\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.1\n\nprint(f\"Created {cube.name} with:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 165, "instruction": "Place a Passive 3x1x3 cube at (-6, 0, -3) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static passive obstacle with specific dimensions, location, and orientation. This involves precise geometric modeling and rigid body physics setup. The cube will serve as a passive collider in simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: (width=3.0m, height=1.0m, depth=3.0m)\n- Location: Center at (-6.0, 0.0, -3.0) in world coordinates\n- Rotation: 75° about Y-axis, converted to radians: θ = 75 × π/180 ≈ 1.30899694 rad\n- Mesh Transformation: Default Blender cube (2×2×2m) must be scaled by (1.5, 0.5, 1.5) to achieve target dimensions\n- Base Plane: No additional support needed as cube contacts ground at Z = -3.5 (bottom face at Z = -4.0 with 1m height)\n</spatial_layout>\n\n<kinematic_topology>\n- world → passive_cube (Static Passive Rigid Body)\n- No joints or constraints needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube has sufficient base area (3×3m) and low center of mass at Z = -3.0\n- Collision: Passive rigid body will remain fixed during simulations\n- Risk: None identified for static geometry\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (-6.0, 0.0, -3.0)\n- cube_rotation_y_rad: 1.30899694\n- cube_dimensions: (3.0, 1.0, 3.0)\n- cube_scale: (1.5, 0.5, 1.5)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Set scale for dimensions (default 2m cube → scale by 1.5,0.5,1.5 for 3x1x3m)\ncube.scale = (1.5, 0.5, 1.5)\n\n# Apply transformations\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (-6.0, 0.0, -3.0)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Update viewport\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 167, "instruction": "Place a Passive cylinder (radius 0.6, height 2.4) at (1, 0, 1) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThis is a simple static object placement task requiring precise geometric transformation. The cylinder must be positioned and oriented exactly as specified. Since it's a passive rigid body, no dynamic simulation is required beyond proper collision representation. The 90° X-axis rotation will align the cylinder's height axis (typically Z) to the Y-axis in global coordinates.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder base at creation: centered at origin with height along Z-axis\n- Target position: (1, 0, 1) for the object origin\n- Target rotation: 90° around X-axis (π/2 radians)\n- Post-rotation dimensions:\n  - Local X-axis unchanged\n  - Local Y-axis becomes height direction (2.4m extent)\n  - Local Z-axis becomes radial direction\n- Bounding box extremes after rotation:\n  - X: 1 ± 0.6m (radius)\n  - Y: 0 ± 1.2m (half height)\n  - Z: 1 ± 0.6m (radius)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_object (Passive Rigid Body)\n- No joints or constraints needed\n- Rigid body type: PASSIVE for static collision\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Centered placement ensures no tipping\n- Collision: Cylinder will interact properly with other active rigid bodies\n- Mesh quality: Default cylinder with 32 vertices provides smooth collision surface\n- No dynamic risks for static object\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.6\n- cylinder_height: 2.4\n- location_xyz: (1.0, 0.0, 1.0)\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.57079632679\n- rigidbody_type: PASSIVE\n- cylinder_vertices: 32\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.6,\n    depth=2.4,\n    location=(1.0, 0.0, 1.0),\n    rotation=(math.radians(90.0), 0.0, 0.0)\n)\n\n# Reference the active object\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Verify transformations\nprint(f\"Cylinder created at: {cylinder.location}\")\nprint(f\"Cylinder rotation (radians): {cylinder.rotation_euler}\")\nprint(f\"Cylinder dimensions: Radius=0.6, Height=2.4\")\n```</implementation>"}
{"id": 166, "instruction": "Place an Active sphere (radius 1.1) at (3, 8, -2) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a sphere with specific geometric properties and spatial transformation. Since \"Active\" suggests dynamic behavior in a physics simulation context, I'll create the sphere as an active rigid body. The primary considerations are ensuring correct radius, location in global coordinates, and applying a precise Z-axis rotation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 1.1 units\n- Global location: (x=3.0, y=8.0, z=-2.0)\n- Rotation: 60° about Z-axis = 1.04719755 radians (π/3)\n- Coordinate system: Blender uses right-handed Z-up coordinate system\n- Rotation order: Default XYZ Euler, where Z rotation is applied first\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere (single rigid body object)\n- No hierarchical relationships needed\n- Rigid body type: ACTIVE for dynamic simulation\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: Active rigid body will immediately fall due to gravity from z=-2\n- Mitigation: May require temporary suspension or positioning in mid-air for static scenes\n- Collision: Sphere radius 1.1 ensures proper collision geometry\n- Rotation: Applied in object space, affects collision mesh orientation\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.1\n- sphere_location: (3.0, 8.0, -2.0)\n- sphere_rotation_z_degrees: 60.0\n- sphere_rotation_z_radians: 1.0471975511965976\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.1)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location\nsphere.location = (3.0, 8.0, -2.0)\n\n# Apply rotation (60° around Z-axis)\nsphere.rotation_euler = (0.0, 0.0, math.radians(60.0))\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Ensure collision geometry matches visual\nsphere.rigid_body.use_margin = True\nsphere.rigid_body.collision_margin = 0.0\n\n# Add material for visualization\nmat = bpy.data.materials.new(name=\"Sphere_Material\")\nmat.use_nodes = True\nnodes = mat.node_tree.nodes\nnodes.clear()\n\n# Create principled BSDF node\nbsdf = nodes.new(type='ShaderNodeBsdfPrincipled')\nbsdf.location = (0, 0)\nbsdf.inputs['Base Color'].default_value = (0.8, 0.2, 0.2, 1.0)  # Red color\nbsdf.inputs['Roughness'].default_value = 0.3\n\n# Create material output node\noutput = nodes.new(type='ShaderNodeOutputMaterial')\noutput.location = (400, 0)\n\n# Link nodes\nlinks = mat.node_tree.links\nlinks.new(bsdf.outputs['BSDF'], output.inputs['Surface'])\n\n# Assign material to sphere\nif sphere.data.materials:\n    sphere.data.materials[0] = mat\nelse:\n    sphere.data.materials.append(mat)\n\n# Add world environment for better visualization\nworld = bpy.data.worlds.get(\"World\")\nif world:\n    world.use_nodes = True\n    bg = world.node_tree.nodes.get(\"Background\")\n    if bg:\n        bg.inputs['Color'].default_value = (0.8, 0.9, 1.0, 1.0)  # Light blue\n        bg.inputs['Strength'].default_value = 1.0\n\n# Add a ground plane for reference\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, -4))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\nprint(f\"Created active sphere at {sphere.location}\")\nprint(f\"Radius: {sphere.dimensions.x / 2}\")\nprint(f\"Rotation (Z): {math.degrees(sphere.rotation_euler.z)}°\")\n```\n</implementation>"}
{"id": 164, "instruction": "Place an Active 2x4x2 cube at (5, 9, -5) and rotate it 20° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single active rigid body cube with specific dimensions, position, and orientation. This requires precise modeling and rigid body setup in Blender. Since the cube is active, it will respond to gravity and collisions. For demonstration, a passive floor will be added to allow the cube to fall and interact with the environment, but the core requirement is met by creating the cube as specified.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 2 units along X (width), 4 units along Y (depth), 2 units along Z (height).\n- Cube location: (5.0, 9.0, -5.0) in world coordinates.\n- Cube rotation: 20 degrees around the X-axis, which in radians is 20 * (π/180) ≈ 0.349066 radians.\n- Floor: A large passive rigid body plane at Z = -10 to catch the falling cube, extending from -20 to 20 in X and Y.\n</spatial_layout>\n\n<kinematic_topology>\n- world: Root coordinate system.\n- floor: Passive rigid body mesh (plane) fixed in world.\n- cube: Active rigid body mesh (cube) with specified transform.\nNo hierarchical relationships; both are direct children of the world.\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube starts at (5,9,-5) and is rotated 20° about X. This rotation will affect its initial contact with the floor and its subsequent bounce/tumble.\n- With gravity enabled (default -9.8 m/s² along Z), the cube will fall and hit the floor at Z=-10.\n- The cube's active rigid body properties (mass, friction, bounciness) will influence its dynamics. Default mass (calculated from volume and density) is sufficient.\n- Risk: The cube may bounce or slide off the floor due to initial rotation and velocity. This is acceptable for demonstration.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 4.0, 2.0)\n- cube_location: (5.0, 9.0, -5.0)\n- cube_rotation_x_deg: 20.0\n- cube_rotation_x_rad: 0.349066\n- floor_location: (0.0, 0.0, -10.0)\n- floor_size: 40.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create floor plane\nbpy.ops.mesh.primitive_plane_add(size=40, location=(0, 0, -10))\nfloor = bpy.context.active_object\nfloor.name = \"Floor\"\nbpy.ops.rigidbody.object_add()\nfloor.rigid_body.type = 'PASSIVE'\n\n# Create cube with specified dimensions\n# Default cube is 2x2x2, so we scale by (1,2,1) to get 2x4x2\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0,0,0))\ncube = bpy.context.active_object\ncube.name = \"Cube\"\ncube.scale = (1.0, 2.0, 1.0)  # Scale Y by 2 to get depth=4 (since base size=2)\nbpy.ops.object.transform_apply(scale=True)  # Apply scale to have true dimensions\n\n# Set location and rotation\ncube.location = (5.0, 9.0, -5.0)\ncube.rotation_euler = (math.radians(20.0), 0, 0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n# Optional: set mass explicitly (default is calculated from volume and density)\n# cube.rigid_body.mass = 1.0\n\n# Set scene gravity to default -9.8 along Z (already default, but explicit)\nbpy.context.scene.use_gravity = True\nbpy.context.scene.gravity = (0, 0, -9.8)\n\n# Optional: Set frame range for animation\nbpy.context.scene.frame_start = 1\nbpy.context.scene.frame_end = 250\n```\n</implementation>"}
{"id": 171, "instruction": "Place a Passive cylinder (radius 1.7, height 3.3) at (2, 0, -6) and rotate it 25° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a single passive cylinder with specific dimensions, position, and orientation. Since this involves no moving parts or complex assemblies, the focus is on precise geometric placement and rigid body property assignment. The cylinder should be created as a passive rigid body that won't move during simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.7 units\n- Cylinder height: 3.3 units (extends ±1.65 units along Z-axis from center)\n- Position: (2, 0, -6) in global coordinates\n- Rotation: 25° around Y-axis = 25 × (π/180) ≈ 0.436332 radians\n- The cylinder's local coordinate system will be rotated such that its circular faces remain parallel to XY-plane\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n- No joints or constraints needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed during physics simulations\n- The mass and inertia properties are automatically calculated from geometry\n- No dynamic risks since object is static\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.7\n- cylinder_height: 3.3\n- cylinder_location: (2.0, 0.0, -6.0)\n- cylinder_rotation_y_degrees: 25.0\n- cylinder_rotation_y_radians: 0.436332\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.7,\n    depth=3.3,\n    location=(2.0, 0.0, -6.0),\n    rotation=(0.0, math.radians(25.0), 0.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"PassiveCylinder\"\n\n# Add rigid body physics and set to passive\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n```\n</implementation>"}
{"id": 170, "instruction": "Place an Active sphere (radius 2.4) at (-8, 6, 0) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThis task involves placing a single rigid body sphere with specific geometric properties. The key requirements are correct radius (2.4), precise location (-8, 6, 0), and exact rotation (15° on X-axis). As an active rigid body, it will respond to gravity and collisions. No complex kinematics are needed since it's a standalone object.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (r): 2.4 units\n- Sphere Center Location: (x, y, z) = (-8.0, 6.0, 0.0)\n- Rotation: 15° around X-axis = 0.261799 radians (converted for Blender's radians)\n- Note: In Blender, rotations use radians and follow right-hand rule. Positive rotation around X rotates from Y to Z.\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere (Single rigid body with no parent-child hierarchy)\n- No joints or constraints needed for this standalone object\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Sphere has uniform mass distribution, making it stable for rolling/physics.\n- Risk: None beyond standard gravity effects. Active rigid body will fall if gravity is enabled.\n- Mesh Quality: Default UV sphere with 32 segments/rings provides good physics collision approximation.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 2.4\nsphere_location: (-8.0, 6.0, 0.0)\nsphere_rotation_x_degrees: 15.0\nsphere_rotation_x_radians: 0.261799\nrigid_body_type: ACTIVE\nmesh_subdivisions: 32\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.4,\n    location=(-8.0, 6.0, 0.0),\n    segments=32,\n    ring_count=32\n)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 15° rotation around X-axis (convert to radians)\nsphere.rotation_euler = (math.radians(15.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Optional: Enable gravity in scene (default is already -9.81 Z)\nbpy.context.scene.use_gravity = True\n\nprint(f\"Created sphere: {sphere.name}\")\nprint(f\"Radius: {sphere.dimensions.x/2}\")\nprint(f\"Location: {sphere.location}\")\nprint(f\"Rotation: {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 174, "instruction": "Place an Active sphere (radius 0.9) at (-3, 6, 7) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body sphere with specific geometric properties (radius 0.9), spatial placement (position (-3, 6, 7)), and orientation (60° Y-axis rotation). As an \"Active\" sphere, it must be configured as an active rigid body to participate in Blender's physics simulations. This is a straightforward object creation and configuration task without complex kinematics or dynamic constraints.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius (r): 0.9 units\n- Position (P): (-3, 6, 7) in global (X, Y, Z) coordinates\n- Rotation: 60° about the Y-axis. Convert to radians for Blender: θ = 60° × (π/180) = 1.047197551 rad\n- Since a sphere's collision shape is isotropic, rotation doesn't affect its physical interaction, but the visual mesh will be rotated.\n</spatial_layout>\n\n<kinematic_topology>\nSingle object hierarchy:\n- world → sphere (Active Rigid Body)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a single sphere, no stability issues.\n- Dynamic behavior: As an active rigid body with default settings (mass 1kg, gravity enabled), the sphere will fall under gravity from its initial elevated position (Z=7).\n- Collision: The sphere's radius (0.9) determines its collision bounds. The Y-axis rotation is purely visual.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.9\n- sphere_location: (-3.0, 6.0, 7.0)\n- sphere_rotation_y_degrees: 60.0\n- sphere_rotation_y_radians: 1.047197551\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.9)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation\nsphere.location = (-3.0, 6.0, 7.0)\nsphere.rotation_euler = (0.0, math.radians(60.0), 0.0)  # Y-axis rotation\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n\n# Optional: Adjust rigid body settings for clarity\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.5\n\nprint(f\"Created active sphere at {sphere.location} with rotation {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 172, "instruction": "Place an Active 5x1x2 cube at (-1, 8, 3) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a single rigid body cube with specific dimensions, position, and orientation. Since it's an active rigid body, it will respond to physics simulations. The main considerations are ensuring correct scaling from default cube dimensions, accurate placement, and proper rotation about the Z-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Default cube dimensions: 2m × 2m × 2m (from -1 to 1 in all axes)\n- Target dimensions: 5m (width) × 1m (depth) × 2m (height)\n- Scale factors: (5/2, 1/2, 2/2) = (2.5, 0.5, 1.0)\n- Location: (-1, 8, 3) in global coordinates\n- Rotation: 90° about Z-axis = π/2 radians = 1.5708 rad\n- Note: Blender's default cube center is at origin; applying scale before rotation ensures correct orientation\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (single Active Rigid Body with no parent)\n- No joints or constraints needed for this isolated object\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube's dimensions create an anisotropic shape (5×1×2)\n- Center of mass: At geometric center due to uniform density\n- Dynamic behavior: The long dimension (5m) aligned with local X-axis will create interesting rotational inertia\n- Risk: With Z-rotation applied, the long axis aligns with global Y-direction, potentially creating unstable tipping if subjected to lateral forces\n</predictive_simulation>\n\n<parameter_summary>\n- target_location: (-1.0, 8.0, 3.0)\n- target_rotation_z: 90.0 (degrees)\n- scale_factors: (2.5, 0.5, 1.0)\n- rigidbody_type: ACTIVE\n- cube_dimensions: (5.0, 1.0, 2.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Add default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scale transformation to achieve 5x1x2 dimensions\ncube.scale = (2.5, 0.5, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-1.0, 8.0, 3.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Default mass\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.2\n\n# Optional: Add visual material for clarity\nmat = bpy.data.materials.new(name=\"ActiveMaterial\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blueish color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Created active cube at {cube.location}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 175, "instruction": "Place a Passive cylinder (radius 1.1, height 2.2) at (7, 0, -2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely kinematic: create a static cylinder object with specified dimensions, position, and rotation. Since it's marked as \"Passive,\" we should also assign it a passive rigid body property for potential physics simulations. The implementation is straightforward but requires precise coordinate and rotation handling in Blender's right-handed coordinate system (Y-up, Z-forward).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.1 units\n- Cylinder height: 2.2 units  \n- World position: (X=7.0, Y=0.0, Z=-2.0)\n- Rotation: 45° about the Z-axis (0.785398 radians)\n- No scaling or additional transformations required.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cylinder (Single rigid body with no parent-child hierarchy)\n- Joints: None (static placement only)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder base at Z=-3.1 (center Z=-2 minus half height 1.1) ensures it rests on the ground plane at Z=0.\n- Risk: None. Passive object won't move unless acted upon.\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 1.1\ncylinder_height: 2.2\ncylinder_location: (7.0, 0.0, -2.0)\ncylinder_rotation_z_deg: 45.0\ncylinder_rotation_z_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.1,\n    depth=2.2,\n    location=(7.0, 0.0, -2.0),\n    rotation=(0, 0, math.radians(45.0))\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"passive_cylinder\"\n\n# Assign passive rigid body property\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\nprint(f\"Created passive cylinder '{cylinder.name}'\")\nprint(f\"  Radius: {cylinder.dimensions.x/2}\")\nprint(f\"  Height: {cylinder.dimensions.z}\")\nprint(f\"  Location: {cylinder.location}\")\nprint(f\"  Rotation: {math.degrees(cylinder.rotation_euler.z)}° about Z-axis\")\n```\n</implementation>"}
{"id": 168, "instruction": "Place an Active 4x3x1 cube at (-4, 7, 4) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a simple rigid body with specific geometric properties. I need to construct a rectangular prism (cube is misleading - it's actually a box) with dimensions 4×3×1 units, positioned at coordinates (-4, 7, 4) with a 35° rotation around the Y-axis. As an \"Active\" rigid body, it will respond to physics forces like gravity when simulated.\n</strategic_analysis>\n\n<spatial_layout>\n- Box Dimensions: Width (X) = 4.0, Depth (Y) = 3.0, Height (Z) = 1.0\n- Location: Coordinates (-4.0, 7.0, 4.0) in world space\n- Rotation: 35° counter-clockwise around global Y-axis (viewed from above)\n- Center Point: The box's geometric center aligns with the specified location\n- Since dimensions are asymmetrical (4×3×1), the visual orientation matters relative to rotation\n</spatial_layout>\n\n<kinematic_topology>\n- world -> active_box (Single rigid body with no joints or constraints)\n- The box is a free rigid body that can translate and rotate in 3D space\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Positioned at Z=4, the box will fall under gravity when simulation starts\n- Orientation: 35° Y-rotation means it will land on an edge/corner rather than a flat face\n- Risk: No significant risks; simple free-fall dynamics expected\n- Mitigation: Ensure rigid body properties (mass, friction) are reasonable defaults\n</predictive_simulation>\n\n<parameter_summary>\n- box_dimensions: (4.0, 3.0, 1.0)\n- box_location: (-4.0, 7.0, 4.0)\n- box_rotation_y_degrees: 35.0\n- box_rotation_y_radians: 0.610865 (35° × π/180)\n- rigidbody_type: 'ACTIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create box with specified dimensions\n# Blender's default cube is 2x2x2, so we scale accordingly\nbpy.ops.mesh.primitive_cube_add(size=1.0)\nbox = bpy.context.active_object\nbox.name = \"active_box\"\n\n# Set dimensions: (width, depth, height) = (4, 3, 1)\n# Scale factors = desired_dimension / 2.0 (since default cube spans -1 to +1)\nbox.scale = (2.0, 1.5, 0.5)  # 4/2=2, 3/2=1.5, 1/2=0.5\nbpy.ops.object.transform_apply(scale=True)  # Apply scale to mesh data\n\n# Set location and rotation\nbox.location = (-4.0, 7.0, 4.0)\nbox.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\nbox.rigid_body.type = 'ACTIVE'\n\n# Set mass proportional to volume (4×3×1 = 12 cubic units)\nbox.rigid_body.mass = 12.0\n\nprint(f\"Created active box at {box.location} with rotation {math.degrees(box.rotation_euler[1]):.1f}°\")\nprint(f\"Dimensions: {box.dimensions}\")\n```\n</implementation>"}
{"id": 177, "instruction": "Place a Passive 1x3x5 cube at (-7, 0, 2) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nWe need to place a static (passive rigid body) rectangular prism with dimensions 1m (X) × 3m (Y) × 5m (Z) at position (-7, 0, 2) and rotated 35° around the Y-axis. Since it's a passive object, it will not respond to physics but can serve as an obstacle or platform. The primary challenge is correctly applying the scale, location, and rotation transformations in the proper order.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions (X, Y, Z): (1.0, 3.0, 5.0) meters.\n- Location: (-7.0, 0.0, 2.0) in world coordinates.\n- Rotation: 35° around the Y-axis, converted to radians: 35 * π / 180 ≈ 0.610865 radians.\n- Since the default Blender cube is 2×2×2, the scale factors are (1/2, 3/2, 5/2) = (0.5, 1.5, 2.5).\n- The pivot point (origin) is at the center of the cube, so the location specifies the center position.\n</spatial_layout>\n\n<kinematic_topology>\n- World → cube (Passive Rigid Body, no parent, no joints).\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed and immovable in simulations, serving as a static obstacle.\n- The 35° Y-rotation will tilt the cube, potentially creating an inclined surface for other objects to interact with.\n- No stability concerns since it's fixed in place.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 3.0, 5.0)\n- cube_location: (-7.0, 0.0, 2.0)\n- cube_rotation_y_deg: 35.0\n- cube_rotation_y_rad: 0.610865\n- scale_factors: (0.5, 1.5, 2.5)\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scale to achieve 1x3x5 dimensions\ncube.scale = (0.5, 1.5, 2.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-7.0, 0.0, 2.0)\ncube.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set display to show rigid body\nbpy.context.space_data.shading.type = 'SOLID'\nbpy.context.space_data.shading.show_rigidbody = True\n\nprint(f\"Created passive cube '{cube.name}' at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 169, "instruction": "Place a Passive 1x2x4 cube at (6, 0, -3) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nSimple static object placement with rigid body physics. The cube will be positioned at specified coordinates with a Z-axis rotation, then assigned as a passive rigid body (non-moving obstacle in simulations).\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 1m (x) × 2m (y) × 4m (z)\n- Location coordinates: (6.0, 0.0, -3.0) in world space\n- Rotation: 45° around global Z-axis (0.785398 radians)\n- Local origin: Default cube center at (0,0,0) relative to object location\n- No clearance requirements - isolated static object\n</spatial_layout>\n\n<kinematic_topology>\n- world → passive_cube (Static mesh with passive rigid body)\n- No joints or constraints needed\n- Object transformations applied directly\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Default cube geometry with uniform mass distribution\n- Collision: Passive rigid body will remain fixed during simulations\n- Risk: None - simple static placement\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (1.0, 2.0, 4.0)\ncube_location: (6.0, 0.0, -3.0)\ncube_rotation_z_degrees: 45.0\ncube_rotation_z_radians: 0.7853981634\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\n# Default Blender cube is 2x2x2, scale by half dimensions\ncube = bpy.ops.mesh.primitive_cube_add(\n    size=2.0,\n    location=(6.0, 0.0, -3.0),\n    scale=(0.5, 1.0, 2.0)  # Scale to achieve 1x2x4 dimensions\n)\n\n# Get reference to the active object\ncube_obj = bpy.context.active_object\ncube_obj.name = \"Passive_Cube\"\n\n# Apply Z-axis rotation (45 degrees)\ncube_obj.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Add rigid body physics and set to PASSIVE\nbpy.ops.rigidbody.object_add()\ncube_obj.rigid_body.type = 'PASSIVE'\n\n# Optional: Set display properties for clarity\ncube_obj.display_type = 'SOLID'\nbpy.context.object.data.materials.clear()\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: 1.0 × 2.0 × 4.0 m\")\nprint(f\"  Location: {cube_obj.location}\")\nprint(f\"  Rotation: {math.degrees(cube_obj.rotation_euler.z):.1f}° on Z-axis\")\n```\n</implementation>"}
{"id": 176, "instruction": "Place an Active 3x4x1 cube at (0, 9, 1) and rotate it 20° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid object with specific dimensions, position, and orientation. We need to create a 3×4×1 rectangular prism (cube-like shape), position it at (0, 9, 1) in global coordinates, and apply a 20° rotation about the X-axis. Since this is a simple single object without articulated parts, the implementation focuses on proper geometric creation and transformation application.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: width (X)=3m, depth (Y)=4m, height (Z)=1m\n- Location: X=0.0m, Y=9.0m, Z=1.0m (center point of cube)\n- Rotation: 20° about X-axis = 0.349066 radians\n- Note: Since Z=1m and center is at Z=1m, the bottom face is at Z=0.5m and top face at Z=1.5m\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (single active rigid body)\n- No joints or hierarchical relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will respond to physics simulation (gravity, collisions)\n- With rotation applied, the cube's tilted orientation affects its stability and contact points\n- No specific stability concerns for this isolated object placement\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (3.0, 4.0, 1.0)\n- location: (0.0, 9.0, 1.0)\n- rotation_x_degrees: 20.0\n- rotation_x_radians: 0.349066\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default dimensions (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Scale to achieve 3×4×1 dimensions\n# Default cube is 2×2×2, so scale factors: (3/2, 4/2, 1/2)\ncube.scale = (1.5, 2.0, 0.5)\n\n# Apply scale to make dimensions intrinsic\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (0.0, 9.0, 1.0)\n\n# Apply X-axis rotation (20° converted to radians)\ncube.rotation_euler = (math.radians(20.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optional: Set mass based on volume (assuming density 1 kg/m³)\n# Volume = 3 × 4 × 1 = 12 m³\ncube.rigid_body.mass = 12.0\n\nprint(f\"Created active cube: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation (degrees): ({math.degrees(cube.rotation_euler.x):.1f}, 0, 0)\")\n```\n</implementation>"}
{"id": 178, "instruction": "Place an Active sphere (radius 1.6) at (2, 8, 6) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single active physics object (rigid body sphere) at a specified location with a specific orientation. This is a foundational 3D modeling operation that tests understanding of coordinate systems, rotation conventions, and Blender's physics system setup.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: (x, y, z) = (2.0, 8.0, 6.0)\n- Sphere radius: r = 1.6 units\n- Rotation specification: 90° around Z-axis\n- Rotation conversion: 90° × (π/180) = π/2 ≈ 1.5708 radians\n- Resulting transformation matrix: Translation T(2,8,6) followed by rotation Rz(90°)\n- Note: Blender uses right-handed coordinate system with Z-up\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: sphere (root-level object)\n- No parent-child relationships needed\n- Rigid body type: ACTIVE for dynamic physics simulation\n- Collision shape: SPHERE (matches mesh geometry)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Single object placement has no inherent stability concerns\n- Dynamic behavior: As an active rigid body, sphere will respond to gravity (falls downward along -Z)\n- Initial conditions: Object starts with zero linear/angular velocity unless specified\n- Risk: No collision risks specified in task\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.6\n- sphere_location: (2.0, 8.0, 6.0)\n- rotation_z_degrees: 90.0\n- rotation_z_radians: 1.57079632679\n- rigidbody_type: \"ACTIVE\"\n- collision_shape: \"SPHERE\"\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.6,\n    location=(2.0, 8.0, 6.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"ActiveSphere\"\n\n# Apply 90° rotation around Z-axis (convert degrees to radians)\nrotation_radians = math.radians(90.0)\nsphere.rotation_euler = Euler((0.0, 0.0, rotation_radians), 'XYZ')\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Verify transformation\nprint(f\"Sphere created at: {sphere.location}\")\nprint(f\"Sphere rotation (radians): {sphere.rotation_euler}\")\nprint(f\"Rigid body type: {sphere.rigid_body.type}\")\n```\n</implementation>"}
{"id": 179, "instruction": "Place a Passive cylinder (radius 2.2, height 1.8) at (-5, 0, 1) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a single passive rigid body cylinder with specific geometric properties and spatial orientation. No complex mechanisms or physics interactions are required beyond the object's static placement. The primary considerations are accurate dimension specification and correct transformation application (translation and rotation).\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center position: (-5, 0, 1) in world coordinates.\n- Cylinder radius: 2.2 units.\n- Cylinder height (along local Z-axis): 1.8 units.\n- Rotation: 15° (0.2618 radians) around the global X-axis. This will tilt the cylinder forward, making its central axis no longer vertical.\n</spatial_layout>\n\n<kinematic_topology>\nSingle object hierarchy: world -> cylinder (Passive Rigid Body).\n</kinematic_topology>\n\n<predictive_simulation>\nAs a passive rigid body, the cylinder will remain fixed and immovable in any physics simulation, serving as a static obstacle or environmental element. No dynamic risks exist.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (-5.0, 0.0, 1.0)\n- cylinder_radius: 2.2\n- cylinder_height: 1.8\n- cylinder_rotation_x_deg: 15.0\n- cylinder_rotation_x_rad: 0.2617993877991494\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.2,\n    depth=1.8,\n    location=(-5.0, 0.0, 1.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply rotation (15 degrees around X-axis)\ncylinder.rotation_euler.x = math.radians(15.0)\n\n# Add passive rigid body property\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'CYLINDER'\n\n# Ensure transformations are applied\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(\"Cylinder created successfully at (-5, 0, 1) with 15° X-axis rotation.\")\n```\n</implementation>"}
{"id": 173, "instruction": "Place a Passive 2x3x3 cube at (4, 0, 4) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires positioning a static obstacle with specific dimensions, location, and orientation. Since it's a passive rigid body, it won't move during simulation but will interact with other objects through collisions. The primary considerations are precise geometric placement and proper rigid body configuration.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 2m (X) × 3m (Y) × 3m (Z)\n- Location: (4, 0, 4) in world coordinates\n- Rotation: 30° around X-axis (converted to radians: 30° × π/180 = 0.5236 rad)\n- Coordinate system: Right-handed (X-right, Y-forward, Z-up)\n- The rotation will tilt the cube forward/backward since we're rotating around X-axis\n</spatial_layout>\n\n<kinematic_topology>\n- world (Global coordinate system)\n  └── obstacle_cube (Passive rigid body mesh with specified transform)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object, the cube will remain fixed regardless of rotation\n- Collision: The 30° rotation creates a sloped surface that will affect how other objects slide or bounce off it\n- Center of mass: Defaults to geometric center at (4, 0, 4)\n- Inertia: Automatically calculated from mesh geometry and mass\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (2.0, 3.0, 3.0)\ncube_location: (4.0, 0.0, 4.0)\ncube_rotation_x_degrees: 30.0\ncube_rotation_x_radians: 0.5236\ncube_mass: 100.0 (arbitrary for passive)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Scale to achieve 2×3×3 dimensions\n# Default cube is 2×2×2, so we need half scaling factors\ncube.scale = (1.0, 1.5, 1.5)\n\n# Apply scale to make dimensions permanent in mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (4.0, 0.0, 4.0)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add rigid body physics as passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.mass = 100.0\n\n# Apply rotation to transform\nbpy.ops.object.transform_apply(rotation=True)\n\n# Optional: Add material for visibility\nmat = bpy.data.materials.new(name=\"Cube_Material\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\nif cube.data.materials:\n    cube.data.materials[0] = mat\nelse:\n    cube.data.materials.append(mat)\n\nprint(f\"Cube created at {cube.location} with dimensions 2×3×3\")\nprint(f\"Rotation: {math.degrees(cube.rotation_euler.x):.1f}° on X-axis\")\n```\n</implementation>"}
{"id": 182, "instruction": "Place an Active sphere (radius 3.2) at (9, 8, 1) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a single dynamic sphere object in Blender. Since the sphere is specified as \"Active,\" I will configure it as an active rigid body so it responds to gravity and collisions. The required transformation is explicit: translation to (9, 8, 1) and a 30-degree rotation around the X-axis. This is a straightforward modeling and physics assignment with no complex mechanisms.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (r): 3.2 units (as specified).\n- Sphere Center Position (P): (x=9.0, y=8.0, z=1.0).\n- Rotation (R): 30° rotation about the X-axis. In Blender, rotation is applied in radians. Therefore, rotation_x = 30° × (π/180) ≈ 0.523599 rad.\n- The sphere's local origin will be at its geometric center, so after these transformations, the sphere's volume will extend from (9-3.2, 8-3.2, 1-3.2) to (9+3.2, 8+3.2, 1+3.2).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single active rigid body with no parent).\n- No joints or constraints are required.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will immediately fall under gravity (default -Z direction) from its starting height of Z=1.0.\n- The initial X-axis rotation does not affect the center of mass or the gravitational response but will define the sphere's initial orientation.\n- Collision shape: \"Sphere\" (mesh-based) is appropriate given the object's geometry.\n- Risk: None, as this is a simple, stable object placement.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 3.2\nsphere_location: (9.0, 8.0, 1.0)\nsphere_rotation_x_deg: 30.0\nsphere_rotation_x_rad: 0.523599\nrigidbody_type: ACTIVE\ncollision_shape: SPHERE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear the scene of default objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a UV Sphere with the specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=3.2)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation (converting degrees to radians)\nsphere.location = (9.0, 8.0, 1.0)\nsphere.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add rigid body physics and set to ACTIVE\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n# Set collision shape to SPHERE for accuracy (default is convex hull)\nsphere.rigid_body.collision_shape = 'SPHERE'\n\n# Optional: Set a mass proportional to volume (density of 1)\n# Volume of sphere = (4/3)*pi*r^3\nvolume = (4/3) * math.pi * (3.2**3)\nsphere.rigid_body.mass = volume\n\nprint(f\"Created active sphere at {sphere.location} with radius 3.2 and X-rotation 30°.\")\n```\n</implementation>"}
{"id": 183, "instruction": "Place a Passive cylinder (radius 1.4, height 4.1) at (0, 0, 9) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single passive rigid body cylinder with specific geometric properties and spatial transformation. This is a foundational 3D modeling task that requires precise parameter application and correct rigid body physics setup. The cylinder's passive designation means it will remain static during simulations but can collide with other objects.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center location: (0, 0, 9) in global coordinates\n- Cylinder dimensions: radius (r) = 1.4 units, height (h) = 4.1 units\n- Rotation transformation: 60° rotation about the Y-axis (local coordinate system)\n- The cylinder's base will be at z = 9 - h/2 = 9 - 2.05 = 6.95\n- The cylinder's top will be at z = 9 + h/2 = 9 + 2.05 = 11.05\n- After 60° Y-axis rotation, the cylinder's orientation will be tilted relative to the world Z-axis\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world → cylinder (Passive Rigid Body)\n- No joints or constraints needed\n- The cylinder exists as an independent static mesh in the scene\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed during physics simulations\n- The 60° rotation creates a non-vertical orientation, which may affect collision interactions\n- No stability concerns since the object is static and non-dynamic\n- The object can serve as an obstacle or environmental element in physics scenarios\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.4\n- cylinder_height: 4.1\n- cylinder_location: (0.0, 0.0, 9.0)\n- cylinder_rotation_y: 60.0 (degrees)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.4,\n    depth=4.1,\n    location=(0.0, 0.0, 9.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply 60° rotation around Y-axis (convert to radians)\nrotation_euler = Euler((0.0, math.radians(60.0), 0.0), 'XYZ')\ncylinder.rotation_euler = rotation_euler\n\n# Add passive rigid body physics\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\ncylinder.rigid_body.mass = 100.0  # Arbitrary mass for passive object\n\n# Update scene and ensure proper transform application\nbpy.context.view_layer.update()\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n```\n</implementation>"}
{"id": 185, "instruction": "Place a Passive 3x3x2 cube at (5, 0, 0) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a passive rigid body cube with specific dimensions, position, and orientation. This is a foundational scene setup exercise in Blender physics simulations. The cube must be positioned at (5, 0, 0) and rotated 90° around the X-axis, making it lie flat if we consider the original orientation. Since it's a passive rigid body, it will act as static collision geometry in simulations.\n</strategic_layout>\n\n<spatial_layout>\n- Cube Dimensions: 3m (X) × 3m (Y) × 2m (Z).\n- Default Blender Cube: 2m × 2m × 2m (from -1 to 1 on each axis).\n- Scale Factors: (3/2, 3/2, 2/2) = (1.5, 1.5, 1.0).\n- Final Position: (5, 0, 0).\n- Rotation: 90° around X-axis = π/2 radians = 1.5708 rad.\n- Post-rotation Orientation: Originally, the cube's local Z-axis points upward. After 90° X-rotation, the local Z-axis now points along the global -Y direction, and the local Y-axis points along global Z.\n</spatial_layout>\n\n<kinematic_topology>\n- world (root)\n  └── cube_object (Passive Rigid Body, static mesh)\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed during simulations, providing a stable collision surface.\n- The 90° X-rotation means the cube's original height (2m along Z) is now oriented along the Y-axis in global space. This could affect interaction with other objects if they approach from specific directions.\n- No dynamic risks since the object is passive and immovable.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (3.0, 3.0, 2.0)\ncube_location: (5.0, 0.0, 0.0)\ncube_rotation_x_degrees: 90.0\ncube_rotation_x_radians: 1.5708\nscale_factors: (1.5, 1.5, 1.0)\nrigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a cube\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Scale to achieve 3x3x2 dimensions (default cube is 2x2x2)\ncube.scale = (1.5, 1.5, 1.0)\n\n# Apply scale to avoid issues with physics\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location and rotation\ncube.location = (5.0, 0.0, 0.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Add rigid body physics, set to passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n```\n</implementation>"}
{"id": 184, "instruction": "Place an Active 1x4x3 cube at (-1, 7, -3) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires precise placement and orientation of a rigid body with specific dimensions. We need to create a cube with non-uniform scaling (1×4×3), position it at exact coordinates, apply a Z-axis rotation, and ensure it's configured as an active rigid body for physics simulation. The main challenge is correctly applying transformations in the right order (scale, then location/rotation) to avoid distortion.\n</strategic_layout>\n\n<spatial_layout>\n- Default Blender cube dimensions: 2×2×2 meters\n- Target dimensions: X=1m, Y=4m, Z=3m\n- Scale factors: (1/2, 4/2, 3/2) = (0.5, 2.0, 1.5)\n- Location: (-1, 7, -3) in global coordinates\n- Rotation: 20° about Z-axis = 0.349066 radians\n- Transformation order: Apply scaling first to establish correct dimensions, then location and rotation\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (Active Rigid Body)\n- Single object hierarchy with no joints or constraints\n- Rigid body physics enabled with ACTIVE type\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Base dimensions provide sufficient contact area (1×4 footprint)\n- Dynamic risk: Asymmetric dimensions (4m length vs 1m width) may cause preferential tipping along Y-axis\n- Mitigation: Default rigid body settings provide reasonable stability; collision margin can be adjusted if needed\n</predictive_simulation>\n\n<parameter_summary>\n- target_location: (-1.0, 7.0, -3.0)\n- target_rotation_z_deg: 20.0\n- target_dimensions: (1.0, 4.0, 3.0)\n- scale_factors: (0.5, 2.0, 1.5)\n- rigidbody_type: 'ACTIVE'\n- collision_shape: 'BOX'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube at origin\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scaling for dimensions 1×4×3 (X, Y, Z)\ncube.scale = (0.5, 2.0, 1.5)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set final location and rotation\ncube.location = (-1.0, 7.0, -3.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Apply visual material for clarity\nmat = bpy.data.materials.new(name=\"ActiveCube_Material\")\nmat.diffuse_color = (0.8, 0.2, 0.2, 1.0)  # Red color\ncube.data.materials.append(mat)\n\nprint(f\"Created active cube:\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Rotation: {math.degrees(cube.rotation_euler.z):.1f}° Z-axis\")\nprint(f\"  Rigid Body: {cube.rigid_body.type}\")\n```\n</implementation>"}
{"id": 181, "instruction": "Place a Passive 2x1x5 cube at (-2, 0, -2) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves creating a single static passive rigid body cube with specific dimensions, location, and rotation. This requires basic 3D modeling with Blender's rigid body physics system. The cube will be passive (immovable) and serve as a static obstacle or platform in a physics simulation environment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 2m (width) × 1m (depth) × 5m (height) along local X, Y, Z axes respectively.\n- Target location: World coordinates (-2, 0, -2) for the cube's origin.\n- Target rotation: 45° (π/4 radians) around global Z-axis.\n- Scaling approach: Default Blender cube (2×2×2 units) will be scaled by (1, 0.5, 2.5) to achieve desired dimensions.\n- Rotation order: Apply rotation after scaling and translation to match task specification.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world → cube_object (Passive Rigid Body)\n- No joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is passive/static, so no dynamic stability concerns.\n- Collision geometry: The rotated elongated cube will create interesting angled collision surfaces for other active rigid bodies.\n- Mass distribution: Uniform density assumed with default rigid body settings.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (-2.0, 0.0, -2.0)\n- cube_rotation_z_deg: 45.0\n- cube_rotation_z_rad: 0.7853981634\n- cube_dimensions: (2.0, 1.0, 5.0)\n- cube_scale_factors: (1.0, 0.5, 2.5)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add default cube (2x2x2 units)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get reference to cube\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Set scale to achieve 2x1x5 dimensions\ncube.scale = (1.0, 0.5, 2.5)\n\n# Apply scale to make dimensions actual mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (-2.0, 0.0, -2.0)\n\n# Set rotation (45° around Z-axis)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Apply rotation to mesh data\nbpy.ops.object.transform_apply(rotation=True)\n\n# Add rigid body physics (passive/static)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Verify final dimensions\nprint(f\"Cube created at {cube.location}\")\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube rotation: {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 186, "instruction": "Place an Active sphere (radius 0.7) at (-6, 6, 3) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is purely kinematic: position and orient a sphere in 3D space. An \"Active\" rigid body sphere must be placed at specified coordinates with a Y-axis rotation. Since it's active, it will respond to physics simulation (gravity, collisions). The sphere should be created with precise radius and transform properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Center: (x, y, z) = (-6.0, 6.0, 3.0)\n- Sphere Radius: r = 0.7 m\n- Rotation: 15° around global Y-axis (Euler rotation (0, 15°, 0) in degrees)\n- Transform order: Location then rotation applied to mesh origin at center.\n- Bounding box: From (-6.7, 5.3, 2.3) to (-5.3, 6.7, 3.7) in world coordinates.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single rigid body with no joints or constraints)\n- The sphere is an independent active rigid body with mass and collision shape.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: Active rigid body at z=3.0m will fall under gravity when simulation runs unless supported.\n- Mitigation: No support required for placement task. If testing dynamics, add a passive plane below or disable gravity.\n- Collision: Sphere radius 0.7m ensures sufficient collision geometry for interactions.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.7\n- sphere_location: (-6.0, 6.0, 3.0)\n- sphere_rotation_y_degrees: 15.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects (optional cleanup)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with radius 0.7\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.7, location=(-6.0, 6.0, 3.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 15° rotation around Y-axis (convert to radians)\nsphere.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.collision_shape = 'SPHERE'\n\n# Optional: Set collision margin for stability\nsphere.rigid_body.collision_margin = 0.0\n\n# Optional: Add a passive ground plane for simulation testing\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 189, "instruction": "Place a Passive 1x2x6 cube at (6, 0, -2) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a static rigid body obstacle with specific dimensions, location, and orientation. The passive rigid body will serve as a collision object in simulations, requiring precise placement and rotation for accurate physical behavior.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 1m (X) × 2m (Y) × 6m (Z)\n- Location: (6, 0, -2) in world coordinates\n- Rotation: 60° around Y-axis = 1.0471975511965976 radians\n- The cube's local origin will be at its geometric center after creation\n- No complex geometric calculations needed beyond direct parameter application\n</spatial_layout>\n\n<kinematic_topology>\n- world -> obstacle_cube (single static mesh with passive rigid body)\n- No joints or hierarchical relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed but interact with active bodies\n- The 60° Y-rotation creates a slanted obstacle that may cause objects to slide or deflect\n- The negative Z-position (-2m) places it partially below ground if ground plane at Z=0\n- Mass properties automatically calculated from mesh volume (assuming uniform density)\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 6.0)\n- cube_location: (6.0, 0.0, -2.0)\n- cube_rotation_y_deg: 60.0\n- cube_rotation_y_rad: 1.0471975511965976\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add cube with base dimensions (default Blender cube is 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"obstacle_cube\"\n\n# Scale to desired dimensions (scale = dimension/2 since default cube is 2 units)\ncube.scale = (0.5, 1.0, 3.0)  # 1/2=0.5, 2/2=1.0, 6/2=3.0\n\n# Apply scale to make dimensions actual mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (6.0, 0.0, -2.0)\ncube.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Ensure proper display (optional)\ncube.display_type = 'SOLID'\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Y): {math.degrees(cube.rotation_euler.y):.1f}°\")\n```\n</implementation>"}
{"id": 191, "instruction": "Place a Passive cylinder (radius 1.6, height 2.9) at (-3, 0, -4) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static cylindrical obstacle with specific dimensions, position, and orientation. Since it's designated as \"Passive,\" it should function as an immovable object in physics simulations, likely serving as an obstacle or structural element. The rotation around the X-axis will tilt the cylinder forward, affecting how other objects might interact with its slanted surface.\n</strategic_layout>\n\n<spatial_layout>\n- Cylinder radius: 1.6 units\n- Cylinder height: 2.9 units\n- Position: (-3, 0, -4) in XYZ coordinates\n- Rotation: 15° around X-axis = 0.2618 radians\n- The cylinder's base will be at Z = -4 - (2.9/2) = -5.45 before rotation\n- After 15° X-axis rotation, the top tilts toward negative Y direction\n</spatial_layout>\n\n<kinematic_topology>\n- world → cylinder (static mesh with passive rigid body)\n- No joints or constraints needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive object, the cylinder will remain fixed during simulations\n- The 15° tilt creates an inclined surface that may cause objects to slide off\n- With radius 1.6 and height 2.9, the cylinder has substantial footprint and stability\n- Located at (-3, 0, -4), it's positioned away from origin for clear scene arrangement\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.6\n- cylinder_height: 2.9\n- cylinder_location: (-3.0, 0.0, -4.0)\n- cylinder_rotation_x_degrees: 15.0\n- cylinder_rotation_x_radians: 0.2618\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.6,\n    depth=2.9,\n    location=(-3.0, 0.0, -4.0),\n    rotation=(math.radians(15.0), 0.0, 0.0)\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add rigid body physics with passive type\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Set collision margin for stability\ncylinder.rigid_body.collision_margin = 0.0\n\n# Enable visibility of rigid body in viewport\ncylinder.show_rigid_body = True\n\nprint(f\"Created passive cylinder: {cylinder.name}\")\nprint(f\"Location: {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.x):.1f}° on X-axis\")\n```\n</implementation>"}
{"id": 190, "instruction": "Place an Active sphere (radius 2.1) at (0, 10, 0) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a single sphere object with specific geometric properties and physical behavior. The sphere needs to be positioned and oriented precisely in 3D space, then configured as an active rigid body for dynamic simulation. This is a straightforward modeling and physics setup task with no complex mechanisms or constraints to consider beyond the direct parameters.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 2.1 units\n- Sphere Center Position: (X=0.0, Y=10.0, Z=0.0)\n- Rotation: 90° around global Z-axis (Z-axis rotation = π/2 radians = 1.5708 rad)\n- Volume: V = (4/3)πr³ = (4/3)π(2.1)³ ≈ 38.79 cubic units\n- Surface Area: A = 4πr² = 4π(2.1)² ≈ 55.42 square units\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body: sphere_object (Active Rigid Body)\n- No joints or constraints required\n- Root: World origin\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will respond to gravity and collisions in simulations\n- Initial rotation of 90° around Z-axis will affect collision response if the sphere has anisotropic friction or non-uniform mass distribution\n- Position at (0,10,0) places it away from the origin; if gravity is enabled, it will fall along negative Z-axis\n- No stability concerns for a single free object\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.1\n- sphere_location: (0.0, 10.0, 0.0)\n- rotation_z_degrees: 90.0\n- rotation_z_radians: 1.57079632679\n- rigidbody_type: ACTIVE\n- sphere_segments: 32\n- sphere_rings: 16\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified parameters\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.1,\n    location=(0.0, 10.0, 0.0),\n    segments=32,\n    ring_count=16\n)\n\n# Get reference to the created sphere\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 90° rotation around Z-axis (convert degrees to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(90.0))\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\nsphere.rigid_body.friction = 0.5  # Default friction\nsphere.rigid_body.restitution = 0.5  # Default bounciness\n\n# Optional: Set collision shape to SPHERE for optimal performance\nsphere.rigid_body.collision_shape = 'SPHERE'\n\nprint(f\"Created active sphere: {sphere.name}\")\nprint(f\"  Radius: {sphere.dimensions.x / 2}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {math.degrees(sphere.rotation_euler.z)}° around Z-axis\")\n```\n</implementation>"}
{"id": 187, "instruction": "Place a Passive cylinder (radius 0.9, height 3.6) at (3, 0, -8) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nWe are creating a static cylindrical obstacle for a physics simulation. The cylinder is defined as a passive rigid body, meaning it will not move due to collisions but will interact with other objects. The specified location (3, 0, -8) and rotation (45° Z-axis) position it as a tilted barrier in 3D space. This could serve as an obstacle for rolling objects or a structural element in a larger scene.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder dimensions: radius = 0.9 m, height = 3.6 m.\n- World location: (X=3.0, Y=0.0, Z=-8.0). This positions the cylinder's origin (center) at these coordinates.\n- Rotation: 45° around the global Z-axis. Since Blender's default cylinder is aligned vertically (local Z-axis), this rotation spins it around its vertical axis, which is visually symmetric but matters for texture mapping and potential asymmetric collision shapes.\n- The cylinder is a simple primitive, so no further geometric calculations are needed.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body: world -> cylinder (Passive, no joints or constraints)\n- No hierarchical relationships; it's a standalone object.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed in place regardless of collisions.\n- With the origin at Z = -8.0, the cylinder extends from Z = -9.8 (bottom) to Z = -6.2 (top) when unrotated. This places it mostly below the world origin (Z=0).\n- The 45° Z-rotation has no effect on the collision shape for a symmetric cylinder but may affect visual texture orientation.\n- No stability concerns since it's passive and static.\n</predictive_simulation>\n\n<parameter_summary>\ncylinder_radius: 0.9\ncylinder_height: 3.6\ncylinder_location: (3.0, 0.0, -8.0)\ncylinder_rotation_z_deg: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified radius and height\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=0.9,\n    depth=3.6,\n    location=(3.0, 0.0, -8.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply 45-degree rotation around Z-axis (convert degrees to radians)\ncylinder.rotation_euler = (0, 0, math.radians(45.0))\n\n# Add rigid body physics and set to PASSIVE\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'  # Use mesh for accurate cylinder collision\n\n# Optional: Set display to wireframe to see rotation effect\ncylinder.show_wire = True\ncylinder.show_all_edges = True\n```\n</implementation>"}
{"id": 195, "instruction": "Place a Passive cylinder (radius 2.5, height 1.5) at (5, 0, -5) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static cylindrical obstacle with specific dimensions, location, and orientation. The cylinder must be positioned in 3D space and rotated to lie horizontally (perpendicular to its default vertical orientation). As a passive rigid body, it will not move during simulations but will interact with other objects.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius (r): 2.5 units\n- Cylinder height (h): 1.5 units\n- Location: (x, y, z) = (5.0, 0.0, -5.0)\n- Rotation: 90° around Y-axis (converted to radians: π/2 ≈ 1.5708 rad)\n- Default cylinder in Blender is aligned with Z-axis. Rotating 90° around Y-axis makes it align with X-axis.\n- Mesh origin will be at the center of the cylinder after rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n- No joints or constraints needed for a passive object.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed and immovable.\n- The horizontal orientation may create a rolling surface for other objects.\n- Location at negative Z places it below the default ground plane (Z=0), which may be intentional for sub-surface placement.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 2.5\n- height: 1.5\n- location: (5.0, 0.0, -5.0)\n- rotation_y_degrees: 90\n- rotation_y_radians: 1.5708\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=2.5,\n    depth=1.5,\n    location=(5.0, 0.0, -5.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Rotate 90 degrees around Y-axis (convert to radians)\ncylinder.rotation_euler = (0, math.radians(90), 0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n```"}
{"id": 188, "instruction": "Place an Active 2x5x2 cube at (-4, 7, 5) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement task. I need to create a single active rigid body cube with specific dimensions, location, and rotation. The \"active\" designation means it will respond to physics forces like gravity and collisions. The primary consideration is ensuring the dimensions (2×5×2) are correctly interpreted for scaling in Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions (width, depth, height): (2.0, 5.0, 2.0) meters\n- Location: (X=-4.0, Y=7.0, Z=5.0) meters\n- Rotation: 30° around the X-axis (0.5236 radians)\n- Mesh geometry: Starting from a default 2×2×2 Blender cube, scaling factors become (1.0, 2.5, 1.0)\n- World coordinates: Cube's origin (geometric center) will be at specified location\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent object: \"cube_active\"\n- No joints or hierarchical relationships needed\n- Rigid body type: ACTIVE (dynamic simulation)\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube is active, so it will fall under gravity from Z=5m\n- 30° X-axis rotation means it will land on one edge/corner, causing rotational motion\n- Risk: Initial orientation may cause unstable tumbling during descent\n- Mitigation: None needed for basic placement task\n- If other objects exist, collisions will occur normally\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 5.0, 2.0)\n- cube_location: (-4.0, 7.0, 5.0)\n- cube_rotation_x_deg: 30.0\n- cube_rotation_x_rad: 0.5236\n- rigidbody_type: ACTIVE\n- default_cube_size: 2.0\n- scale_factors: (1.0, 2.5, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default 2x2x2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"cube_active\"\n\n# Scale to achieve 2x5x2 dimensions\n# Default cube is 2x2x2, so scale factors: (2/2, 5/2, 2/2) = (1.0, 2.5, 1.0)\ncube.scale = (1.0, 2.5, 1.0)\n\n# Apply scale transformation for accurate physics\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (-4.0, 7.0, 5.0)\n\n# Set rotation (30 degrees around X-axis)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optionally set mass (1kg per cubic meter * volume = 1*20 = 20kg)\ncube.rigid_body.mass = 20.0\n\nprint(f\"Created active cube at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 192, "instruction": "Place an Active 3x2x5 cube at (4, 9, 7) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a rigid body cube with specified dimensions, location, and rotation. The cube must be \"Active\" in the physics simulation context. This requires creating a cube mesh, applying non-uniform scaling to achieve the 3x2x5 dimensions, setting its position to (4,9,7), applying a 45° Y-axis rotation, and configuring it as an active rigid body for dynamic simulation.\n</strategic_layout>\n\n<spatial_layout>\n- Default Blender cube dimensions: 2x2x2 (span from -1 to 1 on each axis).\n- Target dimensions: width (X) = 3m, depth (Y) = 2m, height (Z) = 5m.\n- Scaling factors: (3/2, 2/2, 5/2) = (1.5, 1.0, 2.5).\n- Location: (x=4.0, y=9.0, z=7.0).\n- Rotation: 45° around Y-axis → radians = 45 * π/180 ≈ 0.7854 rad.\n- Center of mass: at the cube's geometric center (4,9,7) due to uniform scaling from origin.\n</spatial_layout>\n\n<kinematic_topology>\n- world → cube (single active rigid body with no joints or constraints).\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube is active and will respond to gravity and collisions in simulations.\n- With mass derived from volume and default density, it may tip/roll when landing due to the 45° rotation creating an unstable initial orientation if not supported.\n- Ensure the cube is above any ground plane (z=7 is likely sufficient if ground is at z=0).\n</predictive_simulation>\n\n<parameter_summary>\n- target_dimensions: (3.0, 2.0, 5.0)\n- location: (4.0, 9.0, 7.0)\n- rotation_y_deg: 45.0\n- rotation_y_rad: 0.785398\n- scale_factors: (1.5, 1.0, 2.5)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube primitive (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scaling for 3x2x5 dimensions\ncube.scale = (1.5, 1.0, 2.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (4.0, 9.0, 7.0)\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Default mass, adjust if needed\n\n# Optional: Add ground plane for context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0,0,0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 193, "instruction": "Place a Passive 5x1x3 cube at (-8, 0, 0) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a static obstacle in the simulation environment. A passive rigid body cube will act as an immovable object. The specified location, rotation, and dimensions define its placement in 3D space.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube location: (-8, 0, 0) in world coordinates (x, y, z).\n- Cube dimensions: 5m (x-axis), 1m (y-axis), 3m (z-axis).\n- Cube rotation: 30° around the global Z-axis. In radians: θ_z = 30 * (π/180) = π/6 ≈ 0.5236 rad.\n- Since the cube's local origin is at its geometric center, the rotation will pivot around that center point at the given location.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Static Mesh with passive rigid body). No joints or hierarchy needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed and immovable during any simulation.\n- The 30° rotation may cause other dynamic objects to slide or deflect at an angle upon collision.\n- No stability risks since the cube is static and anchored by its rigid body type.\n</predictive_simulation>\n\n<parameter_summary>\n- location: (-8.0, 0.0, 0.0)\n- rotation_z_degrees: 30.0\n- rotation_z_radians: 0.5235987756\n- dimensions: (5.0, 1.0, 3.0)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add a cube with initial size 1 (creates a 1x1x1 cube)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Scale to desired dimensions (5, 1, 3)\ncube.scale = (5.0, 1.0, 3.0)\n\n# Set location and rotation\ncube.location = (-8.0, 0.0, 0.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Apply transformations so scale and rotation are baked (clean for physics)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Add rigid body and set to passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 194, "instruction": "Place an Active sphere (radius 1.4) at (2, 8, 8) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single rigid body sphere with active physics properties, placed at a specified location with a non-zero orientation. Since no other objects or constraints are mentioned, the sphere will be the only dynamic entity in the scene. The rotation will affect its initial orientation and potentially its collision behavior if it interacts with other objects later.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (2.0, 8.0, 8.0) in world coordinates.\n- Sphere radius: 1.4 units.\n- Rotation: 60° (π/3 radians) around the global X-axis.\n- Transform order: Location applied first, then rotation (Blender's default).\n- No collisions or supporting structures are specified; the sphere will be in free space.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (single rigid body, no parent)\n- No joints or constraints.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will immediately fall under default gravity (Z = -9.81 m/s²) if simulation is run.\n- The initial rotation may cause uneven collision response if it contacts other objects, but with no other geometry, it will simply tumble during free fall.\n- Risk: Without a passive ground plane, the sphere will fall indefinitely. This is acceptable as the task only specifies creating the sphere.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_location: (2.0, 8.0, 8.0)\n- sphere_radius: 1.4\n- sphere_rotation_x_degrees: 60.0\n- sphere_mass: 1.0 (default)\n- sphere_rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.4, location=(2.0, 8.0, 8.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 60-degree rotation around X-axis (convert to radians)\nsphere.rotation_euler[0] = math.radians(60.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n# Optional: Explicitly set mass (default is 1.0 kg)\nsphere.rigid_body.mass = 1.0\n\n# Ensure the transformation is applied (location and rotation are set, scale is 1)\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n```</implementation>"}
{"id": 196, "instruction": "Place an Active 2x2x6 cube at (0, 7, -7) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body cube with specific dimensions, position, and orientation. Since this is a standalone object without complex mechanisms, the focus is on precise geometric placement and proper rigid body physics setup. The cube should be an \"active\" rigid body, meaning it will respond to gravity and collisions in Blender's physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2m (width) × 2m (depth) × 6m (height)\n- World Position: (x=0.0m, y=7.0m, z=-7.0m)\n- Rotation: 20° around the global Z-axis. In radians: 20° × (π/180) ≈ 0.349066 radians\n- Since rotation is applied around the object's origin (which defaults to geometric center), the entire cube will be rotated 20° around the Z-axis at the specified location.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body hierarchy: world → cube (Active Rigid Body)\n- No joints or constraints required\n- The cube's origin will be at its geometric center\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body, the cube will fall under gravity (z-direction) when simulation starts\n- Rotation Effect: The 20° Z-rotation is purely around the vertical axis, so it doesn't affect the cube's balance or center of mass position relative to gravity\n- Initial State: The cube will be spawned at z=-7m, so it will have potential energy to convert to kinetic energy when falling\n- Risk: No collision risks in initial placement since it's a single object in empty space\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 6.0)\n- cube_location: (0.0, 7.0, -7.0)\n- cube_rotation_z_degrees: 20.0\n- cube_rotation_z_radians: 0.349066\n- rigidbody_type: ACTIVE\n- cube_mass: 10.0 (default, can be adjusted)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with base dimensions (Blender's default cube is 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\n\n# Get reference to the cube\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Scale to achieve 2x2x6 dimensions\n# Since default cube is 2x2x2, we need to scale Z by 3 to get 6m height\ncube.scale = (1.0, 1.0, 3.0)  # (2*1, 2*1, 2*3) = (2, 2, 6)\n\n# Apply scale to make dimensions actual\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (0.0, 7.0, -7.0)\n\n# Set rotation (20 degrees around Z-axis)\n# Convert degrees to radians\nrotation_rad = math.radians(20.0)\ncube.rotation_euler = (0.0, 0.0, rotation_rad)\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 10.0  # 10 kg mass\n\n# Optional: Set collision shape to BOX for better performance\ncube.rigid_body.collision_shape = 'BOX'\n\n# Update viewport to show changes\nbpy.context.view_layer.update()\n\nprint(f\"Created active cube:\")\nprint(f\"  Dimensions: 2.0 × 2.0 × 6.0 m\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {math.degrees(cube.rotation_euler.z):.1f}° around Z-axis\")\nprint(f\"  Rigid Body: {cube.rigid_body.type}, Mass: {cube.rigid_body.mass} kg\")\n```\n</implementation>"}
{"id": 198, "instruction": "Place an Active sphere (radius 0.5) at (7, 6, 3) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nA simple rigid body placement task requiring accurate translation and rotation. The sphere must be active (dynamic) in Blender's physics simulation, meaning it will respond to gravity and collisions. No complex kinematics or constraints are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center location: (x, y, z) = (7.0, 6.0, 3.0) in global coordinates.\n- Sphere radius: r = 0.5 m.\n- Rotation: 45° (π/4 radians) around the global Y-axis.\n- No other geometry or constraints specified.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (single dynamic rigid body).\n- No parent-child relationships or joints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will immediately fall under gravity when simulation starts (default -Z gravity).\n- Without a floor or constraints, it will continue falling indefinitely.\n- Rotation applied as initial state; angular velocity is zero unless impacted.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_location: (7.0, 6.0, 3.0)\n- sphere_radius: 0.5\n- rotation_angle_y: 45.0 (degrees)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere primitive\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.5,\n    location=(7.0, 6.0, 3.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 45° rotation around Y-axis (convert to radians)\nsphere.rotation_euler = (0, math.radians(45.0), 0)\n\n# Assign active rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # default mass\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Optional: Add a simple ground plane for context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Ensure smooth shading for visual clarity\nbpy.ops.object.shade_smooth()\n```\n</implementation>"}
{"id": 180, "instruction": "Place an Active 4x2x2 cube at (1, 9, -1) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body object with specific geometric properties. The 4×2×2 dimensions likely represent width, depth, and height respectively (X, Y, Z in Blender). Positioning at (1, 9, -1) places it in positive X and Y quadrant with negative Z elevation. A 75° Y-axis rotation will orient the object's local coordinate system relative to world axes. Since this is an \"Active\" rigid body, it will respond to gravity and collisions, requiring consideration of stability if other objects exist. The primary challenge is ensuring correct dimension mapping and rotation application.\n</strategic_analysis>\n\n<spatial_layout>\n- World coordinate system: X (right/left), Y (forward/back), Z (up/down)\n- Cube dimensions: width=4.0m (X), depth=2.0m (Y), height=2.0m (Z)\n- Transform sequence: Scale to half-dimensions (Blender's default cube is 2×2×2), then rotate, then translate\n- Rotation: 75° about world Y-axis = 1.308996 radians (conversion: 75 × π/180)\n- Position: (X=1.0, Y=9.0, Z=-1.0)\n- Bounding box extremes after rotation:\n  - Front-right-top corner ≈ (3.035, 10.518, 0.518) \n  - Back-left-bottom corner ≈ (-1.035, 7.482, -2.518)\n  (Calculated via rotation matrix R_y(75°): [[cosθ, 0, sinθ], [0,1,0], [-sinθ,0,cosθ]] applied to (±2, ±1, ±1) offsets)\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent rigid body object with no parent-child hierarchy\n- World origin (0,0,0) → Active_Cube (direct transform)\n- No constraints or joints required\n</kinematic_topology>\n\n<predictive_simulation>\n- Dynamic stability: Cube's center of mass at (1,9,-1) with height 2m means potential tipping if on edge\n- Collision geometry: Rotated bounding box may create asymmetric contact surfaces\n- Gravity effect: Will fall if unsupported (Z=-1 suggests elevation below likely ground plane at Z=0)\n- Recommendation: Add passive ground plane at Z=-2 to catch falling cube\n- Rotation note: 75° rotation tilts cube such that one diagonal edge becomes lowest point\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (4.0, 2.0, 2.0)\ncube_location: (1.0, 9.0, -1.0)\ncube_rotation_y_degrees: 75.0\ncube_rotation_y_radians: 1.308996\nground_plane_size: 20.0\nground_plane_location: (0.0, 0.0, -2.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create ground plane (passive rigid body)\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0.0, 0.0, -2.0))\nground = bpy.context.active_object\nground.name = \"Ground_Plane\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Create cube with specified dimensions\n# Blender's default cube is 2×2×2, so we scale by half dimensions\nscale_factors = (\n    4.0 / 2.0,  # X scale\n    2.0 / 2.0,  # Y scale  \n    2.0 / 2.0   # Z scale\n)\n\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply scaling\ncube.scale = scale_factors\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Apply rotation (Y-axis, 75°)\ncube.rotation_euler = (0.0, math.radians(75.0), 0.0)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Apply translation\ncube.location = (1.0, 9.0, -1.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 2.0  # Default mass (optional)\ncube.rigid_body.collision_shape = 'BOX'\n\n# Set up physics scene\nbpy.context.scene.rigidbody_world.steps_per_second = 60\nbpy.context.scene.rigidbody_world.solver_iterations = 10\n\n# Frame range for simulation\nbpy.context.scene.frame_start = 1\nbpy.context.scene.frame_end = 250\n\nprint(f\"Created active cube '{cube.name}'\")\nprint(f\"  Dimensions: {cube_dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {math.degrees(cube.rotation_euler.y):.1f}° around Y-axis\")\n```\n</implementation>"}
{"id": 199, "instruction": "Place a Passive cylinder (radius 1, height 6) at (-1, 0, 10) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single static cylindrical obstacle with specific dimensions, placement, and orientation. As a passive rigid body, it will remain fixed during simulations but may interact with other objects. The primary considerations are accurate geometric modeling and proper rigid body property assignment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0 unit\n- Cylinder height: 6.0 units\n- World location: (-1.0, 0.0, 10.0) in XYZ coordinates\n- Rotation: 30° about the global Z-axis, which equals 0.523599 radians\n- The cylinder's base will be centered at Z=10, so the cylinder extends from Z=7 to Z=13 along its local axis\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_object (Single rigid body with no parent-child relationships)\n- No joints or constraints required for this static object\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain stationary during physics simulations\n- The 30° rotation may cause objects sliding against it to deflect at an angle\n- The height of 6 units and center position at Z=10 creates a substantial obstacle for most mechanisms\n- No stability concerns for fixed objects\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.0\n- cylinder_height: 6.0\n- location: (-1.0, 0.0, 10.0)\n- rotation_z_degrees: 30.0\n- rotation_z_radians: 0.523599\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=6.0,\n    location=(-1.0, 0.0, 10.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply rotation: 30 degrees about Z-axis\n# Convert to radians and create rotation Euler\nrotation_rad = math.radians(30.0)\ncylinder.rotation_euler = Euler((0.0, 0.0, rotation_rad), 'XYZ')\n\n# Add rigid body physics with passive type\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to mesh for accurate interactions\ncylinder.rigid_body.collision_shape = 'MESH'\n\nprint(f\"Created {cylinder.name} at {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.z):.1f}° about Z-axis\")\n```\n</implementation>"}
{"id": 197, "instruction": "Place a Passive 4x3x2 cube at (-2, 0, 1) and rotate it 35° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to create a static passive obstacle in the scene - a rigid body cube with specified dimensions, position, and rotation. This cube will act as a non-moving collider in physics simulations. The implementation requires precise geometric placement and proper rigid body configuration.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 4m (X) × 3m (Y) × 2m (Z)\n- World Location: (-2, 0, 1) in meters (X,Y,Z)\n- Rotation: 35° around X-axis (Euler rotation)\n- Note: Default Blender cube is 2m³, so scaling factors are (2.0, 1.5, 1.0)\n- Center Position: The location (-2, 0, 1) represents the cube's center\n</spatial_layout>\n\n<kinematic_topology>\n- world → passive_cube (Single rigid body mesh with no joints or hierarchy)\n- The cube is a standalone passive rigid body with no kinematic dependencies\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None for placement; cube is static passive rigid body\n- Collision: Cube will interact with active rigid bodies but remain fixed\n- Stability: As a passive object with no mass requirement, it will not move\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 3.0, 2.0)\n- cube_location: (-2.0, 0.0, 1.0)\n- cube_rotation_x: 35.0 (degrees)\n- rigidbody_type: PASSIVE\n- scale_factors: (2.0, 1.5, 1.0)  # From default 2m cube\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2m³ at origin)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Set scale to achieve 4×3×2 dimensions\n# Default cube is 2m in each dimension, so scale factors:\n# X: 4.0/2.0 = 2.0, Y: 3.0/2.0 = 1.5, Z: 2.0/2.0 = 1.0\ncube.scale = (2.0, 1.5, 1.0)\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-2.0, 0.0, 1.0)\ncube.rotation_euler = (math.radians(35.0), 0.0, 0.0)\n\n# Add rigid body physics as PASSIVE\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX for accuracy\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {[math.degrees(angle) for angle in cube.rotation_euler]}\")\n```\n</implementation>"}
{"id": 200, "instruction": "Place an Active 3x3x1 cube at (9, 7, -2) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single active rigid body cube with specified dimensions, location, and orientation. This is a foundational task for constructing dynamic scenes. The cube's active rigid body property will allow it to respond to physics simulations. The 90-degree X-axis rotation will orient the cube's local axes, which may affect collision interactions and visual appearance.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 3m (X) × 3m (Y) × 1m (Z) [scale vector (3,3,1) applied to unit cube].\n- World Location: (9, 7, -2) in global coordinates.\n- Rotation: 90° about X-axis = π/2 radians (1.5708 rad).\n- Geometric Center: The cube's origin will be at the specified location post-rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single Active Rigid Body, no hierarchical dependencies).\n- No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body, the cube will fall under gravity unless supported.\n- Rotation Impact: The 90° X-axis rotation means the cube's local Z-axis now aligns with world Y-axis. This orientation may cause the cube to tip or roll depending on initial contact surfaces.\n- Collision Geometry: The rotated bounding box dimensions remain (3,3,1) in world space, but the visual mesh is rotated.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 3.0, 1.0)\n- cube_location: (9.0, 7.0, -2.0)\n- cube_rotation: (1.5708, 0.0, 0.0) [radians]\n- rigidbody_type: 'ACTIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create unit cube\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply dimensions via scale (alternatively set dimensions directly)\ncube.scale = (3.0, 3.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (9.0, 7.0, -2.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)  # 90° about X\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Default mass (optional)\n```\n</implementation>"}
{"id": 203, "instruction": "Place a Passive sphere (radius 1) at (-2, 0, 6) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a static sphere with specific placement and orientation. As a passive rigid body, it won't respond to physics but can interact with active bodies. The sphere's radius is given, and we need precise coordinate and rotation transformations.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (-2.0, 0.0, 6.0) in world coordinates.\n- Sphere radius: 1.0m (diameter 2.0m).\n- Rotation: 30° around Z-axis (Euler rotation (0,0,30°)). Convert to radians: θ_z = 30° × (π/180) ≈ 0.5236 rad.\n- No other geometric constraints required.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_sphere (Single rigid body with fixed transform)\n- No joints or hierarchical constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the sphere will remain fixed at its location.\n- Interactions: Other active rigid bodies may collide with it, but the sphere won't move.\n- Risk: None, given the simplicity of the task.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.0\nsphere_location: (-2.0, 0.0, 6.0)\nsphere_rotation_z_degrees: 30.0\nsphere_rotation_z_radians: 0.5235987755982988\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with radius 1.0\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.0)\nsphere = bpy.context.active_object\nsphere.name = \"Passive_Sphere\"\n\n# Set location\nsphere.location = (-2.0, 0.0, 6.0)\n\n# Set rotation: 30 degrees around Z-axis (convert to radians)\nsphere.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Add rigid body physics with PASSIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 202, "instruction": "Place an Active 1x1x1 cube at (2, 6, 2) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nCreate a single active rigid body cube at a specific 3D coordinate with a 15-degree rotation around the X-axis. This requires precise object placement and orientation in Blender's global coordinate system, with the cube set to actively participate in physics simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 1×1×1 meters (scale of 0.5 in Blender's default 2m cube).\n- World position: (2.0, 6.0, 2.0) in global coordinates.\n- Rotation: 15° about X-axis → 0.261799 radians (converted for Blender's radian system).\n- No translation/rotation hierarchy needed.\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent object:\n- world → active_cube (Free rigid body with no parent)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is symmetric and properly placed; no tipping risk.\n- Physics: As an active rigid body, cube will respond to gravity and collisions if simulation runs.\n- Validation: Verify rotation uses local X-axis after placement.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_location: (2.0, 6.0, 2.0)\n- cube_rotation_x_deg: 15.0\n- cube_rotation_x_rad: 0.261799\n- cube_scale: (0.5, 0.5, 0.5)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube (Blender default is 2x2x2, so scale by 0.5 for 1x1x1)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"active_cube\"\n\n# Set scale to 0.5 for 1m cube (since default 2m cube)\ncube.scale = (0.5, 0.5, 0.5)\n\n# Set location and rotation\ncube.location = (2.0, 6.0, 2.0)\ncube.rotation_euler = (math.radians(15.0), 0.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0\n\n# Apply transforms to make scale and rotation explicit\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Optional: Set visual origin to geometry center\nbpy.context.view_layer.objects.active = cube\nbpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n```\n</implementation>"}
{"id": 206, "instruction": "Place an Active sphere (radius 0.7) at (-4, 5, 4) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a sphere with rigid body physics enabled at a specific location with a specific rotation. The main consideration is ensuring the sphere is correctly positioned, rotated, and configured as an \"ACTIVE\" rigid body type so it responds to gravity and collisions in Blender's physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius: 0.7m\n- Initial Location: (-4.0, 5.0, 4.0) in global XYZ coordinates\n- Initial Rotation: 90° about the global Z-axis. In radians: 90° * (π/180°) = 1.5708 rad\n- The sphere is a single primitive; no complex assembly is required.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single rigid body with no parent)\n- No joints or constraints are required.\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere is set as an ACTIVE rigid body, meaning it will fall under gravity (default -9.81 m/s² in Z) upon simulation start.\n- Starting at Z=4.0 provides potential energy.\n- The 90° Z-rotation is purely visual/orientational for a sphere but will be applied.\n- No stability risks as it's a simple free-falling object.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.7\n- location: (-4.0, 5.0, 4.0)\n- rotation_z_degrees: 90\n- rotation_z_radians: 1.5708\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects in the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.7, location=(-4, 5, 4))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 90-degree rotation about the Z-axis (convert to radians)\nsphere.rotation_euler = (0, 0, math.radians(90))\n\n# Add rigid body physics and set to ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n\n# Optionally, set mass (default is 1.0 kg) and other physics properties\n# sphere.rigid_body.mass = 1.0\n```\n</implementation>"}
{"id": 204, "instruction": "Place an Active cylinder (radius 1, height 2) at (4, 7, -3) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a single active rigid body cylinder with specific geometric properties, position, and orientation. This is a straightforward modeling and physics setup exercise. The cylinder must be placed exactly at the given coordinates and rotated 45 degrees around its local Y-axis, then assigned active rigid body properties for dynamic simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center location: (x=4.0, y=7.0, z=-3.0)\n- Cylinder radius: 1.0 unit\n- Cylinder height: 2.0 units\n- Rotation: 45° around the Y-axis (local coordinate system).\n- Rotation conversion: 45° * (π/180) = 0.785398 radians\n- Note: Blender's default cylinder is created vertically aligned with the Z-axis. A Y-axis rotation of 45° will tilt it appropriately.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Single active rigid body, no hierarchical joints)\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cylinder will respond to gravity and collisions in the simulation.\n- With its center at z=-3 and height 2, the cylinder's bottom will be at z=-4 and top at z=-2.\n- The 45° Y-axis rotation gives it a diagonal orientation, affecting its rolling/tipping behavior.\n- No stability risks since it's a single dynamic object.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (4.0, 7.0, -3.0)\n- cylinder_radius: 1.0\n- cylinder_height: 2.0\n- cylinder_rotation_y_degrees: 45.0\n- cylinder_rotation_y_radians: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    radius=1.0,\n    depth=2.0,\n    location=(4.0, 7.0, -3.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"ActiveCylinder\"\n\n# Apply 45-degree rotation around Y-axis (convert to radians)\ncylinder.rotation_euler = (0, math.radians(45.0), 0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 1.0  # Default mass\ncylinder.rigid_body.friction = 0.5\ncylinder.rigid_body.restitution = 0.1\n\n# Ensure visual smoothness\nbpy.ops.object.shade_smooth()\n\n# Set up a ground plane for reference\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, -5))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\nprint(f\"Cylinder created at {cylinder.location}\")\nprint(f\"Cylinder rotation (degrees): {math.degrees(cylinder.rotation_euler.y)}\")\n```\n</implementation>"}
{"id": 205, "instruction": "Place a Passive 2x2x2 cube at (6, 0, 6) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a static passive rigid body cube with specific dimensions, location, and orientation. As a passive object, it will not respond to forces but can collide with active bodies. The primary considerations are precise geometric placement and correct rigid body property assignment. The cube's rotation around the X-axis will tilt it forward, affecting its collision bounds.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2m × 2m × 2m (from -1 to +1 on all axes in object space).\n- World Location: (6, 0, 6) places the cube's origin at this point in global coordinates.\n- Rotation: 60° around X-axis = 1.0472 radians. This tilts the cube forward, with the top face leaning toward positive Z and negative Y.\n- Base Plane: Cube's bottom face (in local coordinates) will be oriented at a 60° angle relative to the ground plane (XY-plane).\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent object: passive_cube (Direct child of world origin).\n- No joints or constraints required.\n- Rigid body type: PASSIVE (immovable collision object).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cube will remain fixed regardless of rotation.\n- Collision: The 60° rotation creates tilted collision planes that will deflect active bodies asymmetrically.\n- Risk: None beyond ensuring correct transform and rigid body settings.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_size: 2.0\n- cube_location: (6.0, 0.0, 6.0)\n- cube_rotation_x_deg: 60.0\n- cube_rotation_x_rad: 1.0471975511965976\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with dimensions 2x2x2\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"passive_cube\"\n\n# Set location\ncube.location = (6.0, 0.0, 6.0)\n\n# Convert 60 degrees to radians and apply X rotation\ncube.rotation_euler = (math.radians(60.0), 0.0, 0.0)\n\n# Add rigid body physics as passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n```</implementation>"}
{"id": 207, "instruction": "Place a Passive cylinder (radius 1.2, height 3) at (1, 0, -6) and rotate it 25° on the Y-axis.", "answer": "<strategic_analysis>\nWe need to create a passive rigid body cylinder with precise dimensions and placement. The cylinder will serve as a static obstacle in a physics simulation. The task is purely geometric/kinematic with no dynamic behavior required beyond being a passive collision object. We must ensure the cylinder's local coordinate system aligns properly with world axes after applying the Y-axis rotation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.2 units\n- Cylinder height: 3.0 units\n- Base location: (x=1.0, y=0.0, z=-6.0) in world coordinates\n- Rotation: 25° counterclockwise around the global Y-axis (when viewed from above)\n- Since Blender's cylinder primitive is created vertically along the Z-axis, a 25° Y rotation will tilt it forward/backward relative to the XZ plane\n- No clearance issues since it's a standalone object\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n- No joints or parent-child relationships needed\n- All transformations applied directly to the cylinder object\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed during simulation\n- The 25° Y-axis rotation may affect collision interactions if other objects slide against it\n- Center of mass remains at object origin (midpoint of cylinder height)\n- No stability concerns for static geometry\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.2\n- cylinder_height: 3.0\n- location: (1.0, 0.0, -6.0)\n- rotation_y_degrees: 25.0\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\nfrom mathutils import Euler\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,  # Smooth default resolution\n    radius=1.2,\n    depth=3.0,\n    location=(1.0, 0.0, -6.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply 25-degree rotation around Y-axis\n# Convert degrees to radians for Euler rotation\nrotation_rad = math.radians(25.0)\ncylinder.rotation_euler = Euler((0.0, rotation_rad, 0.0), 'XYZ')\n\n# Add rigid body physics with PASSIVE type\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'  # Use exact mesh for collision\n\n# Optional: Set collision margin for stability\ncylinder.rigid_body.collision_margin = 0.0\n\n# Validate transformations\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\nprint(f\"Created cylinder at {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler.y):.1f}° around Y-axis\")\n```\n</implementation>"}
{"id": 210, "instruction": "Place an Active sphere (radius 2) at (5, 9, 0) and rotate it 75° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is to create a single active rigid body sphere with specified dimensions, position, and orientation. This is a basic 3D modeling and physics setup. The sphere will be affected by gravity and any other physics simulations in the scene due to its active rigid body property.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (5.0, 9.0, 0.0) in world coordinates.\n- Sphere radius: 2.0 units.\n- Rotation: 75° around the global Y-axis, applied as an Euler rotation (0, 75°, 0) in degrees.\n</spatial_layout>\n\n<kinematic_topology>\nSingle object: sphere (Rigid Body, Active). No parent-child hierarchy.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will immediately fall under gravity (if gravity is enabled) starting from (5,9,0). \n- The rotation does not affect the center of mass or the gravitational effect, but it sets the initial orientation.\n- Risk: The sphere starts at Z=0, so it is on the ground plane if one exists. If the ground is a passive rigid body, the sphere may rest or bounce depending on physics settings.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.0\n- sphere_location: (5.0, 9.0, 0.0)\n- sphere_rotation_y_degrees: 75.0\n- sphere_mass: 1.0 (default for rigid body)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects in the scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create a UV sphere with radius 2\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.0, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation\nsphere.location = (5.0, 9.0, 0.0)\n# Convert 75 degrees to radians for rotation_euler\nsphere.rotation_euler = (0, math.radians(75.0), 0)\n\n# Add rigid body physics and set to ACTIVE\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n# Optionally set mass (default is 1.0 kg, but we can be explicit)\nsphere.rigid_body.mass = 1.0\n```\n</implementation>"}
{"id": 208, "instruction": "Place an Active 1x4x1 cube at (0, 8, 5) and rotate it 45° on the X-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body object with specific dimensions, location, and orientation. The \"Active\" designation indicates it should be an active rigid body in Blender's physics system. Since it's a standalone object without joints or mechanisms, the implementation focuses on proper mesh creation, transformation application, and rigid body property assignment.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: 1m (width/X) × 4m (depth/Y) × 1m (height/Z)\n- Location coordinates: X=0m, Y=8m, Z=5m\n- Rotation: 45° about X-axis (0.7854 radians)\n- Scale factors: Since default Blender cube is 2×2×2, scaling by (0.5, 2.0, 0.5) achieves 1×4×1 dimensions\n- Mesh origin at cube center post-scaling\n</spatial_layout>\n\n<kinematic_topology>\n- Single object hierarchy: world → active_cube (Active Rigid Body)\n- No joints or parent-child relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, cube will respond to gravity and collisions\n- Initial rotation may affect falling/rolling behavior if simulation runs\n- Center of mass automatically at geometric center due to uniform density\n- No stability concerns for single object placement\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 4.0, 1.0)\n- cube_location: (0.0, 8.0, 5.0)\n- x_rotation_degrees: 45.0\n- default_cube_size: 2.0\n- scale_factors: (0.5, 2.0, 0.5)\n- rotation_radians: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Scale to achieve 1x4x1 dimensions\ncube.scale = (0.5, 2.0, 0.5)  # (1/2, 4/2, 1/2)\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Set location\ncube.location = (0.0, 8.0, 5.0)\n\n# Apply 45° X-axis rotation\ncube.rotation_euler.x = math.radians(45.0)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0  # Default mass\n\n# Verify final transform\nprint(f\"Cube created at: {cube.location}\")\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube rotation (degrees): {[math.degrees(r) for r in cube.rotation_euler]}\")\n```\n</implementation>"}
{"id": 211, "instruction": "Place a Passive 4x1x1 cube at (8, 0, -1) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static object placement task. The objective is to create a passive (non-moving) rectangular prism with specified dimensions, position, and orientation. The \"passive\" designation indicates it should act as a static obstacle or platform in a physics simulation. The rotation around the X-axis will tilt the object forward or backward relative to the global coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Object Type: Cuboid (Cube mesh).\n- Dimensions: Length (X) = 4.0, Width (Y) = 1.0, Height (Z) = 1.0.\n- World Location: (X=8.0, Y=0.0, Z=-1.0). The Z-coordinate places the object's origin 1 unit below the global ground plane (Z=0).\n- Rotation: 30 degrees about the global X-axis. In Blender, this is applied as an Euler rotation (30°, 0°, 0°).\n- Origin: By default, a Blender cube's origin is at its geometric center. Therefore, the final world position of the cube's center will be (8, 0, -1).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Static Mesh with Passive Rigid Body)\n- No joints or hierarchical parents required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object anchored in place, it is inherently stable.\n- Interaction: Other active rigid bodies may collide with it. The 30° tilt will create an inclined plane, affecting collision responses and potential sliding/rolling dynamics of other objects.\n- Risk: None for the object itself. Potential risk of interpenetration if other objects are spawned inside it.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 1.0, 1.0)\n- cube_location: (8.0, 0.0, -1.0)\n- cube_rotation_x_degrees: 30.0\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects (optional, clean start)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with base dimensions of 2 (Blender default)\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"passive_cube\"\n\n# Scale to achieve 4x1x1 dimensions (scale = desired / default)\n# Default cube is 2x2x2, so scaling factor = desired_dimension / 2.0\ncube.scale.x = 4.0 / 2.0  # Length\ncube.scale.y = 1.0 / 2.0  # Width\ncube.scale.z = 1.0 / 2.0  # Height\n\n# Apply scale to make dimensions intrinsic\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (8.0, 0.0, -1.0)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n``` \n</implementation>"}
{"id": 209, "instruction": "Place a Passive 3x2x1 cube at (-6, 0, 3) and rotate it 15° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric placement: create a passive rigid body cube with specific dimensions, location, and orientation. No dynamic simulation or complex physics needed beyond rigid body setup. We must ensure the cube's dimensions (3x2x1) are correctly implemented, the passive rigid body is configured, and the rotation is applied properly around the cube's local Z-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 3m, Depth (Y) = 2m, Height (Z) = 1m\n- Location: World coordinates (-6, 0, 3)\n- Rotation: 15° counterclockwise around Z-axis (looking from positive Z)\n- Mathematical conversion: rotation_angle_radians = 15 × π / 180 = π/12 ≈ 0.2618 rad\n- The cube's center will be at the specified location after rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- World -> cube (single static mesh with passive rigid body)\n- No joints or hierarchy needed - standalone object\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will remain fixed during simulation but will participate in collisions\n- Center of mass will be at geometric center\n- No stability concerns since it's static\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 2.0, 1.0)\n- cube_location: (-6.0, 0.0, 3.0)\n- cube_rotation_z_deg: 15.0\n- cube_rotation_z_rad: 0.2617993877991494\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions (Blender's default cube is 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Scale to achieve 3x2x1 dimensions\n# Default cube vertices range from -0.5 to 0.5, so scaling by (3,2,1) gives proper dimensions\ncube.scale = (3.0, 2.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-6.0, 0.0, 3.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(15.0))\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Ensure collision shape is BOX (appropriate for cubes)\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set display properties for clarity\ncube.show_wire = True\ncube.show_all_edges = True\n\nprint(f\"Created passive cube:\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Z): {math.degrees(cube.rotation_euler.z):.1f}°\")\nprint(f\"  Rigid Body Type: {cube.rigid_body.type}\")\n```</implementation>"}
{"id": 214, "instruction": "Place an Active sphere (radius 1.3) at (-7, 6, -2) and rotate it 45° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a spherical rigid body with active physics at a specific 3D location and orientation. This requires precise coordinate placement, proper rigid body physics setup, and correct rotational transformation. The sphere's radius is substantial (1.3 units), so it will have noticeable physical presence in simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius (r): 1.3 units\n- Location coordinates: (x, y, z) = (-7.0, 6.0, -2.0)\n- Rotation: 45° around X-axis → Rotation vector: (π/4, 0, 0) radians\n- Mesh vertices will be transformed by this rotation before physics simulation begins\n- The sphere center will be exactly at the specified coordinates after transformation\n</spatial_layout>\n\n<kinematic_topology>\n- world (global coordinate system)\n  └── sphere_object (Active Rigid Body with mesh and physics properties)\n- No hierarchical joints or constraints needed for this isolated object\n- Transformation order: Apply rotation first (around object origin), then translation\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will respond to gravity and collisions\n- Initial rotation around X-axis means the sphere's poles will be tilted 45° relative to world Z-axis\n- Starting at negative Z coordinate (-2) means it may fall if gravity is enabled\n- No stability risks since it's a single object with symmetrical geometry\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.3\n- location_x: -7.0\n- location_y: 6.0\n- location_z: -2.0\n- rotation_x_degrees: 45.0\n- rotation_x_radians: 0.7853981633974483\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=1.3,\n    location=(-7.0, 6.0, -2.0),\n    scale=(1, 1, 1)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 45° rotation around X-axis (convert to radians)\nrotation_rad = math.radians(45.0)\nsphere.rotation_euler = (rotation_rad, 0.0, 0.0)\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n\n# Set reasonable default physics properties\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Apply rotation transformation to mesh data\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=False)\n\nprint(f\"Created active sphere at {sphere.location}\")\nprint(f\"Rotation: {math.degrees(sphere.rotation_euler.x):.1f}° around X-axis\")\n```\n</implementation>"}
{"id": 218, "instruction": "Place an Active sphere (radius 2.6) at (6, 10, 3) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to place a sphere with rigid body physics at a specific location and orientation. This requires creating a UV sphere primitive with the correct dimensions, positioning it in 3D space, applying rotation, and configuring physics properties for dynamic simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: (x=6.0, y=10.0, z=3.0)\n- Sphere radius: 2.6 units\n- Initial rotation: 90° about the Z-axis (mathematically: rotation_z = π/2 radians ≈ 1.5708 rad)\n- The rotation will orient the sphere's pole axis (typically the vertical axis in Blender's default sphere) to align with the XY-plane.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single rigid body with no parent)\n- No joint constraints required (free rigid body)\n- Sphere mesh defines collision boundary for physics simulation\n</kinematic_topology>\n\n<predictive_simulation>\n- As an ACTIVE rigid body, the sphere will respond to gravity and collisions once simulation starts.\n- Initial rotation may affect rolling behavior if placed on an inclined surface.\n- Sphere radius (2.6) ensures substantial mass if using default density, creating noticeable momentum.\n- No stability risks since it's a single object in free space.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 2.6\n- sphere_location: (6.0, 10.0, 3.0)\n- sphere_rotation_z_degrees: 90.0\n- sphere_rotation_z_radians: 1.57079632679\n- rigidbody_type: ACTIVE\n- segments: 32 (default for clean mesh)\n- rings: 16 (default for clean mesh)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create UV sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.6,\n    location=(6.0, 10.0, 3.0),\n    segments=32,\n    ring_count=16\n)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 90-degree rotation around Z-axis (convert to radians)\nsphere.rotation_euler = (0, 0, math.radians(90.0))\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'MESH'\nsphere.rigid_body.mass = 1.0  # Default mass\n\n# Ensure transformation is applied\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\nprint(f\"Created active sphere at {sphere.location} with rotation {sphere.rotation_euler}\")\n```\n</implementation>"}
{"id": 212, "instruction": "Place an Active cylinder (radius 0.8, height 2.5) at (-1, 7, 6) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a cylindrical rigid body with specific geometric properties and spatial orientation. The cylinder must be active (dynamic physics object) rather than static. The main considerations are correct dimensional scaling, accurate positioning in 3D space, and proper rotation transformation. Since the cylinder is active, it will respond to gravity and collisions. We'll ensure the mass properties are reasonable for the given size.\n</strategic_layout>\n\n<spatial_layout>\n- Cylinder radius (r): 0.8 units\n- Cylinder height (h): 2.5 units  \n- Base Blender cylinder primitive has radius=1, height=2, centered at origin\n- Scale factors: X = Y = 0.8/1.0 = 0.8, Z = 2.5/2.0 = 1.25\n- Translation vector: (-1, 7, 6)\n- Rotation: 60° about global Z-axis = 1.047197551 radians\n- Center of mass: At cylinder's geometric center (0,0,0 in local coordinates)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Active Rigid Body)\n- Single rigid body with no joints or constraints\n- Transform hierarchy: world directly parents cylinder mesh with applied transformations\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cylinder will fall under gravity unless supported\n- Risk: With only Z-axis rotation, cylinder may roll if placed on edge\n- Mitigation: Default rigid body properties (mass=1kg) appropriate for size\n- Note: Location places cylinder at (x,y,z)=(-1,7,6) which is high above origin - will fall unless collision floor exists\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.8\n- cylinder_height: 2.5\n- location: (-1.0, 7.0, 6.0)\n- rotation_z_degrees: 60.0\n- rotation_z_radians: 1.047197551\n- scale_x: 0.8\n- scale_y: 0.8  \n- scale_z: 1.25\n- rigidbody_type: ACTIVE\n- mass: 1.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with base dimensions (radius=1, height=2)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=2.0,\n    location=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"ActiveCylinder\"\n\n# Apply scale transformation for correct dimensions\ncylinder.scale = (0.8, 0.8, 1.25)  # Based on parameter summary\n\n# Set location and rotation\ncylinder.location = (-1.0, 7.0, 6.0)\ncylinder.rotation_euler = (0, 0, math.radians(60.0))\n\n# Apply transformations to mesh data\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'ACTIVE'\ncylinder.rigid_body.mass = 1.0\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Optional: Create ground plane for stability demonstration\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 213, "instruction": "Place a Passive 2x3x3 cube at (3, 0, -7) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a rigid body cube with specific dimensions, placement, and orientation. The cube is passive (immovable) which means we don't need to consider dynamics, only static geometry. The main challenge is correctly interpreting \"2x3x3\" dimensions and applying the 90° Y-axis rotation relative to Blender's coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 2m, Depth (Y) = 3m, Height (Z) = 3m\n- Location: Center point at (X=3, Y=0, Z=-7)\n- Rotation: 90° around Y-axis converts to radians: θ = 90° × π/180 = 1.5708 rad\n- Since we start with a default cube (2×2×2), scaling factors are: X=1.0, Y=1.5, Z=1.5 (desired ÷ original = 2/2, 3/2, 3/2)\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Static mesh with rigid body physics)\n- No joints or hierarchy needed since it's a single static object.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body, the cube will remain fixed regardless of its orientation.\n- Collision: The cube's rotated orientation may affect interactions with other objects, but this is by design.\n- No dynamic risks since the object is passive.\n</predictive_simulation>\n\n<parameter_summary>\n- location: (3.0, 0.0, -7.0)\n- rotation_y: 1.5708\n- scale: (1.0, 1.5, 1.5)\n- dimensions: (2.0, 3.0, 3.0)\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply scaling for 2×3×3 dimensions\ncube.scale = (1.0, 1.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set final location and rotation\ncube.location = (3.0, 0.0, -7.0)\ncube.rotation_euler = (0.0, math.radians(90.0), 0.0)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 215, "instruction": "Place a Passive cylinder (radius 1, height 4) at (0, 0, 12) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a static cylindrical obstacle at a specified location and orientation. Since the cylinder is passive, it will not move in simulations. This is a straightforward modeling task with no dynamic constraints.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0 unit.\n- Cylinder height: 4.0 units.\n- Location: (0, 0, 12) in world coordinates.\n- Rotation: 20° around the global Z-axis, which corresponds to (0, 0, 20) in degrees, or (0, 0, 0.349066) radians (since 20° * π/180 ≈ 0.349066 rad).\n- The cylinder's local Z-axis aligns with its height; rotation around Z will twist it about its central axis.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object, the cylinder will remain fixed. Its high position (Z=12) means it will not interact with ground-level objects unless they are elevated.\n- Risk: None. The cylinder is static and will not topple or move.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 1.0\n- height: 4.0\n- location: (0.0, 0.0, 12.0)\n- rotation_z_deg: 20.0\n- rotation_z_rad: 0.349066\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified radius and height (depth in Blender)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,  # Default resolution\n    radius=1.0,\n    depth=4.0,\n    location=(0.0, 0.0, 12.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply rotation (20° around Z-axis)\ncylinder.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to CYLINDER for accuracy\ncylinder.rigid_body.collision_shape = 'CYLINDER'\n\nprint(f\"Created '{cylinder.name}' at {cylinder.location}, rotated {cylinder.rotation_euler.z:.3f} rad.\")\n```\n</implementation>"}
{"id": 216, "instruction": "Place an Active 5x2x1 cube at (2, 9, -4) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a single active rigid body cube with specific dimensions, position, and rotation. Since this is a solitary object without complex interactions, we can directly implement the geometric transformations. The cube should be created with the correct dimensions, positioned at (2, 9, -4), and rotated 35° around the Y-axis, then configured as an active rigid body for physical simulation.\n</strategic_layout>\n\n<spatial_layout>\n- Cube dimensions: width (X)=5, depth (Y)=2, height (Z)=1.\n- Location: (x=2.0, y=9.0, z=-4.0).\n- Rotation: 35° around Y-axis. In radians: θ = 35° × (π/180) ≈ 0.610865 rad.\n- Since the default Blender cube is 2×2×2, we need to scale by (5/2, 2/2, 1/2) = (2.5, 1.0, 0.5).\n- The pivot point is at the object's origin, which will be at the specified location after transformation.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body: world → cube (Active Rigid Body)\n- No joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None beyond ensuring correct dimensions and rigid body properties.\n- Stability: As an active rigid body, the cube will respond to gravity and collisions appropriately.\n- Verification: The cube's bounding box should measure exactly 5×2×1 units in its local axes when unrotated.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (5.0, 2.0, 1.0)\n- cube_location: (2.0, 9.0, -4.0)\n- cube_rotation_y_deg: 35.0\n- cube_scale_factors: (2.5, 1.0, 0.5)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nfrom math import radians\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Set dimensions via scale (from 2x2x2 to 5x2x1)\ncube.scale = (2.5, 1.0, 0.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (2.0, 9.0, -4.0)\ncube.rotation_euler = (0, radians(35.0), 0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'BOX'\ncube.rigid_body.mass = 1.0  # Default mass\n\n# Optional: Verify dimensions\nprint(f\"Cube dimensions: {cube.dimensions}\")\nprint(f\"Cube location: {cube.location}\")\nprint(f\"Cube rotation (Y): {cube.rotation_euler.y} rad\")\n```\n</implementation>"}
{"id": 221, "instruction": "Place a Passive 2x2x5 cube at (1, 0, -9) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a stationary rigid body with specific dimensional and positional constraints. A passive rigid body will remain fixed during simulations while serving as an environmental obstacle or structural element. The 30° Z-axis rotation adds orientation complexity beyond basic placement.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 2×2×5 meters (X×Y×Z).\n- Location: (1, 0, -9) meters in global coordinates.\n- Rotation: 30° around Z-axis → 0.523599 radians.\n- Volume Calculation: 2×2×5 = 20 m³.\n- Geometric Center: At specified location (1, 0, -9), which becomes the object's origin after creation.\n</spatial_layout>\n\n<kinematic_topology>\n- world → passive_cube (Single rigid body with no parent)\n- Joints: None (static passive object)\n- Transformation Hierarchy: Direct world transformation with translation and rotation applied to object origin.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk Assessment: None for static passive geometry.\n- Collision Geometry: The 5m height creates potential interaction volume above ground plane at Z=-9.\n- Orientation Impact: 30° rotation changes collision normal directions, affecting bounce angles for dynamic objects.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (2.0, 2.0, 5.0)\ncube_location: (1.0, 0.0, -9.0)\ncube_rotation_z_degrees: 30.0\ncube_rotation_z_radians: 0.523599\nrigidbody_type: 'PASSIVE'\nobject_name: 'Passive_Cube'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with specified dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply dimensions (scale from unit cube)\ncube.scale = (2.0, 2.0, 5.0)\n\n# Set location and rotation\ncube.location = (1.0, 0.0, -9.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Apply transforms to make scale (1,1,1) with actual dimensions\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX for accuracy\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Created {cube.name} at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 219, "instruction": "Place a Passive cylinder (radius 1.5, height 2) at (-3, 0, 8) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward static placement task requiring precise geometric creation and rigid body assignment. The cylinder must be positioned and oriented exactly as specified, then marked as a passive (immovable) rigid body for physics simulations. No kinematic chains or dynamic behaviors are needed.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center coordinates: (-3.0, 0.0, 8.0)\n- Cylinder radius: 1.5 units\n- Cylinder height: 2.0 units\n- Y-axis rotation: 15° (0.261799 radians)\n- The cylinder's local Z-axis is aligned with its height. A 15° rotation around the global Y-axis will tilt its top toward positive X-direction.\n- Bounding box extents: ±1.5 in X and Y, ±1.0 in local Z from center point.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (direct parent-child relationship, no joints)\n- The cylinder is a single rigid body with passive physics type.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cylinder will remain fixed during simulations, serving as a static obstacle or platform.\n- The rotation may affect collision interactions if objects roll or slide along its surface.\n- No stability concerns since it's immovable.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.5\n- cylinder_height: 2.0\n- cylinder_location: (-3.0, 0.0, 8.0)\n- cylinder_rotation_y_degrees: 15.0\n- cylinder_rotation_y_radians: 0.261799\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.5,\n    depth=2.0,\n    location=(-3.0, 0.0, 8.0),\n    rotation=(0.0, math.radians(15.0), 0.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Assign passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n```\n</implementation>"}
{"id": 226, "instruction": "Place an Active sphere (radius 1.7) at (3, 9, 7) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is straightforward: create a spherical rigid body at a specified coordinate with a specific orientation. The term \"Active\" indicates a dynamic rigid body for physics simulation. We must ensure the sphere is correctly sized, positioned, and rotated. No complex mechanisms or environmental interactions are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 1.7 units.\n- World coordinates: X=3.0, Y=9.0, Z=7.0.\n- Rotation: 15° around the global X-axis. In radians: 15 * (π/180) ≈ 0.261799 rad.\n- No geometric constraints or derivations needed beyond direct parameter application.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single active rigid body with no joints or parent hierarchy).\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: None. The sphere is isolated and unconstrained.\n- Mitigation: Not applicable.\n- Trajectory: If simulated from rest, the sphere will fall under gravity from Z=7.0.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.7\n- sphere_location: (3.0, 9.0, 7.0)\n- sphere_rotation_x_degrees: 15.0\n- sphere_rotation_x_radians: 0.261799\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.7, location=(3.0, 9.0, 7.0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply rotation: 15 degrees around X-axis\nsphere.rotation_euler.x = math.radians(15.0)\n\n# Add active rigid body for physics simulation\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\n```\n</implementation>"}
{"id": 222, "instruction": "Place an Active sphere (radius 0.9) at (-2, 6, 9) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a physics-enabled sphere at specified coordinates with a specific orientation. Since it's an \"Active\" sphere in Blender's rigid body system, it should respond dynamically to forces and collisions. The placement requires precise coordinate transformation and rotation application. The sphere's rigid body properties must be configured correctly to ensure proper physical simulation behavior.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 0.9 units\n- World coordinates: X = -2.0, Y = 6.0, Z = 9.0\n- Rotation: 60° around the global Y-axis (converted to radians: 60 × π/180 ≈ 1.0472 rad)\n- The sphere's center point will be exactly at (-2, 6, 9) after placement\n- The rotation is applied around the sphere's origin, which coincides with its geometric center\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent object: active_sphere\n- No parent-child relationships\n- Rigid body simulation: ACTIVE type with sphere collision shape\n- No constraints attached\n</kinematic_topology>\n\n<predictive_simulation>\n- With active rigid body enabled, sphere will fall under gravity (default -9.8 m/s² Z-direction)\n- Initial orientation (60° Y-rotation) doesn't affect sphere's collision response due to symmetric shape\n- Starting height of Z=9.0 provides significant potential energy for falling motion\n- Collision detection will use sphere shape with radius 0.9 for accurate physics\n- No stability concerns for a single free-falling sphere\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 0.9\nlocation_x: -2.0\nlocation_y: 6.0\nlocation_z: 9.0\nrotation_y_degrees: 60.0\nrotation_y_radians: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=0.9,\n    location=(-2.0, 6.0, 9.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"active_sphere\"\n\n# Apply 60° rotation around Y-axis\nsphere.rotation_euler = (0, math.radians(60.0), 0)\n\n# Add rigid body physics with ACTIVE type\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\nsphere.rigid_body.mass = 1.0\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.5\n\n# Ensure proper collision margin (sphere radius will be used)\nsphere.rigid_body.use_margin = True\nsphere.rigid_body.collision_margin = 0.0\n\n# Create ground plane for physics simulation context\nbpy.ops.mesh.primitive_plane_add(size=20.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"ground_plane\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Set viewport display for clarity\nsphere.display_type = 'SOLID'\nground.display_type = 'WIRE'\n\nprint(f\"Created active sphere at {sphere.location}\")\nprint(f\"Rotation: {math.degrees(sphere.rotation_euler.y):.1f}° around Y-axis\")\n```\n</implementation>"}
{"id": 201, "instruction": "Place a Passive 3x3x1 cube at (0, 0, 0), then place an Active 1x1x1 cube offset on the front-right edge of the first cube at (1.5, 1, 0.5) and rotate the small cube 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task involves placing two cubes with specific spatial relationships and rigid body properties. The large passive cube serves as a stable base platform, while the smaller active cube is positioned partially overhanging its front-right edge with a rotational offset. This creates an unstable configuration where the active cube may fall or slide due to gravity and its initial rotation.\n</strategic_analysis>\n\n<spatial_layout>\n- Large cube dimensions: 3m (x) × 3m (y) × 1m (z). Center at (0,0,0.5) since bottom aligns with z=0.\n- Small cube dimensions: 1m (x) × 1m (y) × 1m (z). Target center at (1.5,1,0.5).\n- Edge clearance: Small cube's x-boundary extends from 1.0 to 2.0. The large cube's x-boundary extends from -1.5 to 1.5. Thus, 0.5m of the small cube overhangs beyond x=1.5.\n- Y-axis rotation: 45° (π/4 rad) about the small cube's local origin.\n- Coordinate verification: After rotation, the cube's vertices will shift, but the center remains at (1.5,1,0.5).\n</spatial_layout>\n\n<kinematic_topology>\n- World (global origin)\n  ├── large_cube (Passive Rigid Body, static)\n  └── small_cube (Active Rigid Body, dynamic)\n        └── Y-rotation constraint: 45° applied during initialization\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The small cube's center of mass (at its geometric center) is partially supported by the large cube. With 45° rotation, one corner may contact the large cube first, creating a pivot point.\n- Dynamics: Initial potential energy will convert to rotational and translational kinetic energy. The cube may tip, slide, or roll off the edge.\n- Simulation parameters: Default gravity (9.81 m/s² downward). Rigid body friction and damping will affect motion.\n</predictive_simulation>\n\n<parameter_summary>\nlarge_cube_dimensions: (3.0, 3.0, 1.0)\nlarge_cube_location: (0.0, 0.0, 0.5)\nsmall_cube_dimensions: (1.0, 1.0, 1.0)\nsmall_cube_location: (1.5, 1.0, 0.5)\nsmall_cube_rotation_y_deg: 45.0\nsmall_cube_rotation_y_rad: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create large passive cube (3x3x1)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0.0, 0.0, 0.5))\nlarge_cube = bpy.context.active_object\nlarge_cube.name = \"large_cube\"\nlarge_cube.scale = (1.5, 1.5, 0.5)  # Scale default 2m cube to 3x3x1\nbpy.ops.rigidbody.object_add()\nlarge_cube.rigid_body.type = 'PASSIVE'\n\n# Create small active cube (1x1x1) with rotation\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(1.5, 1.0, 0.5))\nsmall_cube = bpy.context.active_object\nsmall_cube.name = \"small_cube\"\nsmall_cube.scale = (0.5, 0.5, 0.5)  # Scale default 2m cube to 1x1x1\nsmall_cube.rotation_euler = (0.0, math.radians(45.0), 0.0)\nbpy.ops.rigidbody.object_add()\nsmall_cube.rigid_body.type = 'ACTIVE'\n\n# Set rigid body properties for realism\nsmall_cube.rigid_body.mass = 1.0\nsmall_cube.rigid_body.friction = 0.5\nsmall_cube.rigid_body.restitution = 0.2\n\n# Ensure proper viewport display\nbpy.context.view_layer.update()\n```</implementation>"}
{"id": 217, "instruction": "Place a Passive 1x1x3 cube at (-9, 0, 0) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task is to place a static passive rigid body cube with specified dimensions, location, and rotation. No dynamic mechanisms or interactions are required. The cube will serve as a fixed obstacle or structural element in the scene.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 1.0m (X, width) × 1.0m (Y, depth) × 3.0m (Z, height).\n- World Location: (-9.0, 0.0, 0.0).\n- Rotation: 60° around the global X-axis (counter-clockwise when viewing from positive X). This tilts the cube forward, aligning its local Z-axis 60° from the world Z-axis.\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body (cube) with no joints or constraints.\n- Parent: World (no hierarchy).\n</kinematic_topology>\n\n<predictive_simulation>\nThe cube is passive and static, meaning it will not move under simulation. Its mass and inertia are irrelevant for passive rigid bodies. No dynamic risks or stability concerns exist.\n</predictive_simulation>\n\n<parameter_summary>\n- location: (-9.0, 0.0, 0.0)\n- dimensions: (1.0, 1.0, 3.0)\n- rotation_x_degrees: 60.0\n- rigid_body_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Add a default cube (initially 2m x 2m x 2m)\nbpy.ops.mesh.primitive_cube_add()\n\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Set dimensions to 1x1x3 (scaling from default 2x2x2)\ncube.dimensions = (1.0, 1.0, 3.0)\n\n# Apply location and rotation\ncube.location = (-9.0, 0.0, 0.0)\ncube.rotation_euler.x = math.radians(60.0)\n\n# Add rigid body and set to passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 225, "instruction": "Place a Passive 4x4x1 cube at (-10, 0, 2) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThe task is purely kinematic placement of a passive rigid body cube at specified coordinates with a Y-axis rotation. No dynamic behavior or complex mechanisms are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 4m (X) × 4m (Y) × 1m (Z)\n- Location: (-10.0, 0.0, 2.0)\n- Rotation: 45° around Y-axis = π/4 radians ≈ 0.785398 radians\n- Since the cube is 1m tall, its base sits at Z=1.5m and top at Z=2.5m (center at Z=2.0)\n</spatial_layout>\n\n<kinematic_topology>\n- world → static_cube (Passive Rigid Body, fixed position/rotation)\n- No joints or hierarchical relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive rigid body, the cube will not move under simulation forces.\n- No collision risks given static placement.\n- The 45° rotation is purely visual with no dynamic implications.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (4.0, 4.0, 1.0)\n- cube_location: (-10.0, 0.0, 2.0)\n- cube_rotation_y_degrees: 45.0\n- cube_rotation_y_radians: 0.785398\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with unit dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply dimensions (scale)\ncube.scale = (4.0, 4.0, 1.0)\n\n# Set location and rotation\ncube.location = (-10.0, 0.0, 2.0)\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Apply transformations to make them intrinsic\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Add rigid body physics (passive)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Add a simple material for visibility\nmat = bpy.data.materials.new(name=\"Cube_Material\")\nmat.diffuse_color = (0.8, 0.4, 0.1, 1.0)  # Orange-brown\ncube.data.materials.append(mat)\n\nprint(f\"Created passive cube at {cube.location} with rotation {cube.rotation_euler}\")\n```\n</implementation>"}
{"id": 223, "instruction": "Place a Passive cylinder (radius 2, height 1) at (4, 0, 10) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create a static cylindrical obstacle with specific dimensions, position, and orientation. A passive rigid body is appropriate as it will remain stationary during simulations while still participating in collisions. The 90° X-axis rotation reorients the cylinder from vertical (default) to horizontal alignment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Geometry: Radius = 2.0m, Height = 1.0m (becomes length when rotated).\n- World Position: (4.0, 0.0, 10.0) in global coordinates.\n- Orientation: 90° rotation around X-axis (π/2 radians) transforms cylinder axis from Z to Y direction.\n- Safety Margin: None required for static placement.\n- Coordinate Check: Ensures cylinder doesn't intersect origin or default scene bounds.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_body (Single rigid body, no joints or hierarchy)\n- Rigid Body Type: PASSIVE (immovable collision object)\n- No constraints or parent-child relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive body, cylinder will remain fixed regardless of mass distribution.\n- Collision Geometry: Horizontal orientation may affect rolling interactions with other objects.\n- Placement Risk: High Z-position (10m) could cause falling objects if gravity is enabled, but passive bodies remain fixed.\n- Performance: Moderate vertex count (default 32 segments) balances accuracy and simulation speed.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 2.0\n- cylinder_height: 1.0\n- location_x: 4.0\n- location_y: 0.0\n- location_z: 10.0\n- rotation_x_degrees: 90.0\n- rotation_x_radians: 1.570796\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with default orientation (axis along Z)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.0,\n    depth=1.0,\n    location=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply transformations\ncylinder.location = (4.0, 0.0, 10.0)\ncylinder.rotation_euler = (math.radians(90.0), 0.0, 0.0)  # 90° around X-axis\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Optional: Set collision margin\ncylinder.rigid_body.collision_margin = 0.0\n\nprint(f\"Created {cylinder.name} at {cylinder.location}\")\nprint(f\"Rotation: {cylinder.rotation_euler}\")\nprint(f\"Rigid Body Type: {cylinder.rigid_body.type}\")\n```\n</implementation>"}
{"id": 227, "instruction": "Place a Passive cylinder (radius 0.7, height 3.5) at (-5, 0, -7) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires placing a static cylinder at a specified location and orientation. This involves creating a cylinder primitive with given dimensions, applying transformations, and configuring it as a passive rigid body for physics simulation scenarios.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder origin: World coordinates (-5.0, 0.0, -7.0)\n- Cylinder rotation: 60° around Z-axis (converted to radians: 60° × π/180° ≈ 1.0472 rad)\n- Cylinder dimensions: Radius 0.7m, Height 3.5m\n- Local coordinate alignment: Default cylinder axis along Z, rotated around same axis\n- Transformation order: Apply rotation first (local), then translation to world location\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder_body (Single rigid body, no joints or constraints)\n- Physical type: PASSIVE (immovable in simulations)\n- No parent-child hierarchy required\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive object with default mass settings, cylinder remains fixed during simulations\n- Collision geometry: Cylinder shape provides uniform collision detection\n- Risk assessment: No dynamic risks; object serves as static environment element\n- Potential usage: Acts as obstacle, support structure, or visual element in physics scenes\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 0.7\n- cylinder_height: 3.5\n- location: (-5.0, 0.0, -7.0)\n- rotation_z_degrees: 60.0\n- rotation_z_radians: 1.0471975511965976\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=0.7,\n    depth=3.5,\n    location=(0, 0, 0),\n    rotation=(0, 0, 0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply transformations in correct order\n# 1. Rotation around Z-axis (60 degrees)\ncylinder.rotation_euler[2] = math.radians(60.0)\n\n# 2. Translation to target location\ncylinder.location = (-5.0, 0.0, -7.0)\n\n# Update object transformations\nbpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n\n# Configure as passive rigid body\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Set visual properties (optional, for clarity)\ncylinder.data.materials.clear()\nmat = bpy.data.materials.new(name=\"Cylinder_Material\")\nmat.diffuse_color = (0.2, 0.6, 0.9, 1.0)  # Blue color\ncylinder.data.materials.append(mat)\n\nprint(f\"Cylinder created: {cylinder.name}\")\nprint(f\"Location: {cylinder.location}\")\nprint(f\"Rotation: {math.degrees(cylinder.rotation_euler[2]):.1f}° around Z-axis\")\n```\n</implementation>"}
{"id": 230, "instruction": "Place an Active sphere (radius 2.9) at (-8, 10, 0) and rotate it 20° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a dynamic spherical object with specific geometric placement and orientation. The sphere must be configured as an \"active\" rigid body, meaning it will respond to physical forces like gravity and collisions. The positioning at (-8, 10, 0) and 20° Z-axis rotation establishes its initial state in the global coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center coordinates: X = -8.0 m, Y = 10.0 m, Z = 0.0 m\n- Sphere radius: 2.9 m (diameter = 5.8 m)\n- Rotation: 20° about global Z-axis → converted to radians: 20 × π/180 = 0.349066 radians\n- Bounding box: From (-10.9, 7.1, -2.9) to (-5.1, 12.9, 2.9) considering radius offset\n</spatial_layout>\n\n<kinematic_topology>\n- Single independent rigid body (world → sphere_active)\n- No parent-child hierarchy needed\n- Sphere mesh with origin at geometric center\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, sphere will immediately respond to gravity (default -9.81 m/s² in Z)\n- Initial rotation about Z-axis won't affect gravitational fall but will influence collision responses\n- Mass automatically calculated from volume (4/3 × π × r³) and default density\n- Risk: Large radius (2.9 m) creates substantial collision volume; ensure scene scale accommodates this\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 2.9\nsphere_location: (-8.0, 10.0, 0.0)\nsphere_rotation_z_deg: 20.0\nsphere_rotation_z_rad: 0.349066\nrigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    radius=2.9,\n    location=(-8.0, 10.0, 0.0),\n    scale=(1.0, 1.0, 1.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"sphere_active\"\n\n# Apply 20° rotation about Z-axis\nsphere.rotation_euler = (0.0, 0.0, math.radians(20.0))\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\nsphere.rigid_body.mass = 1.0  # Will be overridden by mesh volume\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.3\n\n# Optional: Ensure proper scale (already unit scale)\nbpy.ops.object.transform_apply(location=False, rotation=True, scale=True)\n\nprint(f\"Created active sphere '{sphere.name}'\")\nprint(f\"  Radius: {sphere.dimensions.x/2:.3f} m\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation: {math.degrees(sphere.rotation_euler.z):.1f}° about Z\")\n```\n</implementation>"}
{"id": 228, "instruction": "Place an Active 2x1x4 cube at (9, 8, -3) and rotate it 35° on the Y-axis.", "answer": "<strategic_analysis>\nThe objective is to create a simple rigid body object with specific dimensions, position, and orientation. An \"Active\" designation in Blender's physics context means the object will respond to gravity and collisions as a dynamic rigid body. The 35° rotation around the Y-axis will tilt the longest dimension (4 units in Z) forward/backward relative to the world Z-axis.\n</strategic_layout>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 2, Depth (Y) = 1, Height (Z) = 4.\n- Base Cube: Default Blender cube is 2x2x2 meters. Scaling factors: (2/2=1.0 for X, 1/2=0.5 for Y, 4/2=2.0 for Z).\n- World Position: (X=9, Y=8, Z=-3).\n- Rotation: 35° around global Y-axis. In radians: 35 * (π/180) ≈ 0.610865 rad.\n- Center of Mass: Default at object origin (geometric center).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube (Single active rigid body with no joints or constraints)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body, the cube will fall under gravity (-Z direction) until contacting a passive surface.\n- Orientation Risk: The 35° tilt creates an unbalanced initial state; the cube will rotate to stabilize with its largest face downward when falling.\n- Collision Geometry: The rotated bounding box extends approximately ±2.0 in X, ±0.5 in Y, and ±2.0 in Z from the object origin in local space.\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (2.0, 1.0, 4.0)\n- location: (9.0, 8.0, -3.0)\n- rotation_y_degrees: 35.0\n- scale_factors: (1.0, 0.5, 2.0)\n- mass: 1.0 (default)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2)\n\n# Get the active object\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply dimensions via scaling\ncube.scale = (1.0, 0.5, 2.0)  # X=2, Y=1, Z=4\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (9.0, 8.0, -3.0)\ncube.rotation_euler = (0.0, math.radians(35.0), 0.0)\n\n# Add rigid body physics (Active)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 1.0\n```\n</implementation>"}
{"id": 231, "instruction": "Place a Passive cylinder (radius 1.1, height 4) at (6, 0, -10) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis task requires placing a static cylindrical obstacle with specific dimensions, position, and orientation. The cylinder will be passive (non-moving) in any physics simulation. The primary considerations are accurate geometric creation and proper transformation application.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.1 units\n- Cylinder height: 4.0 units\n- Location: (6.0, 0.0, -10.0) in global coordinates\n- Rotation: 45° around Y-axis = π/4 radians ≈ 0.7854 rad\n- Cylinder center will be at the midpoint of its height, so bottom at Z=-12 and top at Z=-8 when unrotated\n- After 45° Y rotation, the cylinder will tilt forward/backward along the X-Z plane\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh with Passive Rigid Body)\n- No joints or hierarchical relationships needed\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive object, the cylinder will remain fixed during simulations\n- The 45° tilt creates an inclined surface that could deflect or guide moving objects\n- The negative Z-position (-10) places it below the default scene origin, which may affect visibility if camera isn't adjusted\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_radius: 1.1\n- cylinder_height: 4.0\n- location_x: 6.0\n- location_y: 0.0\n- location_z: -10.0\n- rotation_y_degrees: 45.0\n- rotation_y_radians: 0.7853981633974483\n- object_name: \"Passive_Cylinder\"\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.1,\n    depth=4.0,\n    location=(6.0, 0.0, -10.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Apply 45° rotation around Y-axis (convert to radians)\ncylinder.rotation_euler = (0, math.radians(45.0), 0)\n\n# Set as passive rigid body for physics simulations\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'\n\n# Update scene to ensure transformations are applied\nbpy.context.view_layer.update()\n\nprint(f\"Created {cylinder.name} at location {cylinder.location}\")\nprint(f\"Radius: 1.1, Height: 4.0, Rotation: 45° around Y-axis\")\n```\n</implementation>"}
{"id": 233, "instruction": "Place a Passive 1x2x2 cube at (10, 0, 1) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThe task involves placing a single passive rigid body cube with specified dimensions, location, and rotation. This is a foundational scene setup operation requiring precise geometric transformation. The cube will serve as a static obstacle or platform in a physics simulation.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: (width=1.0, depth=2.0, height=2.0) in X, Y, Z axes respectively.\n- World Location: (X=10.0, Y=0.0, Z=1.0). The Z=1.0 position means the cube's base will be at Z=0.0 (since height=2.0 and center is at Z=1.0).\n- Rotation: 60° about global Z-axis. Convert to radians: θ = 60 * (π/180) = π/3 ≈ 1.0472 rad.\n- No kinematic relationships or constraints needed.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Single static mesh with passive rigid body)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body with default mass distribution, the cube is stable at its location.\n- Collision: The rotated cube will have different oriented bounding box. The rotation may affect interactions with other objects.\n- Risk: None for single static object.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (1.0, 2.0, 2.0)\n- cube_location: (10.0, 0.0, 1.0)\n- cube_rotation_z_deg: 60.0\n- cube_rotation_z_rad: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with base dimensions 1x1x1 (will scale)\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Apply dimensions (scale) - Blender's default cube is 2x2x2, so we adjust\n# To get 1x2x2 from a default 2x2x2 cube, we scale by (0.5, 1.0, 1.0)\ncube.scale = (0.5, 1.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (10.0, 0.0, 1.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(60.0))\n\n# Add passive rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX (default for cubes)\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Created passive cube: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (Z): {math.degrees(cube.rotation_euler.z):.1f}°\")\n```\n</implementation>"}
{"id": 234, "instruction": "Place an Active sphere (radius 0.6) at (-1, 7, 11) and rotate it 90° on the Y-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single dynamic sphere with specific geometric properties. The primary considerations are ensuring the sphere has the correct dimensions, location, orientation, and physics properties. Since this is a single rigid body without complex mechanisms, we can directly create it with the specified parameters.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (r): 0.6 units\n- Location (L): (x=-1.0, y=7.0, z=11.0)\n- Rotation (θ): 90° around Y-axis = 1.5708 radians\n- The sphere's center will be at the specified location, with its mesh rotated accordingly before simulation begins.\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere (Single rigid body with no joints or constraints)\n- The sphere is an active rigid body that will respond to gravity and collisions.\n</kinematic_topology>\n\n<predictive_simulation>\n- Risk: The sphere is placed at z=11, so it will fall under gravity (default -9.8 m/s² on Z-axis). It may bounce or roll depending on collision geometry below.\n- Mitigation: Default rigid body settings are appropriate for demonstration. No anchoring needed.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 0.6\n- sphere_location: (-1.0, 7.0, 11.0)\n- sphere_rotation_y: 1.5708\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=True)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.6)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location and rotation\nsphere.location = (-1.0, 7.0, 11.0)\nsphere.rotation_euler = (0.0, math.radians(90.0), 0.0)  # 90° around Y\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\n# Keep default mass (calculated from volume and density) and other physics properties\n```\n</implementation>"}
{"id": 229, "instruction": "Place a Passive 3x3x1 cube at (0, 0, 10) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely geometric: create a static cube with specific dimensions, position, and orientation. Since it's a passive rigid body, we need to ensure proper mass and collision properties. The 90° X-axis rotation will make the cube's local Z-axis align with world Y-axis (if initially upright).\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: (3.0, 3.0, 1.0) in X, Y, Z respectively\n- World position: (0.0, 0.0, 10.0)\n- Rotation: 90° about X-axis = π/2 radians = 1.570796 rad\n- No scaling needed since dimensions are explicit\n- The cube's original local coordinate system has Z as up; after 90° X rotation, Y becomes up\n</spatial_layout>\n\n<kinematic_topology>\n- Single rigid body: world -> cube_object (Passive Rigid Body)\n- No joints or constraints needed\n- Collision shape: BOX (matches mesh exactly)\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Cube is passive/static, so no dynamic simulation required\n- Collision: Box shape ensures accurate collision detection\n- Center of mass: Defaults to geometric center at (0,0,0) in local coordinates\n- The 10m height places it well above ground plane\n</predictive_simulation>\n\n<parameter_summary>\n- dimensions: (3.0, 3.0, 1.0)\n- location: (0.0, 0.0, 10.0)\n- rotation_x_rad: 1.570796\n- rigidbody_type: PASSIVE\n- mass: 0.0 (passive bodies have infinite mass)\n- collision_shape: BOX\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with proper dimensions\nbpy.ops.mesh.primitive_cube_add(size=1.0, location=(0, 0, 10))\ncube = bpy.context.active_object\ncube.name = \"PassiveCube\"\n\n# Set dimensions (scale)\ncube.scale = (3.0, 3.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Apply 90° rotation on X-axis\ncube.rotation_euler = (math.pi/2, 0, 0)\nbpy.ops.object.transform_apply(rotation=True)\n\n# Add rigid body properties\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\ncube.rigid_body.mass = 0.0  # Passive objects have infinite mass\n\n# Verify transformation\nprint(f\"Cube created:\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {cube.rotation_euler}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 235, "instruction": "Place a Passive cylinder (radius 2.3, height 2.2) at (2, 0, -11) and rotate it 15° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement task requiring precise geometric specification and rigid body physics properties. The cylinder must be created with exact dimensions, positioned accurately in 3D space, oriented with a specific rotation, and configured as a passive (static) physics object that won't move during simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder location: (2.0, 0.0, -11.0) in global coordinates.\n- Cylinder dimensions: radius = 2.3m, height = 2.2m.\n- Rotation: 15° around X-axis (positive rotation by right-hand rule).\n- Default cylinder orientation: Blender's primitive cylinder is aligned with Z-axis as height axis.\n- Rotation conversion: 15° = 15 × π/180 = 0.2617993877991494 radians.\n</spatial_layout>\n\n<kinematic_topology>\n- world → cylinder (single static object, no hierarchical relationships)\n- Rigid body type: PASSIVE (immovable in physics simulations)\n</kinematic_topology>\n\n<predictive_simulation>\n- As a passive object with substantial mass (default density), the cylinder will remain fixed during physics simulations.\n- Located at negative Z coordinate, it may serve as ground terrain or an obstacle below other objects.\n- The 15° X-rotation will tilt the cylinder forward/backward relative to default vertical orientation.\n- No stability concerns for passive objects.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (2.0, 0.0, -11.0)\n- cylinder_radius: 2.3\n- cylinder_height: 2.2\n- cylinder_rotation_x_deg: 15.0\n- cylinder_rotation_x_rad: 0.2617993877991494\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified dimensions\n# Default Blender cylinder: radius=1, depth=2, aligned with Z-axis\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=2.3,\n    depth=2.2,\n    location=(2.0, 0.0, -11.0),\n    rotation=(0.2617993877991494, 0.0, 0.0)  # 15° around X-axis\n)\n\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add rigid body physics as passive/static object\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n\n# Optional: Set display properties for clarity\ncylinder.display_type = 'SOLID'\ncylinder.show_wire = True\n```\n</implementation>"}
{"id": 232, "instruction": "Place an Active 5x1x3 cube at (-4, 9, 4) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe objective is to create an active rigid body cube with specific dimensions, position, and orientation. The cube's dimensions (5×1×3) suggest an elongated rectangular prism. The location (-4, 9, 4) places it in 3D space, and the 30° X-axis rotation will tilt it forward/backward. As an active rigid body, it will respond to physics (gravity, collisions) when simulated.\n</strategic_layout>\n\n<spatial_layout>\n- Cube Dimensions: 5m (X), 1m (Y), 3m (Z) after scaling.\n- Location: World coordinates (-4, 9, 4). Since Blender's default cube is centered at origin with size 2, scaling factors are (2.5, 0.5, 1.5).\n- Rotation: 30° about X-axis (pitch forward). Converted to radians: 30° × (π/180) = 0.5236 rad.\n- Ground Plane: Added at Z=0 with dimensions 20×20 for physical simulation context.\n</spatial_layout>\n\n<kinematic_topology>\n- world → ground_plane (Passive Rigid Body)\n- world → active_cube (Active Rigid Body, free transform)\nNo joints required as it's a single rigid object.\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube's elongated shape (long X, tall Z) with 30° tilt creates an unstable initial orientation when active.\n- With gravity enabled (default -9.8 m/s² Z), the cube will immediately torque and fall, likely rotating further upon ground impact.\n- The high vertical position (Z=4) combined with tilt may cause tumbling rather than sliding.\n- Ground collision will be energetic due to ~4m fall height (potential energy ~ m×g×h).\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (5.0, 1.0, 3.0)\ncube_location: (-4.0, 9.0, 4.0)\ncube_rotation_x_degrees: 30.0\ncube_scale_factors: (2.5, 0.5, 1.5)\nground_dimensions: (20.0, 20.0, 0.1)\nground_location: (0.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create ground plane (passive rigid body)\nbpy.ops.mesh.primitive_plane_add(size=20, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nground.scale = (1, 1, 0.1)  # Make it thin\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Create the main cube with default Blender cube (2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply scaling to achieve 5×1×3 dimensions\ncube.scale = (2.5, 0.5, 1.5)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-4, 9, 4)\ncube.rotation_euler = (math.radians(30), 0, 0)\n\n# Add active rigid body properties\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 5.0  # Reasonable mass for volume ~15 m³\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.3\n\n# Set up world physics\nbpy.context.scene.rigidbody_world.enabled = True\nbpy.context.scene.rigidbody_world.gravity = (0, 0, -9.81)\n\n# Optional: Frame the view\nbpy.context.scene.camera.location = (10, -15, 10)\nbpy.context.scene.camera.rotation_euler = (\n    math.radians(60),\n    0,\n    math.radians(30)\n)\n```\n</implementation>"}
{"id": 220, "instruction": "Place an Active 3x1x2 cube at (8, 7, 2) and rotate it 45° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a single rigid body object - a rectangular prism with dimensions 3×1×2 units - positioned at coordinates (8,7,2) with a 45° rotation around the X-axis. As an active rigid body, it will respond to physics simulation including gravity and collisions. No complex mechanisms or constraints are required.\n</strategic_analysis>\n\n<spatial_layout>\n- Object origin: Located at geometric center (default Blender cube behavior)\n- World position: (x=8.0, y=7.0, z=2.0)\n- Base dimensions: 3×1×2 units (X×Y×Z)\n- Rotation: 45° around local X-axis (π/4 radians)\n- Bounding box vertices: After scaling and rotation, the corners will be offset from center by ±(1.5, 0.5, 1.0) in local space, then rotated\n- No collision geometry required beyond default mesh collision\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body hierarchy:\n- world → cube (Active Rigid Body with mesh collision)\nNo joints or constraints needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- The object will immediately fall under gravity (default -9.81 m/s² in Z)\n- Rotated 45° on X-axis means it will initially tilt forward/backward relative to world X\n- No stability concerns as it's a simple falling object\n- Collision response will be standard convex hull physics\n- Mass will be automatically calculated from volume and default density\n</predictive_simulation>\n\n<parameter_summary>\ncube_location: (8.0, 7.0, 2.0)\ncube_dimensions: (3.0, 1.0, 2.0)\ncube_rotation: (45.0, 0.0, 0.0)  # degrees\nrigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube primitive (default 2×2×2)\nbpy.ops.mesh.primitive_cube_add(size=1.0)\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scale to achieve 3×1×2 dimensions\n# Default cube vertices are at ±0.5, so scaling by (3,1,2) gives desired size\ncube.scale = (1.5, 0.5, 1.0)  # Scale factors: 3/2, 1/2, 2/2\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (8.0, 7.0, 2.0)\ncube.rotation_euler = (math.radians(45.0), 0.0, 0.0)  # 45° around X-axis\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.collision_shape = 'MESH'  # Use actual mesh for collision\n\n# Optional: Set physics properties for predictable behavior\ncube.rigid_body.mass = 1.0  # kg\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.3\n\n# Ensure proper display\ncube.display_type = 'SOLID'\nbpy.context.view_layer.update()\n```\n</implementation>"}
{"id": 224, "instruction": "Place an Active 1x3x4 cube at (0, 8, -8) and rotate it 25° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single rigid body cube with specific dimensions, placement, and orientation. The primary objective is to accurately construct the geometry, apply the correct transformation, and assign appropriate rigid body physics properties.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: Width (X) = 1m, Height (Y) = 3m, Depth (Z) = 4m.\n- Location: Center at world coordinates (0, 8, -8).\n- Rotation: 25° counterclockwise around the global Z-axis.\n- Scaling: Default Blender cube (2×2×2) requires scaling factors: (1/2, 3/2, 4/2) = (0.5, 1.5, 2.0).\n</spatial_layout>\n\n<kinematic_topology>\nSingle rigid body object with no hierarchical relationships.\n- world → active_cube (Active Rigid Body)\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube's center of mass will be at its geometric center (0, 8, -8).\n- As an active rigid body, it will immediately respond to gravity and fall unless supported.\n- Rotation may cause tumbling during descent due to asymmetric mass distribution from non-uniform dimensions.\n</predictive_simulation>\n\n<parameter_summary>\nlocation: (0.0, 8.0, -8.0)\nrotation_z_deg: 25.0\nrotation_z_rad: 0.4363323129985824\nscale_factors: (0.5, 1.5, 2.0)\ndimensions: (1.0, 3.0, 4.0)\nmass: 12.0 (calculated as product of dimensions assuming density=1)\nrigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube primitive (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2)\n\n# Get reference to the active object\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply transformations from parameter summary\ncube.location = (0.0, 8.0, -8.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(25.0))\ncube.scale = (0.5, 1.5, 2.0)\n\n# Apply scale to avoid distortion in physics calculations\nbpy.ops.object.transform_apply(location=False, rotation=False, scale=True)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\ncube.rigid_body.mass = 12.0  # 1*3*4 = 12 cubic meters with density 1\ncube.rigid_body.friction = 0.5\ncube.rigid_body.restitution = 0.2\ncube.rigid_body.linear_damping = 0.04\ncube.rigid_body.angular_damping = 0.1\n\n# Verify dimensions\ndimensions = [cube.dimensions.x, cube.dimensions.y, cube.dimensions.z]\nprint(f\"Created cube with dimensions: {dimensions}\")\n```\n</implementation>"}
{"id": 239, "instruction": "Place a Passive cylinder (radius 1, height 5) at (-11, 0, -2) and rotate it 60° on the Z-axis.", "answer": "<strategic_analysis>\nThis is a static object placement task. The objective is to create a passive rigid body cylinder with specified dimensions, location, and rotation. Since the cylinder is marked as passive, it will not move during simulations but can interact with active rigid bodies. No complex physics or mechanism design is required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder radius: 1.0 unit.\n- Cylinder height: 5.0 units.\n- Location: (-11.0, 0.0, -2.0) in world coordinates.\n- Rotation: 60 degrees around the global Z-axis (Euler rotation (0, 0, 60°) in degrees).\n- The cylinder's local Z-axis is its height axis. Rotating 60° around the world Z-axis will spin it around the vertical, leaving its height direction unchanged relative to the world.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (single rigid body, no joints, static transformation).\n</kinematic_topology>\n\n<predictive_simulation>\n- The cylinder is passive, so it will remain fixed in place during physics simulations.\n- Collision geometry is determined by the cylinder's mesh with the specified radius and height.\n- No dynamic risks as it is a static obstacle.\n</predictive_simulation>\n\n<parameter_summary>\n- radius: 1.0\n- height: 5.0\n- location: (-11.0, 0.0, -2.0)\n- rotation_z_degrees: 60.0\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, but good for a clean slate)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create a cylinder with radius 1 and depth 5 (height along local Z)\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,\n    radius=1.0,\n    depth=5.0,\n    location=(-11.0, 0.0, -2.0),\n    rotation=(0.0, 0.0, math.radians(60.0))\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Add a passive rigid body component\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 238, "instruction": "Place an Active sphere (radius 1.9) at (0, 11, -6) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement task requiring precise geometric positioning and orientation. The sphere must be created with the specified radius, positioned at the given coordinates, and rotated 30 degrees around the X-axis. The \"Active\" designation implies it should be a dynamic rigid body for physics simulations.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: 1.9 units\n- World coordinates: X=0, Y=11, Z=-6\n- Rotation: 30° around X-axis (0.5236 radians)\n- Geometry: Standard UV sphere with 32 segments and 16 rings for smooth appearance\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere_object (Single rigid body with no joints)\n- Sphere will be created as an ACTIVE rigid body for dynamic simulation\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the sphere will respond to gravity (falling if unsupported) and collisions\n- The 30° X-axis rotation won't affect sphere's collision geometry (isotropic) but will orient its visual mesh\n- Starting at negative Z coordinate may cause immediate ground collision if ground plane exists at Z=0\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 1.9\n- sphere_location: (0.0, 11.0, -6.0)\n- sphere_rotation_x_degrees: 30.0\n- sphere_rotation_x_radians: 0.5235987755982988\n- rigidbody_type: ACTIVE\n- sphere_segments: 32\n- sphere_rings: 16\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional but recommended for clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(\n    segments=32,\n    ring_count=16,\n    radius=1.9,\n    location=(0.0, 11.0, -6.0)\n)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply 30° rotation around X-axis (convert to radians)\nsphere.rotation_euler[0] = math.radians(30.0)\n\n# Add rigid body physics as ACTIVE\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.mass = 1.0  # Default mass\nsphere.rigid_body.friction = 0.5\nsphere.rigid_body.restitution = 0.8\n\n# Update viewport to show changes\nbpy.context.view_layer.update()\n\nprint(f\"Created active sphere:\")\nprint(f\"  Radius: {sphere.dimensions[0]/2}\")\nprint(f\"  Location: {sphere.location}\")\nprint(f\"  Rotation (X): {math.degrees(sphere.rotation_euler[0])}°\")\nprint(f\"  Rigid Body Type: {sphere.rigid_body.type}\")\n```\n</implementation>"}
{"id": 240, "instruction": "Place an Active 2x4x2 cube at (5, 9, -9) and rotate it 20° on the Y-axis.", "answer": "<strategic_analysis>\nThis is a straightforward 3D object placement task with rigid body physics activation. The cube must be created with non-uniform dimensions (2×4×2), positioned at the specified coordinates, and rotated 20° around the Y-axis. Since it's designated as \"Active,\" it will respond to gravity and collisions in Blender's physics simulation. No complex mechanisms or constraints are required.\n</strategic_layout>\n\n<spatial_layout>\n- Target location: (5, 9, -9) in global coordinates.\n- Cube dimensions: width (X) = 2m, depth (Y) = 4m, height (Z) = 2m.\n- Rotation: 20° counterclockwise around the Y-axis (right-hand rule).\n- Blender's default cube is 2×2×2. Scale factors: X=1.0 (2/2), Y=2.0 (4/2), Z=1.0 (2/2).\n</spatial_layout>\n\n<kinematic_topology>\n- World → cube (Single active rigid body, no parent-child hierarchy)\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will fall under gravity unless supported.\n- Rotation is applied initially; physics will maintain angular orientation unless torqued.\n- Risk: None beyond typical rigid body behavior.\n</predictive_simulation>\n\n<parameter_summary>\ncube_location: (5.0, 9.0, -9.0)\ncube_dimensions: (2.0, 4.0, 2.0)\ncube_rotation_y_degrees: 20.0\ncube_scale_factors: (1.0, 2.0, 1.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Apply scale to achieve 2x4x2 dimensions\ncube.scale = (1.0, 2.0, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (5.0, 9.0, -9.0)\ncube.rotation_euler = (0.0, math.radians(20.0), 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n```\n</implementation>"}
{"id": 236, "instruction": "Place an Active 3x3x2 cube at (-9, 8, 3) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe objective is to create a single active rigid body cube with precise dimensions, location, and orientation. Since this is a standalone object, we must ensure the physics properties are correctly configured. The cube should be an \"ACTIVE\" rigid body type to participate in dynamics simulations (fall, collide, etc.). The dimensions (3x3x2) define its collision shape, and the location/rotation define its initial state.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 3.0m, Depth (Y) = 3.0m, Height (Z) = 2.0m.\n- Cube Location: Center point at (-9.0, 8.0, 3.0) in world coordinates.\n- Cube Rotation: 45° around global Z-axis (0.785398 radians).\n- Note: Default Blender cube is 2x2x2. Scaling factors: X = 3.0/2.0 = 1.5, Y = 3.0/2.0 = 1.5, Z = 2.0/2.0 = 1.0.\n</spatial_layout>\n\n<kinematic_topology>\nSingle object hierarchy:\n- world -> cube (Active Rigid Body)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As an active rigid body, the cube will immediately fall under gravity unless supported.\n- Collision: The convex hull collision shape will match the scaled mesh.\n- Rotation: The 45° Z rotation is applied to both visual mesh and collision shape.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 3.0, 2.0)\n- cube_location: (-9.0, 8.0, 3.0)\n- cube_rotation_z_degrees: 45.0\n- cube_scale_factors: (1.5, 1.5, 1.0)\n- rigidbody_type: ACTIVE\n- rigidbody_mass: 10.0 (default)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create default cube (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2)\n\n# Get reference\ncube = bpy.context.active_object\ncube.name = \"ActiveCube\"\n\n# Apply scale transformation to achieve 3x3x2 dimensions\ncube.scale = (1.5, 1.5, 1.0)\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (-9.0, 8.0, 3.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(45.0))\n\n# Add rigid body physics\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n# Optionally set mass (default is 10.0 kg)\ncube.rigid_body.mass = 10.0\n\n# Verify final dimensions\nprint(f\"Cube created:\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation: {cube.rotation_euler}\")\nprint(f\"  Scale: {cube.scale}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\n```\n</implementation>"}
{"id": 237, "instruction": "Place a Passive 4x2x1 cube at (7, 0, 9) and rotate it 75° on the Y-axis.", "answer": ""}
{"id": 243, "instruction": "Place a Passive cylinder (radius 0.9, height 2.8) at (3, 0, 12) and rotate it 45° on the Z-axis.", "answer": "<strategic_analysis>\nThe task is to create a single passive rigid body cylinder at a specified location and rotation. This is a static object that will serve as an obstacle or part of the environment in a physics simulation. There is no dynamic behavior or complex interaction required.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder center position: (X=3.0, Y=0.0, Z=12.0)\n- Cylinder radius: 0.9 m\n- Cylinder height: 2.8 m\n- Rotation: 45 degrees around the Z-axis (applied in Blender's default rotation order, which is XYZ, but we only rotate on Z).\n- Note: In Blender, the cylinder primitive's local origin is at the center of the geometry. The location parameter sets the origin's position.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh, no parent, no joints)\n</kinematic_topology>\n\n<predictive_simulation>\n- The cylinder is passive, so it will not move in response to forces. It will act as a fixed obstacle.\n- No stability or dynamic risks are present because the object is static and has no moving parts.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (3.0, 0.0, 12.0)\n- cylinder_radius: 0.9\n- cylinder_height: 2.8\n- cylinder_rotation_z_degrees: 45.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, to start fresh)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder primitive\n# The default cylinder in Blender has 32 vertices, radius 1, depth 2, and is aligned along the Z-axis.\nbpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=0.9, depth=2.8, location=(3, 0, 12))\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Rotate 45 degrees around Z-axis. Convert degrees to radians.\ncylinder.rotation_euler = (0, 0, math.radians(45))\n\n# Add rigid body physics and set to passive\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\n```\n</implementation>"}
{"id": 246, "instruction": "Place an Active sphere (radius 1.2) at (6, 11, 6) and rotate it 90° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a single physics-enabled sphere with specific geometry and transform. This is a straightforward rigid body setup. The main consideration is ensuring the sphere's active rigid body properties are correctly configured to interact with other objects if added later. The rotation (90° on Z-axis) is visually relevant for texture or mesh orientation but doesn't affect the spherical collision shape.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere center: (6, 11, 6)\n- Sphere radius: 1.2 units\n- Rotation: 90° about Z-axis (π/2 radians)\n- Bounding box: From (4.8, 9.8, 4.8) to (7.2, 12.2, 7.2) in world coordinates\n- No spatial relationships with other objects\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single active rigid body with no parent)\n- No joints or constraints required\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere will immediately fall under gravity (default -9.81 m/s² in Z)\n- With no collisions, it will drop indefinitely\n- Rotation will not affect trajectory but will be preserved during free fall\n- Risk: None beyond expected physical behavior\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 1.2\nsphere_location: (6.0, 11.0, 6.0)\nsphere_rotation_z: 1.57079632679\nrigidbody_type: ACTIVE\ncollision_shape: SPHERE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.2, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set transform\nsphere.location = (6.0, 11.0, 6.0)\nsphere.rotation_euler = (0, 0, math.pi/2)  # 90° Z rotation\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\n\n# Optional: Set mass proportional to volume (density ~1)\nsphere.rigid_body.mass = (4/3) * math.pi * (1.2**3)  # ~7.24 kg if unit=1m\n```\n</implementation>"}
{"id": 245, "instruction": "Place a Passive 2x2x3 cube at (11, 0, -4) and rotate it 60° on the Y-axis.", "answer": "<strategic_analysis>\nThis task requires placing a static passive rigid body obstacle with specific dimensions, location, and orientation. As a passive object, it will remain fixed during simulations while interacting with active rigid bodies through collisions. The main consideration is accurately setting the cube's transform properties and rigid body type.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: Width (X) = 2m, Depth (Y) = 2m, Height (Z) = 3m\n- Location: World coordinates (11, 0, -4)\n- Rotation: 60° counterclockwise around global Y-axis\n- Transform Order: First scale to dimensions, then rotate, then translate to position\n- Volume: 2 × 2 × 3 = 12 m³\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cube_passive (Static Mesh with Passive Rigid Body)\n- No joints or hierarchies needed\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: Passive rigid body with infinite mass - completely stable\n- Collision: Will properly interact with active rigid bodies\n- Center of Mass: Default at object origin (geometric center)\n- Risk: None - purely static geometry\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (2.0, 2.0, 3.0)\n- cube_location: (11.0, 0.0, -4.0)\n- cube_rotation_y_degrees: 60.0\n- rigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with proper dimensions\n# Default cube is 2x2x2, scale to 2x2x3\nbpy.ops.mesh.primitive_cube_add(size=1.0)  # Unit cube (2m when scaled)\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube_2x2x3\"\n\n# Set scale for dimensions (2,2,3)\n# Scale factors: desired / default = (2/2, 2/2, 3/2) = (1, 1, 1.5)\ncube.scale = (1.0, 1.0, 1.5)\n\n# Apply scale to make dimensions actual\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (11.0, 0.0, -4.0)\n\n# Set rotation (60 degrees around Y-axis)\ncube.rotation_euler = (0.0, math.radians(60.0), 0.0)\n\n# Add rigid body physics with PASSIVE type\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to BOX for efficiency\ncube.rigid_body.collision_shape = 'BOX'\n\nprint(f\"Created passive cube at {cube.location}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Rotation Y: {math.degrees(cube.rotation_euler.y):.1f}°\")\n```\n</implementation>"}
{"id": 247, "instruction": "Place a Passive cylinder (radius 1.8, height 3.5) at (-10, 0, 6) and rotate it 25° on the X-axis.", "answer": "<strategic_analysis>\nThis is a straightforward object placement task with no kinematic or dynamic requirements. The goal is to precisely create a static cylindrical obstacle at a specified location and orientation. Since it's a passive rigid body, it will remain fixed during any subsequent simulations, serving as an immovable object in the environment.\n</strategic_analysis>\n\n<spatial_layout>\n- Cylinder Base Center (world coordinates): (-10.0, 0.0, 6.0)\n- Cylinder Dimensions: radius = 1.8 m, height = 3.5 m\n- Rotation: 25° around the global X-axis. In Blender's right-handed coordinate system (Z-up), a positive rotation about X tilts the top towards negative Y.\n- Since the cylinder's origin is at its center, the final position places the geometric center at Z=6.0. The cylinder extends ±1.75m along its local Z-axis (which is rotated).\n</spatial_layout>\n\n<kinematic_topology>\n- world -> cylinder (Static Mesh, Passive Rigid Body). No joints or hierarchy needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: The cylinder is a passive object placed at Z=6, so it is elevated but static. Its base is not in contact with the ground (Z=0), so it appears to be floating. This may be intentional for the scenario (e.g., an aerial obstacle). No risk of tipping.\n- Physical Properties: As a passive rigid body, it will not move under collisions unless animated externally.\n</predictive_simulation>\n\n<parameter_summary>\n- cylinder_location: (-10.0, 0.0, 6.0)\n- cylinder_radius: 1.8\n- cylinder_height: 3.5\n- rotation_x_degrees: 25.0\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects (optional, for a clean scene)\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cylinder with specified radius and height\nbpy.ops.mesh.primitive_cylinder_add(\n    vertices=32,            # Smoothness\n    radius=1.8,\n    depth=3.5,\n    location=(-10.0, 0.0, 6.0)\n)\ncylinder = bpy.context.active_object\ncylinder.name = \"Passive_Cylinder\"\n\n# Rotate 25 degrees around X-axis (convert to radians)\ncylinder.rotation_euler[0] = math.radians(25.0)\n\n# Add rigid body physics, set to PASSIVE (static)\nbpy.ops.rigidbody.object_add()\ncylinder.rigid_body.type = 'PASSIVE'\ncylinder.rigid_body.collision_shape = 'MESH'  # More accurate than 'CONVEX_HULL' for a cylinder\n```\n</implementation>"}
{"id": 250, "instruction": "Place an Active sphere (radius 2.3) at (-12, 10, 0) and rotate it 60° on the X-axis.", "answer": "<strategic_analysis>\nThe task involves creating a single dynamic rigid body sphere with specific geometric properties (radius=2.3), spatial placement (location=(-12, 10, 0)), and rotational state (60° about X-axis). This requires clean Blender object creation, transformation application, and rigid body physics setup without inter-object relationships.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere Radius (R): 2.3 units\n- Center Location: (X, Y, Z) = (-12.0, 10.0, 0.0)\n- Rotation: 60° about X-axis = 1.04719755 radians (π/3)\n- Transform Order: Apply rotation first (local space), then translation to world coordinates.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> sphere (Single active rigid body with no parent constraints)\n- All transformations applied directly to the sphere's object matrix.\n</kinematic_topology>\n\n<predictive_simulation>\n- As a lone active rigid body sphere, initial rotation will affect its collision response when simulation starts.\n- With default gravity (-9.81 Z), the sphere will fall and roll/tumble starting from rotated orientation.\n- No stability risks exist for single object.\n</predictive_simulation>\n\n<parameter_summary>\nsphere_radius: 2.3\nsphere_location: (-12.0, 10.0, 0.0)\nsphere_rotation_x_deg: 60.0\nsphere_rotation_x_rad: 1.0471975511965976\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with specified radius\nbpy.ops.mesh.primitive_uv_sphere_add(radius=2.3, location=(0, 0, 0))\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Apply X-axis rotation (60 degrees)\nsphere.rotation_euler.x = math.radians(60.0)\n\n# Set location after rotation to maintain correct orientation\nsphere.location = (-12.0, 10.0, 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\n```</implementation>"}
{"id": 248, "instruction": "Place an Active 3x1x5 cube at (0, 9, 12) and rotate it 45° on the Y-axis.", "answer": "<strategic_analysis>\nThis task involves placing a single rigid body cube with specified dimensions, location, and rotation. The cube must be configured as an Active rigid body in Blender's physics system, meaning it will respond to gravity and collisions. The primary considerations are accurate geometric placement and proper physics setup.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions (Width×Depth×Height): 3m × 1m × 5m.\n- Cube Location: World coordinates (0, 9, 12).\n- Cube Rotation: 45° around the global Y-axis (0.785398 rad).\n- Origin: The cube's origin will be at its geometric center by default.\n</spatial_layout>\n\n<kinematic_topology>\nSingle independent rigid body object with no parent-child relationships or joints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- The cube is active, so it will fall under gravity (default -Z direction in Blender).\n- Since it's placed at Z=12, it will fall until it collides with a passive object (e.g., ground plane). If no ground exists, it will fall indefinitely.\n- Rotation is applied before dynamics, so the cube's initial orientation is tilted 45° around Y.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (3.0, 1.0, 5.0)\n- cube_location: (0.0, 9.0, 12.0)\n- cube_rotation_y: 45.0 (degrees)\n- rigidbody_type: ACTIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube with default dimensions (2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Scale to achieve 3x1x5 dimensions\n# Since default cube is 2x2x2, scale factors = desired/2\ncube.scale = (1.5, 0.5, 2.5)  # (3/2, 1/2, 5/2)\n\n# Apply scale to make transformations clean\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (0.0, 9.0, 12.0)\ncube.rotation_euler = (0.0, math.radians(45.0), 0.0)\n\n# Add rigid body physics (Active)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Optionally add a ground plane for the cube to fall onto\nbpy.ops.mesh.primitive_plane_add(size=50.0, location=(0, 0, 0))\nground = bpy.context.active_object\nground.name = \"Ground\"\nbpy.ops.rigidbody.object_add()\nground.rigid_body.type = 'PASSIVE'\n\n# Set gravity to default -Z (if not already)\nbpy.context.scene.use_gravity = True\nbpy.context.scene.gravity = (0.0, 0.0, -9.81)\n\nprint(f\"Created active cube: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation Y: {math.degrees(cube.rotation_euler.y):.1f}°\")\n```\n</implementation>"}
{"id": 242, "instruction": "Place an Active sphere (radius 3) at (-6, 12, 2) and rotate it 15° on the Y-axis.", "answer": "<strategic_analysis>\nWe need to create a sphere with radius 3, position it at coordinates (-6, 12, 2), and apply a 15-degree rotation around the Y-axis. The sphere should be an active rigid body, meaning it will respond to physics forces like gravity and collisions. This requires careful coordinate system handling in Blender's right-handed Z-up coordinate system.\n</strategic_analysis>\n\n<spatial_layout>\n- Sphere radius: r = 3.0 units.\n- Sphere center location: (x, y, z) = (-6.0, 12.0, 2.0).\n- Rotation angle: θ = 15° around the global Y-axis.\n- Rotation conversion: 15° × (π/180) = 0.2617993878 radians.\n- The sphere's mesh vertices will be transformed by this rotation after placement.\n</spatial_layout>\n\n<kinematic_topology>\n- world → sphere_object (single mesh with rigid body physics)\n- No joints or hierarchies needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- The sphere's active rigid body status will make it fall under gravity by default (if gravity is enabled).\n- The initial rotation may affect collision response if the sphere has non-uniform surface properties.\n- Without constraints, the sphere will behave as a free-falling rigid body with the specified initial orientation.\n</predictive_simulation>\n\n<parameter_summary>\n- sphere_radius: 3.0\n- sphere_location: (-6.0, 12.0, 2.0)\n- rotation_y_degrees: 15.0\n- rotation_y_radians: 0.2617993878\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create sphere with radius 3\nbpy.ops.mesh.primitive_uv_sphere_add(radius=3.0)\nsphere = bpy.context.active_object\nsphere.name = \"Active_Sphere\"\n\n# Set location\nsphere.location = (-6.0, 12.0, 2.0)\n\n# Apply rotation: 15 degrees around Y-axis\nsphere.rotation_euler = (0.0, math.radians(15.0), 0.0)\n\n# Add active rigid body physics\nbpy.ops.rigidbody.object_add()\nsphere.rigid_body.type = 'ACTIVE'\nsphere.rigid_body.collision_shape = 'SPHERE'\n```\n</implementation>"}
{"id": 244, "instruction": "Place an Active 4x3x1 cube at (-2, 10, -10) and rotate it 30° on the X-axis.", "answer": "<strategic_analysis>\nThe task is straightforward: create a single active rigid body cube with specified dimensions, location, and rotation. This involves basic 3D modeling and rigid body physics setup without complex mechanisms or constraints.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube dimensions: 4m (X) × 3m (Y) × 1m (Z)\n- World location: (-2, 10, -10)\n- Rotation: 30° around the X-axis (converted to radians: 30° × π/180 ≈ 0.5236 rad)\n- The cube's origin will be at its geometric center by default in Blender.\n</spatial_layout>\n\n<kinematic_topology>\nSingle object hierarchy:\n- world → cube (Active Rigid Body)\nNo joints or constraints required.\n</kinematic_topology>\n\n<predictive_simulation>\n- As an active rigid body, the cube will respond to gravity and collisions.\n- The 30° X-axis rotation means it will initially be tilted, affecting its stability and how it interacts with other objects.\n- No stability risks since it's a standalone object.\n</predictive_simulation>\n\n<parameter_summary>\ncube_dimensions: (4.0, 3.0, 1.0)\ncube_location: (-2.0, 10.0, -10.0)\ncube_rotation_deg: (30.0, 0.0, 0.0)\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create cube with default 2x2x2 dimensions\nbpy.ops.mesh.primitive_cube_add(size=2.0)\ncube = bpy.context.active_object\ncube.name = \"Active_Cube\"\n\n# Set dimensions to 4x3x1\ncube.dimensions = (4.0, 3.0, 1.0)\n\n# Apply scale to make dimensions permanent\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location\ncube.location = (-2.0, 10.0, -10.0)\n\n# Set rotation (convert 30 degrees to radians)\ncube.rotation_euler = (math.radians(30.0), 0.0, 0.0)\n\n# Add active rigid body\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'ACTIVE'\n\n# Set rigid body mass based on volume (assuming density 1 kg/m³)\nvolume = 4.0 * 3.0 * 1.0\ncube.rigid_body.mass = volume\n\nprint(f\"Created active cube: {cube.name}\")\nprint(f\"  Dimensions: {cube.dimensions}\")\nprint(f\"  Location: {cube.location}\")\nprint(f\"  Rotation (degrees): ({math.degrees(cube.rotation_euler.x):.1f}, 0, 0)\")\n```\n</implementation>"}
{"id": 249, "instruction": "Place a Passive 5x2x2 cube at (9, 0, 5) and rotate it 30° on the Z-axis.", "answer": "<strategic_analysis>\nThe task requires creating a static environmental object with specific placement and orientation. This is a foundational scene setup task requiring accurate spatial positioning, scaling, and rigid body property assignment. The cube will serve as an immovable obstacle or platform in simulations. No dynamic components or complex kinematics are involved.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: 5m (X) × 2m (Y) × 2m (Z) in world coordinates.\n- Location: World coordinates (9, 0, 5) positions the cube's origin at this point.\n- Rotation: 30° rotation about the Z-axis (vertical axis). This rotates the cube's local X and Y axes while keeping Z vertical.\n- Default Cube: Blender's default cube is 2×2×2m centered at origin. Scaling factors: X=5/2=2.5, Y=2/2=1.0, Z=2/2=1.0.\n- Object Origin: After scaling and rotation, the cube's center remains at (9, 0, 5). Corner positions will vary based on rotation.\n</spatial_layout>\n\n<kinematic_topology>\n- world → passive_cube (Single static mesh with rigid body physics)\n- No joints or hierarchical relationships needed.\n</kinematic_topology>\n\n<predictive_simulation>\n- The 30° rotation creates asymmetrical collision geometry relative to world axes.\n- As a passive rigid body, the cube will remain fixed during simulations, providing reliable collision surfaces.\n- The height (Z=5) places it above ground level, potentially creating an elevated platform or barrier.\n- Mass properties irrelevant for passive bodies but collision shape should match visual mesh.\n</predictive_simulation>\n\n<parameter_summary>\n- cube_dimensions: (5.0, 2.0, 2.0)\n- cube_location: (9.0, 0.0, 5.0)\n- cube_rotation_z_deg: 30.0\n- default_cube_size: 2.0\n- scale_factors: (2.5, 1.0, 1.0)\n- rigidbody_type: 'PASSIVE'\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing mesh objects\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create default cube (2m³)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"passive_cube\"\n\n# Scale to desired dimensions (5×2×2)\ncube.scale = (2.5, 1.0, 1.0)\n\n# Apply scale transform to make it actual mesh data\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (9.0, 0.0, 5.0)\ncube.rotation_euler = (0.0, 0.0, math.radians(30.0))\n\n# Add rigid body physics (passive/static)\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\n\n# Optional: Set collision shape to match mesh exactly\ncube.rigid_body.collision_shape = 'MESH'\n\n# Verify transformations\nprint(f\"Created: {cube.name}\")\nprint(f\"Dimensions: {cube.dimensions}\")\nprint(f\"Location: {cube.location}\")\nprint(f\"Rotation: {math.degrees(cube.rotation_euler.z):.1f}° Z\")\n```\n</implementation>"}
{"id": 241, "instruction": "Place a Passive 1x1x6 cube at (12, 0, 0) and rotate it 90° on the X-axis.", "answer": "<strategic_analysis>\nThe task is purely kinematic: create a static, non-moving rectangular prism (cube) with specific dimensions, location, and orientation. Since it's designated as \"Passive,\" it will serve as an immovable obstacle or structural element in a physics simulation. The 90° X-axis rotation will reorient the long axis from vertical (default Z-up) to horizontal along the global Y-axis.\n</strategic_analysis>\n\n<spatial_layout>\n- Cube Dimensions: (width=1.0, depth=1.0, height=6.0) in meters.\n- Location: World coordinates (12.0, 0.0, 0.0).\n- Rotation: 90° about X-axis converts to radians: θ = 90° × (π/180) = π/2 ≈ 1.5708 rad.\n- Post-rotation orientation: The local Z-axis (original \"up\") becomes aligned with the global -Y direction. The cube's long dimension (height) now extends along the global Y-axis.\n</spatial_layout>\n\n<kinematic_topology>\n- world -> passive_cube (Single static rigid body with no joints or parent).\n</kinematic_topology>\n\n<predictive_simulation>\n- Stability: As a passive rigid body with default mass distribution, the cube is stable due to its low center of mass (located at (12, 0, 0)) and wide base relative to height after rotation.\n- Risk: None. The object is static and will not move under simulation.\n- Simulation Role: Will act as an immovable obstacle for other active rigid bodies.\n</predictive_simulation>\n\n<parameter_summary>\ncube_location: (12.0, 0.0, 0.0)\ncube_dimensions: (1.0, 1.0, 6.0)\ncube_rotation_x_deg: 90.0\ncube_rotation_x_rad: 1.5708\nrigidbody_type: PASSIVE\n</parameter_summary>\n\n<implementation>\n```python\nimport bpy\nimport math\n\n# Clear existing scene\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Create cube (default 2x2x2)\nbpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))\ncube = bpy.context.active_object\ncube.name = \"Passive_Cube\"\n\n# Scale to achieve 1x1x6 dimensions (since default cube is 2 units per side)\n# scale_factor = desired_length / default_length (2.0)\nscale_x = 1.0 / 2.0\nscale_y = 1.0 / 2.0\nscale_z = 6.0 / 2.0\ncube.scale = (scale_x, scale_y, scale_z)\n\n# Apply scale to avoid distortion in physics\nbpy.ops.object.transform_apply(scale=True)\n\n# Set location and rotation\ncube.location = (12.0, 0.0, 0.0)\ncube.rotation_euler = (math.radians(90.0), 0.0, 0.0)\n\n# Add rigid body physics as passive\nbpy.ops.rigidbody.object_add()\ncube.rigid_body.type = 'PASSIVE'\ncube.rigid_body.collision_shape = 'BOX'\n\n# Optional: Set display to see dimensions clearly\nbpy.context.object.display_type = 'WIRE'\n```\n</implementation>"}
